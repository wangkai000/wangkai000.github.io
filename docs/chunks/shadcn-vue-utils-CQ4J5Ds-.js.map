{"version":3,"file":"shadcn-vue-utils-CQ4J5Ds-.js","sources":["../../node_modules/.pnpm/@floating-ui+utils@0.2.4/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../node_modules/.pnpm/@floating-ui+core@1.6.4/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../node_modules/.pnpm/@floating-ui+utils@0.2.4/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../node_modules/.pnpm/@floating-ui+dom@1.6.7/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../node_modules/.pnpm/@floating-ui+vue@1.1.1_vue@3.4.33_typescript@5.5.3_/node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs","../../node_modules/.pnpm/radix-vue@1.9.2_vue@3.4.33_typescript@5.5.3_/node_modules/radix-vue/dist/index.js","../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs","../../node_modules/.pnpm/tailwind-merge@2.4.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs","../../src/utils/shadcn-vue-utils.ts"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isTopLayer(currentNode)) {\n      return null;\n    }\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\nfunction toValue(source) {\n  return typeof source === 'function' ? source() : unref(source);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(toValue(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _toValue;\n    return (_toValue = toValue(options.open)) != null ? _toValue : true;\n  });\n  const middlewareOption = computed(() => toValue(options.middleware));\n  const placementOption = computed(() => {\n    var _toValue2;\n    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _toValue3;\n    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _toValue4;\n    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","import { inject as ol, provide as ll, shallowRef as Mn, watchEffect as ye, readonly as Ka, customRef as sl, ref as I, computed as B, watch as te, nextTick as le, getCurrentScope as ur, onScopeDispose as rl, effectScope as il, unref as o, onBeforeUnmount as Vn, onMounted as se, isRef as Xe, reactive as Ma, getCurrentInstance as vt, onUpdated as ul, Fragment as _e, defineComponent as w, toRefs as ne, renderSlot as C, onBeforeUpdate as dr, toHandlerKey as cr, camelize as dl, toRef as pr, onUnmounted as Ie, mergeProps as k, h as pt, Comment as fr, cloneVNode as Fn, openBlock as b, createBlock as _, withCtx as y, createVNode as Y, createCommentVNode as pe, withKeys as re, Teleport as Wt, normalizeProps as K, guardReactiveProps as j, normalizeStyle as Oe, withModifiers as ie, createElementBlock as ce, withDirectives as Ha, vShow as Ln, createElementVNode as Ue, toDisplayString as $e, createTextVNode as ve, mergeDefaults as cl, renderList as va, markRaw as vr, watchSyncEffect as mr, resolveDynamicComponent as Ge, toHandlers as Nn, triggerRef as Mo, useSlots as Wa, onBeforeMount as pl, vModelSelect as hr, toRaw as yr } from \"vue\";\nimport { CalendarDateTime as gr, CalendarDate as br, DateFormatter as lt, today as Cr, getLocalTimeZone as zn, isEqualMonth as Vo, isSameDay as Te, isEqualDay as Ee, isToday as fl, isSameMonth as vl } from \"@internationalized/date\";\nimport { k as ra, t as Le, j as ml, d as wt, n as Sa, m as ke, l as Et, x as hl, u as wr, r as _r } from \"./calendar-ChFCRr4K.js\";\nimport { useFloating as xr, autoUpdate as Sr, offset as Er, flip as Fo, shift as Pr, limitShift as Dr, size as $r, arrow as Br, hide as Ir } from \"@floating-ui/vue\";\nimport { NumberFormatter as Tr, NumberParser as Rr } from \"@internationalized/number\";\nfunction Q(a, t) {\n  const e = typeof a == \"string\" && !t ? `${a}Context` : t, n = Symbol(e);\n  return [(r) => {\n    const i = ol(n, r);\n    if (i || i === null)\n      return i;\n    throw new Error(\n      `Injection \\`${n.toString()}\\` not found. Component must be used within ${Array.isArray(a) ? `one of the following components: ${a.join(\n        \", \"\n      )}` : `\\`${a}\\``}`\n    );\n  }, (r) => (ll(n, r), r)];\n}\nfunction zt(a, t, e) {\n  const n = e.originalEvent.target, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction Kt(a, t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {\n  return Math.min(Math.max(a, t), e);\n}\nfunction Ea(a, t) {\n  let e = a;\n  const n = t.toString(), l = n.indexOf(\".\"), s = l >= 0 ? n.length - l : 0;\n  if (s > 0) {\n    const r = 10 ** s;\n    e = Math.round(e * r) / r;\n  }\n  return e;\n}\nfunction Ar(a, t, e, n) {\n  t = Number(t), e = Number(e);\n  const l = (a - (Number.isNaN(t) ? 0 : t)) % n;\n  let s = Ea(Math.abs(l) * 2 >= n ? a + Math.sign(l) * (n - Math.abs(l)) : a - l, n);\n  return Number.isNaN(t) ? !Number.isNaN(e) && s > e && (s = Math.floor(Ea(e / n, n)) * n) : s < t ? s = t : !Number.isNaN(e) && s > e && (s = t + Math.floor(Ea((e - t) / n, n)) * n), s = Ea(s, n), s;\n}\nfunction Or(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nvar kr = function a(t, e) {\n  if (t === e) return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor) return !1;\n    var n, l, s;\n    if (Array.isArray(t)) {\n      if (n = t.length, n != e.length) return !1;\n      for (l = n; l-- !== 0; )\n        if (!a(t[l], e[l])) return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString();\n    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length) return !1;\n    for (l = n; l-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, s[l])) return !1;\n    for (l = n; l-- !== 0; ) {\n      var r = s[l];\n      if (!a(t[r], e[r])) return !1;\n    }\n    return !0;\n  }\n  return t !== t && e !== e;\n};\nconst Ye = /* @__PURE__ */ Or(kr);\nfunction Mr(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction St(a, t, e) {\n  const n = a.findIndex((i) => Ye(i, t)), l = a.findIndex((i) => Ye(i, e));\n  if (n === -1 || l === -1)\n    return [];\n  const [s, r] = [n, l].sort((i, u) => i - u);\n  return a.slice(s, r + 1);\n}\nconst ma = typeof document < \"u\";\nfunction Nt(a) {\n  return a == null;\n}\nfunction jt(a) {\n  const { defaultValue: t, defaultPlaceholder: e, granularity: n = \"day\" } = a;\n  if (Array.isArray(t) && t.length)\n    return t.at(-1).copy();\n  if (t && !Array.isArray(t))\n    return t.copy();\n  if (e)\n    return e.copy();\n  const l = /* @__PURE__ */ new Date(), s = l.getFullYear(), r = l.getMonth() + 1, i = l.getDate();\n  return [\"hour\", \"minute\", \"second\"].includes(n ?? \"day\") ? new gr(s, r, i, 0, 0, 0) : new br(s, r, i);\n}\nconst Vr = [\n  \"ach\",\n  \"af\",\n  \"am\",\n  \"an\",\n  \"ar\",\n  \"ast\",\n  \"az\",\n  \"be\",\n  \"bg\",\n  \"bn\",\n  \"br\",\n  \"bs\",\n  \"ca\",\n  \"cak\",\n  \"ckb\",\n  \"cs\",\n  \"cy\",\n  \"da\",\n  \"de\",\n  \"dsb\",\n  \"el\",\n  \"en\",\n  \"eo\",\n  \"es\",\n  \"et\",\n  \"eu\",\n  \"fa\",\n  \"ff\",\n  \"fi\",\n  \"fr\",\n  \"fy\",\n  \"ga\",\n  \"gd\",\n  \"gl\",\n  \"he\",\n  \"hr\",\n  \"hsb\",\n  \"hu\",\n  \"ia\",\n  \"id\",\n  \"it\",\n  \"ja\",\n  \"ka\",\n  \"kk\",\n  \"kn\",\n  \"ko\",\n  \"lb\",\n  \"lo\",\n  \"lt\",\n  \"lv\",\n  \"meh\",\n  \"ml\",\n  \"ms\",\n  \"nl\",\n  \"nn\",\n  \"no\",\n  \"oc\",\n  \"pl\",\n  \"pt\",\n  \"rm\",\n  \"ro\",\n  \"ru\",\n  \"sc\",\n  \"scn\",\n  \"sk\",\n  \"sl\",\n  \"sr\",\n  \"sv\",\n  \"szl\",\n  \"tg\",\n  \"th\",\n  \"tr\",\n  \"uk\",\n  \"zh-CN\",\n  \"zh-TW\"\n], Fr = [\"year\", \"month\", \"day\"], hn = {\n  ach: { year: \"mwaka\", month: \"dwe\", day: \"nino\" },\n  af: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  am: { year: \"ዓዓዓዓ\", month: \"ሚሜ\", day: \"ቀቀ\" },\n  an: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ar: { year: \"سنة\", month: \"شهر\", day: \"يوم\" },\n  ast: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  az: { year: \"iiii\", month: \"aa\", day: \"gg\" },\n  be: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  bg: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  bn: { year: \"yyyy\", month: \"মিমি\", day: \"dd\" },\n  br: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  bs: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  ca: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  cak: { year: \"jjjj\", month: \"ii\", day: \"q'q'\" },\n  ckb: { year: \"ساڵ\", month: \"مانگ\", day: \"ڕۆژ\" },\n  cs: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  cy: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  da: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  de: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  dsb: { year: \"llll\", month: \"mm\", day: \"źź\" },\n  el: { year: \"εεεε\", month: \"μμ\", day: \"ηη\" },\n  en: { year: \"yyyy\", month: \"mm\", day: \"dd\" },\n  eo: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  es: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  et: { year: \"aaaa\", month: \"kk\", day: \"pp\" },\n  eu: { year: \"uuuu\", month: \"hh\", day: \"ee\" },\n  fa: { year: \"سال\", month: \"ماه\", day: \"روز\" },\n  ff: { year: \"hhhh\", month: \"ll\", day: \"ññ\" },\n  fi: { year: \"vvvv\", month: \"kk\", day: \"pp\" },\n  fr: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  fy: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  ga: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gd: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gl: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  he: { year: \"שנה\", month: \"חודש\", day: \"יום\" },\n  hr: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  hsb: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  hu: { year: \"éééé\", month: \"hh\", day: \"nn\" },\n  ia: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  id: { year: \"tttt\", month: \"bb\", day: \"hh\" },\n  it: { year: \"aaaa\", month: \"mm\", day: \"gg\" },\n  ja: { year: \" 年 \", month: \"月\", day: \"日\" },\n  ka: { year: \"წწწწ\", month: \"თთ\", day: \"რრ\" },\n  kk: { year: \"жжжж\", month: \"аа\", day: \"кк\" },\n  kn: { year: \"ವವವವ\", month: \"ಮಿಮೀ\", day: \"ದಿದಿ\" },\n  ko: { year: \"연도\", month: \"월\", day: \"일\" },\n  lb: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  lo: { year: \"ປປປປ\", month: \"ດດ\", day: \"ວວ\" },\n  lt: { year: \"mmmm\", month: \"mm\", day: \"dd\" },\n  lv: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  meh: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ml: { year: \"വർഷം\", month: \"മാസം\", day: \"തീയതി\" },\n  ms: { year: \"tttt\", month: \"mm\", day: \"hh\" },\n  nl: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  nn: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  no: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  oc: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  pl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  pt: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  rm: { year: \"oooo\", month: \"mm\", day: \"dd\" },\n  ro: { year: \"aaaa\", month: \"ll\", day: \"zz\" },\n  ru: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  sc: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  scn: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  sk: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  sl: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  sr: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  sv: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  szl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  tg: { year: \"сссс\", month: \"мм\", day: \"рр\" },\n  th: { year: \"ปปปป\", month: \"ดด\", day: \"วว\" },\n  tr: { year: \"yyyy\", month: \"aa\", day: \"gg\" },\n  uk: { year: \"рррр\", month: \"мм\", day: \"дд\" },\n  \"zh-CN\": { year: \"年\", month: \"月\", day: \"日\" },\n  \"zh-TW\": { year: \"年\", month: \"月\", day: \"日\" }\n};\nfunction Lr(a) {\n  if (Lo(a))\n    return hn[a];\n  {\n    const t = Hr(a);\n    return Lo(t) ? hn[t] : hn.en;\n  }\n}\nfunction yn(a, t, e) {\n  return Nr(a) ? Lr(e)[a] : Kr(a) ? t : zr(a) ? \"––\" : \"\";\n}\nfunction Lo(a) {\n  return Vr.includes(a);\n}\nfunction Nr(a) {\n  return Fr.includes(a);\n}\nfunction zr(a) {\n  return a === \"hour\" || a === \"minute\" || a === \"second\";\n}\nfunction Kr(a) {\n  return a === \"era\" || a === \"dayPeriod\";\n}\nfunction Hr(a) {\n  return Intl.Locale ? new Intl.Locale(a).language : a.split(\"-\")[0];\n}\nconst Kn = [\"day\", \"month\", \"year\"], yl = [\"hour\", \"minute\", \"second\", \"dayPeriod\"], gl = [...Kn, ...yl];\nfunction Wr(a) {\n  return Kn.includes(a);\n}\nfunction bl(a) {\n  return gl.includes(a);\n}\nfunction jr(a, t) {\n  const e = {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZoneName: \"short\",\n    hourCycle: t === 24 ? \"h24\" : void 0,\n    hour12: t === 24 ? !1 : void 0\n  };\n  return a === \"day\" && (delete e.second, delete e.hour, delete e.minute, delete e.timeZoneName), a === \"hour\" && (delete e.minute, delete e.second), a === \"minute\" && delete e.second, e;\n}\nfunction Cl(a) {\n  const t = a.querySelector(\"[data-selected]\");\n  if (t)\n    return t.focus();\n  const e = a.querySelector(\"[data-today]\");\n  if (e)\n    return e.focus();\n  const n = a.querySelector(\"[data-radix-vue-calendar-day]\");\n  if (n)\n    return n.focus();\n}\nfunction Ur(a, t) {\n  var e;\n  const n = Mn();\n  return ye(() => {\n    n.value = a();\n  }, {\n    ...t,\n    flush: (e = void 0) != null ? e : \"sync\"\n  }), Ka(n);\n}\nfunction Gr(a, t) {\n  let e, n, l;\n  const s = I(!0), r = () => {\n    s.value = !0, l();\n  };\n  te(a, r, { flush: \"sync\" });\n  const i = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = sl((c, p) => (n = c, l = p, {\n    get() {\n      return s.value && (e = i(), s.value = !1), n(), e;\n    },\n    set(f) {\n      u == null || u(f);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = r), d;\n}\nfunction mt(a) {\n  return ur() ? (rl(a), !0) : !1;\n}\nfunction ia() {\n  const a = /* @__PURE__ */ new Set(), t = (l) => {\n    a.delete(l);\n  };\n  return {\n    on: (l) => {\n      a.add(l);\n      const s = () => t(l);\n      return mt(s), {\n        off: s\n      };\n    },\n    off: t,\n    trigger: (...l) => Promise.all(Array.from(a).map((s) => s(...l)))\n  };\n}\nfunction qr(a) {\n  let t = !1, e;\n  const n = il(!0);\n  return (...l) => (t || (e = n.run(() => a(...l)), t = !0), e);\n}\nfunction Yr(a) {\n  let t = 0, e, n;\n  const l = () => {\n    t -= 1, n && t <= 0 && (n.stop(), e = void 0, n = void 0);\n  };\n  return (...s) => (t += 1, e || (n = il(!0), e = n.run(() => a(...s))), mt(l), e);\n}\nfunction Ne(a) {\n  return typeof a == \"function\" ? a() : o(a);\n}\nfunction Xr(a) {\n  if (!Xe(a))\n    return Ma(a);\n  const t = new Proxy({}, {\n    get(e, n, l) {\n      return o(Reflect.get(a.value, n, l));\n    },\n    set(e, n, l) {\n      return Xe(a.value[n]) && !Xe(l) ? a.value[n].value = l : a.value[n] = l, !0;\n    },\n    deleteProperty(e, n) {\n      return Reflect.deleteProperty(a.value, n);\n    },\n    has(e, n) {\n      return Reflect.has(a.value, n);\n    },\n    ownKeys() {\n      return Object.keys(a.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: !0,\n        configurable: !0\n      };\n    }\n  });\n  return Ma(t);\n}\nfunction wl(a) {\n  return Xr(B(a));\n}\nconst Je = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst Zr = (a) => typeof a < \"u\", Jr = (a) => a != null, Qr = Object.prototype.toString, ei = (a) => Qr.call(a) === \"[object Object]\", Va = () => {\n}, No = /* @__PURE__ */ ti();\nfunction ti() {\n  var a, t;\n  return Je && ((a = window == null ? void 0 : window.navigator) == null ? void 0 : a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction _l(a, t) {\n  function e(...n) {\n    return new Promise((l, s) => {\n      Promise.resolve(a(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(l).catch(s);\n    });\n  }\n  return e;\n}\nconst xl = (a) => a();\nfunction ai(a, t = {}) {\n  let e, n, l = Va;\n  const s = (i) => {\n    clearTimeout(i), l(), l = Va;\n  };\n  return (i) => {\n    const u = Ne(a), d = Ne(t.maxWait);\n    return e && s(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (s(n), n = null), Promise.resolve(i())) : new Promise((c, p) => {\n      l = t.rejectOnCancel ? p : c, d && !n && (n = setTimeout(() => {\n        e && s(e), n = null, c(i());\n      }, d)), e = setTimeout(() => {\n        n && s(n), n = null, c(i());\n      }, u);\n    });\n  };\n}\nfunction ni(a = xl) {\n  const t = I(!0);\n  function e() {\n    t.value = !1;\n  }\n  function n() {\n    t.value = !0;\n  }\n  const l = (...s) => {\n    t.value && a(...s);\n  };\n  return { isActive: Ka(t), pause: e, resume: n, eventFilter: l };\n}\nfunction Sl(a) {\n  return vt();\n}\nfunction Dt(a, t = 1e4) {\n  return sl((e, n) => {\n    let l = Ne(a), s;\n    const r = () => setTimeout(() => {\n      l = Ne(a), n();\n    }, Ne(t));\n    return mt(() => {\n      clearTimeout(s);\n    }), {\n      get() {\n        return e(), l;\n      },\n      set(i) {\n        l = i, n(), clearTimeout(s), s = r();\n      }\n    };\n  });\n}\nfunction Hn(a, t = 200, e = {}) {\n  return _l(\n    ai(t, e),\n    a\n  );\n}\nfunction oi(a, t, e = {}) {\n  const {\n    eventFilter: n = xl,\n    ...l\n  } = e;\n  return te(\n    a,\n    _l(\n      n,\n      t\n    ),\n    l\n  );\n}\nfunction zo(a, t, e = {}) {\n  const {\n    eventFilter: n,\n    ...l\n  } = e, { eventFilter: s, pause: r, resume: i, isActive: u } = ni(n);\n  return { stop: oi(\n    a,\n    t,\n    {\n      ...l,\n      eventFilter: s\n    }\n  ), pause: r, resume: i, isActive: u };\n}\nfunction li(a, t, ...[e]) {\n  const {\n    flush: n = \"sync\",\n    deep: l = !1,\n    immediate: s = !0,\n    direction: r = \"both\",\n    transform: i = {}\n  } = e || {}, u = [], d = \"ltr\" in i && i.ltr || ((f) => f), c = \"rtl\" in i && i.rtl || ((f) => f);\n  return (r === \"both\" || r === \"ltr\") && u.push(zo(\n    a,\n    (f) => {\n      u.forEach((v) => v.pause()), t.value = d(f), u.forEach((v) => v.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), (r === \"both\" || r === \"rtl\") && u.push(zo(\n    t,\n    (f) => {\n      u.forEach((v) => v.pause()), a.value = c(f), u.forEach((v) => v.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), () => {\n    u.forEach((f) => f.stop());\n  };\n}\nfunction si(a, t) {\n  Sl() && Vn(a, t);\n}\nfunction ri(a, t = !0, e) {\n  Sl() ? se(a, e) : t ? a() : le(a);\n}\nfunction Wn(a, t, e = {}) {\n  const {\n    immediate: n = !0\n  } = e, l = I(!1);\n  let s = null;\n  function r() {\n    s && (clearTimeout(s), s = null);\n  }\n  function i() {\n    l.value = !1, r();\n  }\n  function u(...d) {\n    r(), l.value = !0, s = setTimeout(() => {\n      l.value = !1, s = null, a(...d);\n    }, Ne(t));\n  }\n  return n && (l.value = !0, Je && u()), mt(i), {\n    isPending: Ka(l),\n    start: u,\n    stop: i\n  };\n}\nfunction ii(a = 1e3, t = {}) {\n  const {\n    controls: e = !1,\n    callback: n\n  } = t, l = Wn(\n    n ?? Va,\n    a,\n    t\n  ), s = B(() => !l.isPending.value);\n  return e ? {\n    ready: s,\n    ...l\n  } : s;\n}\nfunction ui(a, t, e) {\n  const n = te(a, (...l) => (le(() => n()), t(...l)), e);\n  return n;\n}\nfunction Be(a) {\n  var t;\n  const e = Ne(a);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst Ut = Je ? window : void 0;\nfunction je(...a) {\n  let t, e, n, l;\n  if (typeof a[0] == \"string\" || Array.isArray(a[0]) ? ([e, n, l] = a, t = Ut) : [t, e, n, l] = a, !t)\n    return Va;\n  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);\n  const s = [], r = () => {\n    s.forEach((c) => c()), s.length = 0;\n  }, i = (c, p, f, v) => (c.addEventListener(p, f, v), () => c.removeEventListener(p, f, v)), u = te(\n    () => [Be(t), Ne(l)],\n    ([c, p]) => {\n      if (r(), !c)\n        return;\n      const f = ei(p) ? { ...p } : p;\n      s.push(\n        ...e.flatMap((v) => n.map((g) => i(c, v, g, f)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), d = () => {\n    u(), r();\n  };\n  return mt(d), d;\n}\nfunction di(a) {\n  return typeof a == \"function\" ? a : typeof a == \"string\" ? (t) => t.key === a : Array.isArray(a) ? (t) => a.includes(t.key) : () => !0;\n}\nfunction jn(...a) {\n  let t, e, n = {};\n  a.length === 3 ? (t = a[0], e = a[1], n = a[2]) : a.length === 2 ? typeof a[1] == \"object\" ? (t = !0, e = a[0], n = a[1]) : (t = a[0], e = a[1]) : (t = !0, e = a[0]);\n  const {\n    target: l = Ut,\n    eventName: s = \"keydown\",\n    passive: r = !1,\n    dedupe: i = !1\n  } = n, u = di(t);\n  return je(l, s, (c) => {\n    c.repeat && Ne(i) || u(c) && e(c);\n  }, r);\n}\nfunction ja() {\n  const a = I(!1), t = vt();\n  return t && se(() => {\n    a.value = !0;\n  }, t), a;\n}\nfunction El(a) {\n  const t = ja();\n  return B(() => (t.value, !!a()));\n}\nfunction Pl(a, t, e = {}) {\n  const { window: n = Ut, ...l } = e;\n  let s;\n  const r = El(() => n && \"MutationObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = B(() => {\n    const f = Ne(a), v = (Array.isArray(f) ? f : [f]).map(Be).filter(Jr);\n    return new Set(v);\n  }), d = te(\n    () => u.value,\n    (f) => {\n      i(), r.value && f.size && (s = new MutationObserver(t), f.forEach((v) => s.observe(v, l)));\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => s == null ? void 0 : s.takeRecords(), p = () => {\n    i(), d();\n  };\n  return mt(p), {\n    isSupported: r,\n    stop: p,\n    takeRecords: c\n  };\n}\nfunction ci(a = {}) {\n  var t;\n  const {\n    window: e = Ut,\n    deep: n = !0,\n    triggerOnRemoval: l = !1\n  } = a, s = (t = a.document) != null ? t : e == null ? void 0 : e.document, r = () => {\n    var d;\n    let c = s == null ? void 0 : s.activeElement;\n    if (n)\n      for (; c != null && c.shadowRoot; )\n        c = (d = c == null ? void 0 : c.shadowRoot) == null ? void 0 : d.activeElement;\n    return c;\n  }, i = I(), u = () => {\n    i.value = r();\n  };\n  return e && (je(e, \"blur\", (d) => {\n    d.relatedTarget === null && u();\n  }, !0), je(e, \"focus\", u, !0)), l && Pl(s, (d) => {\n    d.filter((c) => c.removedNodes.length).map((c) => Array.from(c.removedNodes)).flat().forEach((c) => {\n      c === i.value && u();\n    });\n  }, {\n    childList: !0,\n    subtree: !0\n  }), u(), i;\n}\nfunction Dl(a, t = {}) {\n  const {\n    immediate: e = !0,\n    fpsLimit: n = void 0,\n    window: l = Ut\n  } = t, s = I(!1), r = n ? 1e3 / n : null;\n  let i = 0, u = null;\n  function d(f) {\n    if (!s.value || !l)\n      return;\n    i || (i = f);\n    const v = f - i;\n    if (r && v < r) {\n      u = l.requestAnimationFrame(d);\n      return;\n    }\n    i = f, a({ delta: v, timestamp: f }), u = l.requestAnimationFrame(d);\n  }\n  function c() {\n    !s.value && l && (s.value = !0, i = 0, u = l.requestAnimationFrame(d));\n  }\n  function p() {\n    s.value = !1, u != null && l && (l.cancelAnimationFrame(u), u = null);\n  }\n  return e && c(), mt(p), {\n    isActive: Ka(s),\n    pause: p,\n    resume: c\n  };\n}\nfunction pi(a) {\n  return JSON.parse(JSON.stringify(a));\n}\nfunction fi(a) {\n  const t = vt(), e = Gr(\n    () => null,\n    () => t.proxy.$el\n  );\n  return ul(e.trigger), se(e.trigger), e;\n}\nfunction Ze(a, t, e = {}) {\n  const { window: n = Ut, ...l } = e;\n  let s;\n  const r = El(() => n && \"ResizeObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = B(() => Array.isArray(a) ? a.map((p) => Be(p)) : [Be(a)]), d = te(\n    u,\n    (p) => {\n      if (i(), r.value && n) {\n        s = new ResizeObserver(t);\n        for (const f of p)\n          f && s.observe(f, l);\n      }\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    i(), d();\n  };\n  return mt(c), {\n    isSupported: r,\n    stop: c\n  };\n}\nfunction vi(a, t = {}) {\n  const e = ci(t), n = B(() => Be(a));\n  return { focused: B(() => n.value && e.value ? n.value.contains(e.value) : !1) };\n}\nfunction $l(a = fi()) {\n  const t = Mn(), e = () => {\n    const n = Be(a);\n    n && (t.value = n.parentElement);\n  };\n  return ri(e), te(() => Ne(a), e), t;\n}\nfunction ae(a, t, e, n = {}) {\n  var l, s, r;\n  const {\n    clone: i = !1,\n    passive: u = !1,\n    eventName: d,\n    deep: c = !1,\n    defaultValue: p,\n    shouldEmit: f\n  } = n, v = vt(), g = e || (v == null ? void 0 : v.emit) || ((l = v == null ? void 0 : v.$emit) == null ? void 0 : l.bind(v)) || ((r = (s = v == null ? void 0 : v.proxy) == null ? void 0 : s.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));\n  let m = d;\n  t || (t = \"modelValue\"), m = m || `update:${t.toString()}`;\n  const S = (h) => i ? typeof i == \"function\" ? i(h) : pi(h) : h, x = () => Zr(a[t]) ? S(a[t]) : p, D = (h) => {\n    f ? f(h) && g(m, h) : g(m, h);\n  };\n  if (u) {\n    const h = x(), E = I(h);\n    let P = !1;\n    return te(\n      () => a[t],\n      ($) => {\n        P || (P = !0, E.value = S($), le(() => P = !1));\n      }\n    ), te(\n      E,\n      ($) => {\n        !P && ($ !== a[t] || c) && D($);\n      },\n      { deep: c }\n    ), E;\n  } else\n    return B({\n      get() {\n        return x();\n      },\n      set(h) {\n        D(h);\n      }\n    });\n}\nfunction Ua(a) {\n  return a ? a.flatMap((t) => t.type === _e ? Ua(t.children) : [t]) : [];\n}\nconst mi = [\"INPUT\", \"TEXTAREA\"];\nfunction $t(a, t, e, n = {}) {\n  if (!t || n.enableIgnoredElement && mi.includes(t.nodeName))\n    return null;\n  const {\n    arrowKeyOptions: l = \"both\",\n    attributeName: s = \"[data-radix-vue-collection-item]\",\n    itemsArray: r = [],\n    loop: i = !0,\n    dir: u = \"ltr\",\n    preventScroll: d = !0,\n    focus: c = !1\n  } = n, [p, f, v, g, m, S] = [\n    a.key === \"ArrowRight\",\n    a.key === \"ArrowLeft\",\n    a.key === \"ArrowUp\",\n    a.key === \"ArrowDown\",\n    a.key === \"Home\",\n    a.key === \"End\"\n  ], x = v || g, D = p || f;\n  if (!m && !S && (!x && !D || l === \"vertical\" && D || l === \"horizontal\" && x))\n    return null;\n  const h = e ? Array.from(e.querySelectorAll(s)) : r;\n  if (!h.length)\n    return null;\n  d && a.preventDefault();\n  let E = null;\n  return D || x ? E = Bl(h, t, {\n    goForward: x ? g : u === \"ltr\" ? p : f,\n    loop: i\n  }) : m ? E = h.at(0) || null : S && (E = h.at(-1) || null), c && (E == null || E.focus()), E;\n}\nfunction Bl(a, t, e, n = a.length) {\n  if (--n === 0)\n    return null;\n  const l = a.indexOf(t), s = e.goForward ? l + 1 : l - 1;\n  if (!e.loop && (s < 0 || s >= a.length))\n    return null;\n  const r = (s + a.length) % a.length, i = a[r];\n  return i ? i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\" ? Bl(\n    a,\n    i,\n    e,\n    n\n  ) : i : null;\n}\nfunction gn(a) {\n  if (a === null || typeof a != \"object\")\n    return !1;\n  const t = Object.getPrototypeOf(a);\n  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in a ? !1 : Symbol.toStringTag in a ? Object.prototype.toString.call(a) === \"[object Module]\" : !0;\n}\nfunction Pn(a, t, e = \".\", n) {\n  if (!gn(t))\n    return Pn(a, {}, e, n);\n  const l = Object.assign({}, t);\n  for (const s in a) {\n    if (s === \"__proto__\" || s === \"constructor\")\n      continue;\n    const r = a[s];\n    r != null && (n && n(l, s, r, e) || (Array.isArray(r) && Array.isArray(l[s]) ? l[s] = [...r, ...l[s]] : gn(r) && gn(l[s]) ? l[s] = Pn(\n      r,\n      l[s],\n      (e ? `${e}.` : \"\") + s.toString(),\n      n\n    ) : l[s] = r));\n  }\n  return l;\n}\nfunction hi(a) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, n) => Pn(e, n, \"\", a), {})\n  );\n}\nconst yi = hi(), [Ga, gi] = Q(\"ConfigProvider\"), uv = /* @__PURE__ */ w({\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: !0 },\n    nonce: { default: void 0 },\n    useId: { type: Function, default: void 0 }\n  },\n  setup(a) {\n    const t = a, { dir: e, scrollBody: n, nonce: l } = ne(t);\n    return gi({\n      dir: e,\n      scrollBody: n,\n      nonce: l,\n      useId: t.useId\n    }), (s, r) => C(s.$slots, \"default\");\n  }\n});\nlet bi = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\", Ci = (a = 21) => {\n  let t = \"\", e = a;\n  for (; e--; )\n    t += bi[Math.random() * 64 | 0];\n  return t;\n};\nconst wi = Yr(() => {\n  const a = I(/* @__PURE__ */ new Map()), t = I(), e = B(() => {\n    for (const r of a.value.values())\n      if (r)\n        return !0;\n    return !1;\n  }), n = Ga({\n    scrollBody: I(!0)\n  });\n  let l = null;\n  const s = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = t.value ?? \"\", No && (l == null || l()), t.value = void 0;\n  };\n  return te(e, (r, i) => {\n    var p;\n    if (!Je)\n      return;\n    if (!r) {\n      i && s();\n      return;\n    }\n    t.value === void 0 && (t.value = document.body.style.overflow);\n    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, c = (p = n.scrollBody) != null && p.value ? typeof n.scrollBody.value == \"object\" ? yi({\n      padding: n.scrollBody.value.padding === !0 ? u : n.scrollBody.value.padding,\n      margin: n.scrollBody.value.margin === !0 ? u : n.scrollBody.value.margin\n    }, d) : d : { padding: 0, margin: 0 };\n    u > 0 && (document.body.style.paddingRight = `${c.padding}px`, document.body.style.marginRight = `${c.margin}px`, document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), No && (l = je(\n      document,\n      \"touchmove\",\n      (f) => {\n        var v;\n        f.target === document.documentElement && (f.touches.length > 1 || (v = f.preventDefault) == null || v.call(f));\n      },\n      { passive: !1 }\n    )), le(() => {\n      document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n    });\n  }, { immediate: !0, flush: \"sync\" }), a;\n});\nfunction ha(a) {\n  const t = Ci(6), e = wi();\n  e.value.set(t, a ?? !1);\n  const n = B({\n    get: () => e.value.get(t) ?? !1,\n    set: (l) => e.value.set(t, l)\n  });\n  return si(() => {\n    e.value.delete(t);\n  }), n;\n}\nconst _i = \"data-radix-vue-collection-item\";\nfunction Me(a, t = _i) {\n  const e = a ?? Symbol();\n  return { createCollection: (s) => {\n    const r = I([]);\n    function i() {\n      const u = Be(s);\n      return u ? r.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled])`)\n      ) : r.value = [];\n    }\n    return dr(() => {\n      r.value = [];\n    }), se(i), ul(i), te(() => s == null ? void 0 : s.value, i, { immediate: !0 }), ll(e, r), r;\n  }, injectCollection: () => ol(e, I([])) };\n}\nfunction Un(a) {\n  const t = I(a);\n  function e() {\n    return t.value;\n  }\n  function n(m) {\n    t.value = m;\n  }\n  function l(m, S) {\n    return new lt(t.value, S).format(m);\n  }\n  function s(m, S = !0) {\n    return ra(m) && S ? l(Le(m), {\n      dateStyle: \"long\",\n      timeStyle: \"long\"\n    }) : l(Le(m), {\n      dateStyle: \"long\"\n    });\n  }\n  function r(m, S = {}) {\n    return new lt(t.value, { month: \"long\", year: \"numeric\", ...S }).format(m);\n  }\n  function i(m, S = {}) {\n    return new lt(t.value, { month: \"long\", ...S }).format(m);\n  }\n  function u() {\n    const m = Cr(zn());\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((x) => ({ label: i(Le(m.set({ month: x }))), value: x }));\n  }\n  function d(m, S = {}) {\n    return new lt(t.value, { year: \"numeric\", ...S }).format(m);\n  }\n  function c(m, S) {\n    return ml(m) ? new lt(t.value, {\n      ...S,\n      timeZone: m.timeZone\n    }).formatToParts(Le(m)) : new lt(t.value, S).formatToParts(Le(m));\n  }\n  function p(m, S = \"narrow\") {\n    return new lt(t.value, { weekday: S }).format(m);\n  }\n  function f(m) {\n    var D;\n    return ((D = new lt(t.value, {\n      hour: \"numeric\",\n      minute: \"numeric\"\n    }).formatToParts(m).find((h) => h.type === \"dayPeriod\")) == null ? void 0 : D.value) === \"PM\" ? \"PM\" : \"AM\";\n  }\n  const v = {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n    second: \"numeric\"\n  };\n  function g(m, S, x = {}) {\n    const D = { ...v, ...x }, E = c(m, D).find((P) => P.type === S);\n    return E ? E.value : \"\";\n  }\n  return {\n    setLocale: n,\n    getLocale: e,\n    fullMonth: i,\n    fullYear: d,\n    fullMonthAndYear: r,\n    toParts: c,\n    custom: l,\n    part: g,\n    dayPeriod: f,\n    selectedDate: s,\n    dayOfWeek: p,\n    getMonths: u\n  };\n}\nfunction be(a) {\n  const t = Ga({\n    dir: I(\"ltr\")\n  });\n  return B(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction Re(a) {\n  const t = vt(), e = t == null ? void 0 : t.type.emits, n = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((l) => {\n    n[cr(dl(l))] = (...s) => a(l, ...s);\n  }), n;\n}\nlet bn = 0;\nfunction Gn() {\n  ye((a) => {\n    if (!Je)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? Ko()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? Ko()\n    ), bn++, a(() => {\n      bn === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), bn--;\n    });\n  });\n}\nfunction Ko() {\n  const a = document.createElement(\"span\");\n  return a.setAttribute(\"data-radix-focus-guard\", \"\"), a.tabIndex = 0, a.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", a;\n}\nfunction Qe(a) {\n  return B(() => {\n    var t;\n    return Ne(a) ? !!((t = Be(a)) != null && t.closest(\"form\")) : !0;\n  });\n}\nfunction Bt(a) {\n  const t = vt(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((l, s) => {\n    const r = (t == null ? void 0 : t.type.props[s]).default;\n    return r !== void 0 && (l[s] = r), l;\n  }, {}), n = pr(a);\n  return B(() => {\n    const l = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(s).forEach((r) => {\n      l[dl(r)] = s[r];\n    }), Object.keys({ ...e, ...l }).reduce((r, i) => (n.value[i] !== void 0 && (r[i] = n.value[i]), r), {});\n  });\n}\nfunction xe(a, t) {\n  const e = Bt(a), n = t ? Re(t) : {};\n  return B(() => ({\n    ...e.value,\n    ...n\n  }));\n}\nfunction T() {\n  const a = vt(), t = I(), e = B(() => {\n    var r, i;\n    return [\"#text\", \"#comment\"].includes((r = t.value) == null ? void 0 : r.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : Be(t);\n  }), n = Object.assign({}, a.exposed), l = {};\n  for (const r in a.props)\n    Object.defineProperty(l, r, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => a.props[r]\n    });\n  if (Object.keys(n).length > 0)\n    for (const r in n)\n      Object.defineProperty(l, r, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => n[r]\n      });\n  Object.defineProperty(l, \"$el\", {\n    enumerable: !0,\n    configurable: !0,\n    get: () => a.vnode.el\n  }), a.exposed = l;\n  function s(r) {\n    t.value = r, !(r instanceof Element || !r) && (Object.defineProperty(l, \"$el\", {\n      enumerable: !0,\n      configurable: !0,\n      get: () => r.$el\n    }), a.exposed = l);\n  }\n  return { forwardRef: s, currentRef: t, currentElement: e };\n}\nfunction Il(a, t) {\n  const e = Dt(!1, 300), n = I(null), l = ia();\n  function s() {\n    n.value = null, e.value = !1;\n  }\n  function r(i, u) {\n    const d = i.currentTarget, c = { x: i.clientX, y: i.clientY }, p = xi(c, d.getBoundingClientRect()), f = Si(c, p), v = Ei(u.getBoundingClientRect()), g = Di([...f, ...v]);\n    n.value = g, e.value = !0;\n  }\n  return ye((i) => {\n    if (a.value && t.value) {\n      const u = (c) => r(c, t.value), d = (c) => r(c, a.value);\n      a.value.addEventListener(\"pointerleave\", u), t.value.addEventListener(\"pointerleave\", d), i(() => {\n        var c, p;\n        (c = a.value) == null || c.removeEventListener(\"pointerleave\", u), (p = t.value) == null || p.removeEventListener(\"pointerleave\", d);\n      });\n    }\n  }), ye((i) => {\n    if (n.value) {\n      const u = (d) => {\n        var m, S;\n        if (!n.value)\n          return;\n        const c = d.target, p = { x: d.clientX, y: d.clientY }, f = ((m = a.value) == null ? void 0 : m.contains(c)) || ((S = t.value) == null ? void 0 : S.contains(c)), v = !Pi(p, n.value), g = c.hasAttribute(\"data-grace-area-trigger\");\n        f ? s() : (v || g) && (s(), l.trigger());\n      };\n      document.addEventListener(\"pointermove\", u), i(() => document.removeEventListener(\"pointermove\", u));\n    }\n  }), {\n    isPointerInTransit: e,\n    onPointerExit: l.on\n  };\n}\nfunction xi(a, t) {\n  const e = Math.abs(t.top - a.y), n = Math.abs(t.bottom - a.y), l = Math.abs(t.right - a.x), s = Math.abs(t.left - a.x);\n  switch (Math.min(e, n, l, s)) {\n    case s:\n      return \"left\";\n    case l:\n      return \"right\";\n    case e:\n      return \"top\";\n    case n:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction Si(a, t, e = 5) {\n  const n = [];\n  switch (t) {\n    case \"top\":\n      n.push(\n        { x: a.x - e, y: a.y + e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"bottom\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x + e, y: a.y - e }\n      );\n      break;\n    case \"left\":\n      n.push(\n        { x: a.x + e, y: a.y - e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"right\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x - e, y: a.y + e }\n      );\n      break;\n  }\n  return n;\n}\nfunction Ei(a) {\n  const { top: t, right: e, bottom: n, left: l } = a;\n  return [\n    { x: l, y: t },\n    { x: e, y: t },\n    { x: e, y: n },\n    { x: l, y: n }\n  ];\n}\nfunction Pi(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction Di(a) {\n  const t = a.slice();\n  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), $i(t);\n}\nfunction $i(a) {\n  if (a.length <= 1)\n    return a.slice();\n  const t = [];\n  for (let n = 0; n < a.length; n++) {\n    const l = a[n];\n    for (; t.length >= 2; ) {\n      const s = t[t.length - 1], r = t[t.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        t.pop();\n      else break;\n    }\n    t.push(l);\n  }\n  t.pop();\n  const e = [];\n  for (let n = a.length - 1; n >= 0; n--) {\n    const l = a[n];\n    for (; e.length >= 2; ) {\n      const s = e[e.length - 1], r = e[e.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        e.pop();\n      else break;\n    }\n    e.push(l);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nvar Bi = function(a) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(a) ? a[0] : a;\n  return t.ownerDocument.body;\n}, Vt = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Da = {}, Cn = 0, Tl = function(a) {\n  return a && (a.host || Tl(a.parentNode));\n}, Ii = function(a, t) {\n  return t.map(function(e) {\n    if (a.contains(e))\n      return e;\n    var n = Tl(e);\n    return n && a.contains(n) ? n : (console.error(\"aria-hidden\", e, \"in not contained inside\", a, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, Ti = function(a, t, e, n) {\n  var l = Ii(t, Array.isArray(a) ? a : [a]);\n  Da[e] || (Da[e] = /* @__PURE__ */ new WeakMap());\n  var s = Da[e], r = [], i = /* @__PURE__ */ new Set(), u = new Set(l), d = function(p) {\n    !p || i.has(p) || (i.add(p), d(p.parentNode));\n  };\n  l.forEach(d);\n  var c = function(p) {\n    !p || u.has(p) || Array.prototype.forEach.call(p.children, function(f) {\n      if (i.has(f))\n        c(f);\n      else\n        try {\n          var v = f.getAttribute(n), g = v !== null && v !== \"false\", m = (Vt.get(f) || 0) + 1, S = (s.get(f) || 0) + 1;\n          Vt.set(f, m), s.set(f, S), r.push(f), m === 1 && g && Pa.set(f, !0), S === 1 && f.setAttribute(e, \"true\"), g || f.setAttribute(n, \"true\");\n        } catch (x) {\n          console.error(\"aria-hidden: cannot operate on \", f, x);\n        }\n    });\n  };\n  return c(t), i.clear(), Cn++, function() {\n    r.forEach(function(p) {\n      var f = Vt.get(p) - 1, v = s.get(p) - 1;\n      Vt.set(p, f), s.set(p, v), f || (Pa.has(p) || p.removeAttribute(n), Pa.delete(p)), v || p.removeAttribute(e);\n    }), Cn--, Cn || (Vt = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Da = {});\n  };\n}, Ri = function(a, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var n = Array.from(Array.isArray(a) ? a : [a]), l = Bi(a);\n  return l ? (n.push.apply(n, Array.from(l.querySelectorAll(\"[aria-live]\"))), Ti(n, l, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction ya(a) {\n  let t;\n  te(() => Be(a), (e) => {\n    e ? t = Ri(e) : t && t();\n  }), Ie(() => {\n    t && t();\n  });\n}\nlet Ai = 0;\nfunction me(a, t = \"radix\") {\n  if (a)\n    return a;\n  const { useId: e } = Ga({ useId: void 0 });\n  return e && typeof e == \"function\" ? `${t}-${e()}` : `${t}-${++Ai}`;\n}\nfunction Oi(a, t) {\n  const e = I(), n = (s, r) => {\n    if (t.multiple && Array.isArray(a.value))\n      if (t.selectionBehavior === \"replace\")\n        a.value = [s], e.value = s;\n      else {\n        const i = a.value.findIndex((u) => r(u));\n        i !== -1 ? a.value.splice(i, 1) : a.value.push(s);\n      }\n    else\n      t.selectionBehavior === \"replace\" ? a.value = { ...s } : !Array.isArray(a.value) && r(a.value) ? a.value = void 0 : a.value = { ...s };\n    return a.value;\n  };\n  function l(s, r, i, u) {\n    var f;\n    if (!(e != null && e.value) || !t.multiple || !Array.isArray(a.value))\n      return;\n    const c = (f = i().filter((v) => v.ref.dataset.disabled !== \"\").find((v) => v.ref === r)) == null ? void 0 : f.value;\n    if (!c)\n      return;\n    let p = null;\n    switch (s) {\n      case \"prev\":\n      case \"next\": {\n        p = St(u, e.value, c);\n        break;\n      }\n      case \"first\": {\n        p = St(u, e.value, u == null ? void 0 : u[0]);\n        break;\n      }\n      case \"last\": {\n        p = St(u, e.value, u == null ? void 0 : u[u.length - 1]);\n        break;\n      }\n    }\n    a.value = p;\n  }\n  return {\n    firstValue: e,\n    onSelectItem: n,\n    handleMultipleReplace: l\n  };\n}\nfunction Rl(a) {\n  const t = I(), e = B(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.width) ?? 0;\n  }), n = B(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.height) ?? 0;\n  });\n  return se(() => {\n    const l = Be(a);\n    if (l) {\n      t.value = { width: l.offsetWidth, height: l.offsetHeight };\n      const s = new ResizeObserver((r) => {\n        if (!Array.isArray(r) || !r.length)\n          return;\n        const i = r[0];\n        let u, d;\n        if (\"borderBoxSize\" in i) {\n          const c = i.borderBoxSize, p = Array.isArray(c) ? c[0] : c;\n          u = p.inlineSize, d = p.blockSize;\n        } else\n          u = l.offsetWidth, d = l.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return s.observe(l, { box: \"border-box\" }), () => s.unobserve(l);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: n\n  };\n}\nfunction Al(a, t) {\n  const e = I(a);\n  function n(s) {\n    return t[e.value][s] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (s) => {\n      e.value = n(s);\n    }\n  };\n}\nfunction ga(a) {\n  const t = Dt(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (l, s) => {\n      var f, v;\n      if (!(a != null && a.value) && !s)\n        return;\n      t.value = t.value + l;\n      const r = (a == null ? void 0 : a.value) ?? s, i = document.activeElement, u = ((v = (f = r.find((g) => g === i)) == null ? void 0 : f.textContent) == null ? void 0 : v.trim()) ?? \"\", d = r.map((g) => {\n        var m;\n        return ((m = g.textContent) == null ? void 0 : m.trim()) ?? \"\";\n      }), c = Yn(d, t.value, u), p = r.find(\n        (g) => {\n          var m;\n          return ((m = g.textContent) == null ? void 0 : m.trim()) === c;\n        }\n      );\n      return p && p.focus(), p;\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction qn(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nfunction Yn(a, t, e) {\n  const l = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? a.indexOf(e) : -1;\n  let r = qn(a, Math.max(s, 0));\n  l.length === 1 && (r = r.filter((d) => d !== e));\n  const u = r.find(\n    (d) => d.toLowerCase().startsWith(l.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction dv(a, t) {\n  return {\n    inheritAttrs: !1,\n    name: `${a.__name ?? \"\"}Wrapper`,\n    setup(e, n) {\n      return () => {\n        const l = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, { forwardRef: s } = T(), r = k(l, n.attrs);\n        return pt(a, { ...r, ref: s }, n.slots);\n      };\n    }\n  };\n}\nfunction et() {\n  return {\n    ALT: \"Alt\",\n    ARROW_DOWN: \"ArrowDown\",\n    ARROW_LEFT: \"ArrowLeft\",\n    ARROW_RIGHT: \"ArrowRight\",\n    ARROW_UP: \"ArrowUp\",\n    BACKSPACE: \"Backspace\",\n    CAPS_LOCK: \"CapsLock\",\n    CONTROL: \"Control\",\n    DELETE: \"Delete\",\n    END: \"End\",\n    ENTER: \"Enter\",\n    ESCAPE: \"Escape\",\n    F1: \"F1\",\n    F10: \"F10\",\n    F11: \"F11\",\n    F12: \"F12\",\n    F2: \"F2\",\n    F3: \"F3\",\n    F4: \"F4\",\n    F5: \"F5\",\n    F6: \"F6\",\n    F7: \"F7\",\n    F8: \"F8\",\n    F9: \"F9\",\n    HOME: \"Home\",\n    META: \"Meta\",\n    PAGE_DOWN: \"PageDown\",\n    PAGE_UP: \"PageUp\",\n    SHIFT: \"Shift\",\n    SPACE: \" \",\n    TAB: \"Tab\",\n    CTRL: \"Control\",\n    ASTERISK: \"*\",\n    SPACE_CODE: \"Space\"\n  };\n}\nconst Xn = w({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: !1,\n  setup(a, { attrs: t, slots: e }) {\n    return () => {\n      var u, d;\n      if (!e.default)\n        return null;\n      const n = Ua(e.default()), l = n.findIndex((c) => c.type !== fr);\n      if (l === -1)\n        return n;\n      const s = n[l];\n      (u = s.props) == null || delete u.ref;\n      const r = s.props ? k(t, s.props) : t;\n      t.class && ((d = s.props) != null && d.class) && delete s.props.class;\n      const i = Fn(s, r);\n      for (const c in r)\n        c.startsWith(\"on\") && (i.props || (i.props = {}), i.props[c] = r[c]);\n      return n.length === 1 ? i : (n[l] = i, n);\n    };\n  }\n}), O = w({\n  name: \"Primitive\",\n  inheritAttrs: !1,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: !1\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(a, { attrs: t, slots: e }) {\n    const n = a.asChild ? \"template\" : a.as;\n    return typeof n == \"string\" && [\"area\", \"img\", \"input\"].includes(n) ? () => pt(n, t) : n !== \"template\" ? () => pt(a.as, t, { default: e.default }) : () => pt(Xn, t, { default: e.default });\n  }\n});\nfunction Ae() {\n  const a = I(), t = B(() => {\n    var e, n;\n    return [\"#text\", \"#comment\"].includes((e = a.value) == null ? void 0 : e.$el.nodeName) ? (n = a.value) == null ? void 0 : n.$el.nextElementSibling : Be(a);\n  });\n  return {\n    primitiveElement: a,\n    currentElement: t\n  };\n}\nconst [Ol, ki] = Q(\"CollapsibleRoot\"), Mi = /* @__PURE__ */ w({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, s = ae(n, \"open\", e, {\n      defaultValue: n.defaultOpen,\n      passive: n.open === void 0\n    }), r = ae(n, \"disabled\");\n    return ki({\n      contentId: \"\",\n      disabled: r,\n      open: s,\n      onOpenToggle: () => {\n        s.value = !s.value;\n      }\n    }), t({ open: s }), T(), (i, u) => (b(), _(o(O), {\n      as: i.as,\n      \"as-child\": n.asChild,\n      \"data-state\": n.open ? \"open\" : \"closed\",\n      \"data-disabled\": n.disabled ? \"\" : void 0\n    }, {\n      default: y(() => [\n        C(i.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), Vi = /* @__PURE__ */ w({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Ol();\n    return (n, l) => {\n      var s, r;\n      return b(), _(o(O), {\n        type: n.as === \"button\" ? \"button\" : void 0,\n        as: n.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": o(e).contentId,\n        \"aria-expanded\": o(e).open.value,\n        \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (s = o(e).disabled) != null && s.value ? \"\" : void 0,\n        disabled: (r = o(e).disabled) == null ? void 0 : r.value,\n        onClick: o(e).onOpenToggle\n      }, {\n        default: y(() => [\n          C(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction Fi(a, t) {\n  const e = I({}), n = I(\"none\"), l = a.value ? \"mounted\" : \"unmounted\", { state: s, dispatch: r } = Al(l, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  }), i = (v) => {\n    var g;\n    if (Je) {\n      const m = new CustomEvent(v, { bubbles: !1, cancelable: !1 });\n      (g = t.value) == null || g.dispatchEvent(m);\n    }\n  };\n  te(\n    a,\n    async (v, g) => {\n      var S;\n      const m = g !== v;\n      if (await le(), m) {\n        const x = n.value, D = $a(t.value);\n        v ? (r(\"MOUNT\"), i(\"enter\"), D === \"none\" && i(\"after-enter\")) : D === \"none\" || ((S = e.value) == null ? void 0 : S.display) === \"none\" ? (r(\"UNMOUNT\"), i(\"leave\"), i(\"after-leave\")) : g && x !== D ? (r(\"ANIMATION_OUT\"), i(\"leave\")) : (r(\"UNMOUNT\"), i(\"after-leave\"));\n      }\n    },\n    { immediate: !0 }\n  );\n  const u = (v) => {\n    const g = $a(t.value), m = g.includes(\n      v.animationName\n    ), S = s.value === \"mounted\" ? \"enter\" : \"leave\";\n    v.target === t.value && m && (i(`after-${S}`), r(\"ANIMATION_END\")), v.target === t.value && g === \"none\" && r(\"ANIMATION_END\");\n  }, d = (v) => {\n    v.target === t.value && (n.value = $a(t.value));\n  }, c = te(\n    t,\n    (v, g) => {\n      v ? (e.value = getComputedStyle(v), v.addEventListener(\"animationstart\", d), v.addEventListener(\"animationcancel\", u), v.addEventListener(\"animationend\", u)) : (r(\"ANIMATION_END\"), g == null || g.removeEventListener(\"animationstart\", d), g == null || g.removeEventListener(\"animationcancel\", u), g == null || g.removeEventListener(\"animationend\", u));\n    },\n    { immediate: !0 }\n  ), p = te(s, () => {\n    const v = $a(t.value);\n    n.value = s.value === \"mounted\" ? v : \"none\";\n  });\n  return Ie(() => {\n    c(), p();\n  }), {\n    isPresent: B(\n      () => [\"mounted\", \"unmountSuspended\"].includes(s.value)\n    )\n  };\n}\nfunction $a(a) {\n  return a && getComputedStyle(a).animationName || \"none\";\n}\nconst Pe = w({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: !0\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(a, { slots: t, expose: e }) {\n    var d;\n    const { present: n, forceMount: l } = ne(a), s = I(), { isPresent: r } = Fi(n, s);\n    e({ present: r });\n    let i = t.default({ present: r });\n    i = Ua(i || []);\n    const u = vt();\n    if (i && (i == null ? void 0 : i.length) > 1) {\n      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${c}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((p) => `  - ${p}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => l.value || n.value || r.value ? pt(t.default({ present: r })[0], {\n      ref: (c) => {\n        const p = Be(c);\n        return typeof (p == null ? void 0 : p.hasAttribute) > \"u\" || (p != null && p.hasAttribute(\"data-radix-popper-content-wrapper\") ? s.value = p.firstElementChild : s.value = p), p;\n      }\n    }) : null;\n  }\n}), Li = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Ol();\n    e.contentId || (e.contentId = me(void 0, \"radix-vue-collapsible-content\"));\n    const n = I(), { forwardRef: l, currentElement: s } = T(), r = I(0), i = I(0), u = B(() => e.open.value), d = I(u.value), c = I();\n    return te(\n      () => {\n        var p;\n        return [u.value, (p = n.value) == null ? void 0 : p.present];\n      },\n      async () => {\n        await le();\n        const p = s.value;\n        if (!p)\n          return;\n        c.value = c.value || {\n          transitionDuration: p.style.transitionDuration,\n          animationName: p.style.animationName\n        }, p.style.transitionDuration = \"0s\", p.style.animationName = \"none\";\n        const f = p.getBoundingClientRect();\n        i.value = f.height, r.value = f.width, d.value || (p.style.transitionDuration = c.value.transitionDuration, p.style.animationName = c.value.animationName);\n      },\n      {\n        immediate: !0\n      }\n    ), se(() => {\n      requestAnimationFrame(() => {\n        d.value = !1;\n      });\n    }), (p, f) => (b(), _(o(Pe), {\n      ref_key: \"presentRef\",\n      ref: n,\n      present: p.forceMount || o(e).open.value,\n      \"force-mount\": !0\n    }, {\n      default: y(() => {\n        var v, g;\n        return [\n          Y(o(O), k(p.$attrs, {\n            id: o(e).contentId,\n            ref: o(l),\n            \"as-child\": t.asChild,\n            as: p.as,\n            \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (v = o(e).disabled) != null && v.value ? \"\" : void 0,\n            hidden: !((g = n.value) != null && g.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${i.value}px`,\n              \"--radix-collapsible-content-width\": `${r.value}px`\n            }\n          }), {\n            default: y(() => {\n              var m;\n              return [\n                (m = n.value) != null && m.present ? C(p.$slots, \"default\", { key: 0 }) : pe(\"\", !0)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction kl({ type: a, defaultValue: t, modelValue: e }) {\n  const n = e || t;\n  if (Nt(a) && Nt(e) && Nt(t))\n    throw new Error(\"Either the `type` or the `value` or `default-value` prop must be defined.\");\n  if (e !== void 0 && t !== void 0 && typeof e != typeof t)\n    throw new Error(\n      `Invalid prop \\`value\\` of value \\`${e}\\` supplied, should be the same type as the \\`defaultValue\\` prop, which is \\`${t}\\`. The \\`value\\` prop must be:\n  ${a === \"single\" ? \"- a string\" : a === \"multiple\" ? \"- an array of strings\" : `- a string\n- an array of strings`}\n  - \\`undefined\\``\n    );\n  const l = e !== void 0 || t !== void 0;\n  if (a && l) {\n    const s = Array.isArray(e) || Array.isArray(t), r = e !== void 0 ? \"modelValue\" : \"defaultValue\", i = r === \"modelValue\" ? typeof e : typeof t;\n    if (a === \"single\" && s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`single\\`. The \\`modelValue\\` prop must be a string or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"multiple\";\n    if (a === \"multiple\" && !s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`multiple\\`. The \\`modelValue\\` prop must be an array of strings or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"single\";\n  }\n  return l ? Array.isArray(n) ? \"multiple\" : \"single\" : a;\n}\nfunction Ni({ type: a, defaultValue: t, modelValue: e }) {\n  return a || kl({ type: a, defaultValue: t, modelValue: e });\n}\nfunction zi({ type: a, defaultValue: t }) {\n  return t !== void 0 ? t : a === \"single\" ? void 0 : [];\n}\nfunction Ml(a, t) {\n  const e = I(Ni(a)), n = ae(a, \"modelValue\", t, {\n    defaultValue: zi(a),\n    passive: a.modelValue === void 0,\n    deep: !0\n  });\n  te(\n    () => [a.type, a.modelValue, a.defaultValue],\n    () => {\n      const r = kl(a);\n      e.value !== r && (e.value = r);\n    },\n    { immediate: !0 }\n  );\n  function l(r) {\n    if (e.value === \"single\")\n      n.value = r === n.value ? void 0 : r;\n    else {\n      const i = [...n.value || []];\n      if (i.includes(r)) {\n        const u = i.findIndex((d) => d === r);\n        i.splice(u, 1);\n      } else\n        i.push(r);\n      n.value = i;\n    }\n  }\n  const s = B(() => e.value === \"single\");\n  return {\n    modelValue: n,\n    type: e,\n    changeModelValue: l,\n    isSingle: s\n  };\n}\nconst [qa, Ki] = Q(\"AccordionRoot\"), cv = /* @__PURE__ */ w({\n  __name: \"AccordionRoot\",\n  props: {\n    collapsible: { type: Boolean, default: !1 },\n    disabled: { type: Boolean, default: !1 },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, disabled: s } = ne(e), r = be(l), { modelValue: i, changeModelValue: u, isSingle: d } = Ml(e, n), { forwardRef: c, currentElement: p } = T();\n    return Ki({\n      disabled: s,\n      direction: r,\n      orientation: e.orientation,\n      parentElement: p,\n      isSingle: d,\n      collapsible: e.collapsible,\n      modelValue: i,\n      changeModelValue: u\n    }), (f, v) => (b(), _(o(O), {\n      ref: o(c),\n      \"as-child\": f.asChild,\n      as: f.as\n    }, {\n      default: y(() => [\n        C(f.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [Zn, Hi] = Q(\"AccordionItem\"), pv = /* @__PURE__ */ w({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = qa(), l = B(\n      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)\n    ), s = B(() => n.disabled.value || e.disabled || n.isSingle.value && l.value && !n.collapsible), r = B(() => s.value ? \"\" : void 0), i = B(\n      () => l.value ? \"open\" : \"closed\"\n      /* Closed */\n    );\n    t({ open: l, dataDisabled: r });\n    const { currentRef: u, currentElement: d } = T();\n    Hi({\n      open: l,\n      dataState: i,\n      disabled: s,\n      dataDisabled: r,\n      triggerId: \"\",\n      currentRef: u,\n      currentElement: d,\n      value: B(() => e.value)\n    });\n    function c(p) {\n      $t(\n        p,\n        d.value,\n        n.parentElement.value,\n        {\n          arrowKeyOptions: n.orientation,\n          dir: n.direction.value,\n          focus: !0\n        }\n      );\n    }\n    return (p, f) => (b(), _(o(Mi), {\n      \"data-orientation\": o(n).orientation,\n      \"data-disabled\": r.value,\n      \"data-state\": i.value,\n      disabled: s.value,\n      open: l.value,\n      as: e.as,\n      \"as-child\": e.asChild,\n      onKeydown: re(c, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: y(() => [\n        C(p.$slots, \"default\", { open: l.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as\", \"as-child\"]));\n  }\n}), fv = /* @__PURE__ */ w({\n  __name: \"AccordionContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    return T(), (l, s) => (b(), _(o(Li), {\n      role: \"region\",\n      hidden: !o(n).open.value,\n      \"as-child\": t.asChild,\n      \"aria-labelledby\": o(n).triggerId,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"hidden\", \"as-child\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), vv = /* @__PURE__ */ w({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    return T(), (l, s) => (b(), _(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value\n    }, {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), mv = /* @__PURE__ */ w({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    n.triggerId || (n.triggerId = me(void 0, \"radix-vue-accordion-trigger\"));\n    function l() {\n      n.disabled.value || e.changeModelValue(n.value.value);\n    }\n    return (s, r) => (b(), _(o(Vi), {\n      id: o(n).triggerId,\n      ref: o(n).currentRef,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-disabled\": o(n).disabled.value || void 0,\n      \"aria-expanded\": o(n).open.value || !1,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      disabled: o(n).disabled.value,\n      onClick: l\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [tt, Wi] = Q(\"DialogRoot\"), ji = /* @__PURE__ */ w({\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: !1 },\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = I(), r = I(), { modal: i } = ne(e);\n    return Wi({\n      open: l,\n      modal: i,\n      openModal: () => {\n        l.value = !0;\n      },\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      contentId: \"\",\n      titleId: \"\",\n      descriptionId: \"\",\n      triggerElement: s,\n      contentElement: r\n    }), (u, d) => C(u.$slots, \"default\", { open: o(l) });\n  }\n}), Ui = /* @__PURE__ */ w({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = tt(), { forwardRef: n, currentElement: l } = T();\n    return e.contentId || (e.contentId = me(void 0, \"radix-vue-dialog-content\")), se(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), _(o(O), k(t, {\n      ref: o(n),\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": o(e).open.value || !1,\n      \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      onClick: o(e).onOpenToggle\n    }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), ht = /* @__PURE__ */ w({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = ja();\n    return (e, n) => o(t) || e.forceMount ? (b(), _(Wt, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      C(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : pe(\"\", !0);\n  }\n}), hv = /* @__PURE__ */ w({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gi = \"dismissableLayer.pointerDownOutside\", qi = \"dismissableLayer.focusOutside\";\nfunction Vl(a, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), n = a.dataset.dismissableLayer === \"\" ? a : a.querySelector(\n    \"[data-dismissable-layer]\"\n  ), l = Array.from(\n    a.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && n === e || l.indexOf(n) < l.indexOf(e));\n}\nfunction Fl(a, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = I(!1), l = I(() => {\n  });\n  return ye((r) => {\n    if (!Je)\n      return;\n    const i = async (d) => {\n      const c = d.target;\n      if (t != null && t.value) {\n        if (Vl(t.value, c)) {\n          n.value = !1;\n          return;\n        }\n        if (d.target && !n.value) {\n          let p = function() {\n            zt(\n              Gi,\n              a,\n              f\n            );\n          };\n          const f = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", l.value), l.value = p, e.addEventListener(\"click\", l.value, {\n            once: !0\n          })) : p();\n        } else\n          e.removeEventListener(\"click\", l.value);\n        n.value = !1;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", i);\n    }, 0);\n    r(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", i), e.removeEventListener(\"click\", l.value);\n    });\n  }), {\n    onPointerDownCapture: () => n.value = !0\n  };\n}\nfunction Ll(a, t) {\n  var l;\n  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = I(!1);\n  return ye((s) => {\n    if (!Je)\n      return;\n    const r = async (i) => {\n      t != null && t.value && (await le(), !(!t.value || Vl(t.value, i.target)) && i.target && !n.value && zt(\n        qi,\n        a,\n        { originalEvent: i }\n      ));\n    };\n    e.addEventListener(\"focusin\", r), s(() => e.removeEventListener(\"focusin\", r));\n  }), {\n    onFocusCapture: () => n.value = !0,\n    onBlurCapture: () => n.value = !1\n  };\n}\nconst We = Ma({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), yt = /* @__PURE__ */ w({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), r = B(\n      () => {\n        var g;\n        return ((g = s.value) == null ? void 0 : g.ownerDocument) ?? globalThis.document;\n      }\n    ), i = B(() => We.layersRoot), u = B(() => s.value ? Array.from(i.value).indexOf(s.value) : -1), d = B(() => We.layersWithOutsidePointerEventsDisabled.size > 0), c = B(() => {\n      const g = Array.from(i.value), [m] = [...We.layersWithOutsidePointerEventsDisabled].slice(-1), S = g.indexOf(m);\n      return u.value >= S;\n    }), p = Fl(async (g) => {\n      const m = [...We.branches].some(\n        (S) => S.contains(g.target)\n      );\n      !c.value || m || (n(\"pointerDownOutside\", g), n(\"interactOutside\", g), await le(), g.defaultPrevented || n(\"dismiss\"));\n    }, s), f = Ll((g) => {\n      [...We.branches].some(\n        (S) => S.contains(g.target)\n      ) || (n(\"focusOutside\", g), n(\"interactOutside\", g), g.defaultPrevented || n(\"dismiss\"));\n    }, s);\n    jn(\"Escape\", (g) => {\n      u.value === i.value.size - 1 && (n(\"escapeKeyDown\", g), g.defaultPrevented || n(\"dismiss\"));\n    });\n    let v;\n    return ye((g) => {\n      s.value && (e.disableOutsidePointerEvents && (We.layersWithOutsidePointerEventsDisabled.size === 0 && (v = r.value.body.style.pointerEvents, r.value.body.style.pointerEvents = \"none\"), We.layersWithOutsidePointerEventsDisabled.add(s.value)), i.value.add(s.value), g(() => {\n        e.disableOutsidePointerEvents && We.layersWithOutsidePointerEventsDisabled.size === 1 && (r.value.body.style.pointerEvents = v);\n      }));\n    }), ye((g) => {\n      g(() => {\n        s.value && (i.value.delete(s.value), We.layersWithOutsidePointerEventsDisabled.delete(s.value));\n      });\n    }), (g, m) => (b(), _(o(O), {\n      ref: o(l),\n      \"as-child\": g.asChild,\n      as: g.as,\n      \"data-dismissable-layer\": \"\",\n      style: Oe({\n        pointerEvents: d.value ? c.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: o(f).onFocusCapture,\n      onBlurCapture: o(f).onBlurCapture,\n      onPointerdownCapture: o(p).onPointerDownCapture\n    }, {\n      default: y(() => [\n        C(g.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), Yi = /* @__PURE__ */ w({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = T();\n    return se(() => {\n      We.branches.add(n.value);\n    }), Ie(() => {\n      We.branches.delete(n.value);\n    }), (l, s) => (b(), _(o(O), k({ ref: o(e) }, t), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wn = \"focusScope.autoFocusOnMount\", _n = \"focusScope.autoFocusOnUnmount\", Ho = { bubbles: !1, cancelable: !0 };\nfunction Oa(a, { select: t = !1 } = {}) {\n  const e = document.activeElement;\n  for (const n of a)\n    if (dt(n, { select: t }), document.activeElement !== e)\n      return !0;\n}\nfunction Xi(a) {\n  const t = Jn(a), e = Wo(t, a), n = Wo(t.reverse(), a);\n  return [e, n];\n}\nfunction Jn(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction Wo(a, t) {\n  for (const e of a)\n    if (!Zi(e, { upTo: t }))\n      return e;\n}\nfunction Zi(a, { upTo: t }) {\n  if (getComputedStyle(a).visibility === \"hidden\")\n    return !0;\n  for (; a; ) {\n    if (t !== void 0 && a === t)\n      return !1;\n    if (getComputedStyle(a).display === \"none\")\n      return !0;\n    a = a.parentElement;\n  }\n  return !1;\n}\nfunction Ji(a) {\n  return a instanceof HTMLInputElement && \"select\" in a;\n}\nfunction dt(a, { select: t = !1 } = {}) {\n  if (a && a.focus) {\n    const e = document.activeElement;\n    a.focus({ preventScroll: !0 }), a !== e && Ji(a) && t && a.select();\n  }\n}\nconst Qi = qr(() => I([]));\nfunction eu() {\n  const a = Qi();\n  return {\n    add(t) {\n      const e = a.value[0];\n      t !== e && (e == null || e.pause()), a.value = jo(a.value, t), a.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      a.value = jo(a.value, t), (e = a.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction jo(a, t) {\n  const e = [...a], n = e.indexOf(t);\n  return n !== -1 && e.splice(n, 1), e;\n}\nfunction tu(a) {\n  return a.filter((t) => t.tagName !== \"A\");\n}\nconst Ya = /* @__PURE__ */ w({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: !1 },\n    trapped: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { currentRef: l, currentElement: s } = T(), r = I(null), i = eu(), u = Ma({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    });\n    ye((c) => {\n      if (!Je)\n        return;\n      const p = s.value;\n      if (!e.trapped)\n        return;\n      function f(S) {\n        if (u.paused || !p)\n          return;\n        const x = S.target;\n        p.contains(x) ? r.value = x : dt(r.value, { select: !0 });\n      }\n      function v(S) {\n        if (u.paused || !p)\n          return;\n        const x = S.relatedTarget;\n        x !== null && (p.contains(x) || dt(r.value, { select: !0 }));\n      }\n      function g(S) {\n        p.contains(r.value) || dt(p);\n      }\n      document.addEventListener(\"focusin\", f), document.addEventListener(\"focusout\", v);\n      const m = new MutationObserver(g);\n      p && m.observe(p, { childList: !0, subtree: !0 }), c(() => {\n        document.removeEventListener(\"focusin\", f), document.removeEventListener(\"focusout\", v), m.disconnect();\n      });\n    }), ye(async (c) => {\n      const p = s.value;\n      if (await le(), !p)\n        return;\n      i.add(u);\n      const f = document.activeElement;\n      if (!p.contains(f)) {\n        const g = new CustomEvent(wn, Ho);\n        p.addEventListener(wn, (m) => n(\"mountAutoFocus\", m)), p.dispatchEvent(g), g.defaultPrevented || (Oa(tu(Jn(p)), {\n          select: !0\n        }), document.activeElement === f && dt(p));\n      }\n      c(() => {\n        p.removeEventListener(wn, (S) => n(\"mountAutoFocus\", S));\n        const g = new CustomEvent(_n, Ho), m = (S) => {\n          n(\"unmountAutoFocus\", S);\n        };\n        p.addEventListener(_n, m), p.dispatchEvent(g), setTimeout(() => {\n          g.defaultPrevented || dt(f ?? document.body, { select: !0 }), p.removeEventListener(_n, m), i.remove(u);\n        }, 0);\n      });\n    });\n    function d(c) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const p = c.key === \"Tab\" && !c.altKey && !c.ctrlKey && !c.metaKey, f = document.activeElement;\n      if (p && f) {\n        const v = c.currentTarget, [g, m] = Xi(v);\n        g && m ? !c.shiftKey && f === m ? (c.preventDefault(), e.loop && dt(g, { select: !0 })) : c.shiftKey && f === g && (c.preventDefault(), e.loop && dt(m, { select: !0 })) : f === v && c.preventDefault();\n      }\n    }\n    return (c, p) => (b(), _(o(O), {\n      ref_key: \"currentRef\",\n      ref: l,\n      tabindex: \"-1\",\n      \"as-child\": c.asChild,\n      as: c.as,\n      onKeydown: d\n    }, {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), au = \"menu.itemSelect\", Dn = [\"Enter\", \" \"], nu = [\"ArrowDown\", \"PageUp\", \"Home\"], Nl = [\"ArrowUp\", \"PageDown\", \"End\"], ou = [...nu, ...Nl], lu = {\n  ltr: [...Dn, \"ArrowRight\"],\n  rtl: [...Dn, \"ArrowLeft\"]\n}, su = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction Qn(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction Fa(a) {\n  return a === \"indeterminate\";\n}\nfunction eo(a) {\n  return Fa(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nfunction $n(a) {\n  const t = document.activeElement;\n  for (const e of a)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction ru(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction iu(a, t) {\n  if (!t)\n    return !1;\n  const e = { x: a.clientX, y: a.clientY };\n  return ru(e, t);\n}\nfunction ua(a) {\n  return a.pointerType === \"mouse\";\n}\nconst uu = \"DialogTitle\", du = \"DialogContent\";\nfunction cu({\n  titleName: a = uu,\n  contentName: t = du,\n  componentLink: e = \"dialog.html#title\",\n  titleId: n,\n  descriptionId: l,\n  contentElement: s\n}) {\n  const r = `Warning: \\`${t}\\` requires a \\`${a}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${a}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/${e}`, i = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${t}.`;\n  se(() => {\n    var c;\n    document.getElementById(n) || console.warn(r);\n    const d = (c = s.value) == null ? void 0 : c.getAttribute(\"aria-describedby\");\n    l && !d && (document.getElementById(l) || console.warn(i));\n  });\n}\nconst zl = /* @__PURE__ */ w({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = tt(), { forwardRef: s, currentElement: r } = T();\n    return l.titleId || (l.titleId = me(void 0, \"radix-vue-dialog-title\")), l.descriptionId || (l.descriptionId = me(void 0, \"radix-vue-dialog-description\")), se(() => {\n      l.contentElement = r, document.activeElement !== document.body && (l.triggerElement.value = document.activeElement);\n    }), process.env.NODE_ENV !== \"production\" && cu({\n      titleName: \"DialogTitle\",\n      contentName: \"DialogContent\",\n      componentLink: \"dialog.html#title\",\n      titleId: l.titleId,\n      descriptionId: l.descriptionId,\n      contentElement: l.contentElement\n    }), (i, u) => (b(), _(o(Ya), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        Y(o(yt), k({\n          id: o(l).contentId,\n          ref: o(s),\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": o(l).descriptionId,\n          \"aria-labelledby\": o(l).titleId,\n          \"data-state\": o(Qn)(o(l).open.value)\n        }, i.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => n(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => n(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => n(\"pointerDownOutside\", d))\n        }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), pu = /* @__PURE__ */ w({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = tt(), s = Re(n), { forwardRef: r, currentElement: i } = T();\n    return ya(i), (u, d) => (b(), _(zl, k({ ...e, ...o(s) }, {\n      ref: o(r),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": !0,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        c.defaultPrevented || (c.preventDefault(), (p = o(l).triggerElement.value) == null || p.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (c) => {\n        const p = c.detail.originalEvent, f = p.button === 0 && p.ctrlKey === !0;\n        (p.button === 2 || f) && c.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (c) => {\n        c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), fu = /* @__PURE__ */ w({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    T();\n    const s = tt(), r = I(!1), i = I(!1);\n    return (u, d) => (b(), _(zl, k({ ...e, ...o(l) }, {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        c.defaultPrevented || (r.value || (p = o(s).triggerElement.value) == null || p.focus(), c.preventDefault()), r.value = !1, i.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = (c) => {\n        var v;\n        c.defaultPrevented || (r.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (i.value = !0));\n        const p = c.target;\n        ((v = o(s).triggerElement.value) == null ? void 0 : v.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && i.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vu = /* @__PURE__ */ w({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = tt(), s = Re(n), { forwardRef: r } = T();\n    return (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), _(pu, k({\n          key: 0,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), _(fu, k({\n          key: 1,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), mu = /* @__PURE__ */ w({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = tt();\n    return ha(!0), T(), (e, n) => (b(), _(o(O), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": o(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), hu = /* @__PURE__ */ w({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = tt(), { forwardRef: e } = T();\n    return (n, l) => {\n      var s;\n      return (s = o(t)) != null && s.modal.value ? (b(), _(o(Pe), {\n        key: 0,\n        present: n.forceMount || o(t).open.value\n      }, {\n        default: y(() => [\n          Y(mu, k(n.$attrs, {\n            ref: o(e),\n            as: n.as,\n            \"as-child\": n.asChild\n          }), {\n            default: y(() => [\n              C(n.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : pe(\"\", !0);\n    };\n  }\n}), Kl = /* @__PURE__ */ w({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = tt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), yu = /* @__PURE__ */ w({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a, e = tt();\n    return T(), (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), gu = /* @__PURE__ */ w({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = tt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), yv = /* @__PURE__ */ w({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return T(), (s, r) => (b(), _(o(ji), k(o(l), { modal: !0 }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gv = /* @__PURE__ */ w({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(Ui), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bv = /* @__PURE__ */ w({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [bu, Cu] = Q(\"AlertDialogContent\"), Cv = /* @__PURE__ */ w({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    T();\n    const s = I();\n    return Cu({\n      onCancelElementChange: (r) => {\n        s.value = r;\n      }\n    }), (r, i) => (b(), _(o(vu), k({ ...e, ...o(l) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: i[0] || (i[0] = ie(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: i[1] || (i[1] = ie(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: i[2] || (i[2] = () => {\n        le(() => {\n          var u;\n          (u = s.value) == null || u.focus({\n            preventScroll: !0\n          });\n        });\n      })\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wv = /* @__PURE__ */ w({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(hu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _v = /* @__PURE__ */ w({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = bu(), { forwardRef: n, currentElement: l } = T();\n    return se(() => {\n      e.onCancelElementChange(l.value);\n    }), (s, r) => (b(), _(o(Kl), k(t, { ref: o(n) }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xv = /* @__PURE__ */ w({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(yu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sv = /* @__PURE__ */ w({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(gu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ev = /* @__PURE__ */ w({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(Kl), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pv = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), n = B(() => 1 / t.ratio * 100);\n    return (l, s) => (b(), ce(\"div\", {\n      style: Oe(`position: relative; width: 100%; padding-bottom: ${n.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      Y(o(O), k({\n        ref: o(e),\n        \"as-child\": l.asChild,\n        as: l.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, l.$attrs), {\n        default: y(() => [\n          C(l.$slots, \"default\", { aspect: n.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [Hl, wu] = Q(\"AvatarRoot\"), Dv = /* @__PURE__ */ w({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return T(), wu({\n      imageLoadingStatus: I(\"loading\")\n    }), (t, e) => (b(), _(o(O), {\n      \"as-child\": t.asChild,\n      as: t.as\n    }, {\n      default: y(() => [\n        C(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n});\nfunction _u(a) {\n  const t = I(\"idle\"), e = I(!1), n = (l) => () => {\n    e.value && (t.value = l);\n  };\n  return se(() => {\n    e.value = !0, te(a, (l) => {\n      if (!l)\n        t.value = \"error\";\n      else {\n        const s = new window.Image();\n        t.value = \"loading\", s.onload = n(\"loaded\"), s.onerror = n(\"error\"), s.src = l;\n      }\n    }, { immediate: !0 });\n  }), Ie(() => {\n    e.value = !1;\n  }), t;\n}\nconst $v = /* @__PURE__ */ w({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { src: l } = ne(e);\n    T();\n    const s = Hl(), r = _u(l);\n    return te(\n      r,\n      (i) => {\n        n(\"loadingStatusChange\", i), i !== \"idle\" && (s.imageLoadingStatus.value = i);\n      },\n      { immediate: !0 }\n    ), (i, u) => Ha((b(), _(o(O), {\n      role: \"img\",\n      \"as-child\": i.asChild,\n      as: i.as,\n      src: o(l)\n    }, {\n      default: y(() => [\n        C(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\"])), [\n      [Ln, o(r) === \"loaded\"]\n    ]);\n  }\n}), Bv = /* @__PURE__ */ w({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Hl();\n    T();\n    const n = I(!1);\n    let l;\n    return te(e.imageLoadingStatus, (s) => {\n      s === \"loading\" && (n.value = !1, t.delayMs ? l = setTimeout(() => {\n        n.value = !0, clearTimeout(l);\n      }, t.delayMs) : n.value = !0);\n    }, { immediate: !0 }), (s, r) => n.value && o(e).imageLoadingStatus.value !== \"loaded\" ? (b(), _(o(O), {\n      key: 0,\n      \"as-child\": s.asChild,\n      as: s.as\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : pe(\"\", !0);\n  }\n});\nfunction xu(a) {\n  function t(n) {\n    return Array.isArray(a.date.value) ? a.date.value.some((l) => Te(l, n)) : a.date.value ? Te(a.date.value, n) : !1;\n  }\n  const e = B(\n    () => {\n      var n, l, s, r;\n      if (Array.isArray(a.date.value)) {\n        if (!a.date.value.length)\n          return !1;\n        for (const i of a.date.value)\n          if ((n = a.isDateDisabled) != null && n.call(a, i) || (l = a.isDateUnavailable) != null && l.call(a, i))\n            return !0;\n      } else {\n        if (!a.date.value)\n          return !1;\n        if ((s = a.isDateDisabled) != null && s.call(a, a.date.value) || (r = a.isDateUnavailable) != null && r.call(a, a.date.value))\n          return !0;\n      }\n      return !1;\n    }\n  );\n  return {\n    isDateSelected: t,\n    isInvalid: e\n  };\n}\nfunction Su(a, t) {\n  const e = t(a), n = e.compare(a), l = {};\n  return n >= 7 && (l.day = 1), n >= Et(a) && (l.month = 1), e.set({ ...l });\n}\nfunction Eu(a, t) {\n  const e = t(a), n = a.compare(e), l = {};\n  return n >= 7 && (l.day = 35), n >= Et(a) && (l.month = 13), e.set({ ...l });\n}\nfunction Pu(a, t) {\n  return t(a);\n}\nfunction Du(a, t) {\n  return t(a);\n}\nfunction Wl(a) {\n  const t = Un(a.locale.value), e = B(() => {\n    const m = {\n      calendar: a.placeholder.value.calendar.identifier\n    };\n    return a.placeholder.value.calendar.identifier === \"gregory\" && a.placeholder.value.era === \"BC\" && (m.era = \"short\"), m;\n  }), n = I(wt({\n    dateObj: a.placeholder.value,\n    weekStartsOn: a.weekStartsOn.value,\n    locale: a.locale.value,\n    fixedWeeks: a.fixedWeeks.value,\n    numberOfMonths: a.numberOfMonths.value\n  })), l = B(() => n.value.map((m) => m.value));\n  function s(m) {\n    return !l.value.some((S) => Vo(m, S));\n  }\n  const r = (m = \"month\", S) => {\n    if (!a.maxValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const x = n.value[n.value.length - 1].value;\n    if (S || a.nextPage.value) {\n      const h = Su(x, S || a.nextPage.value);\n      return Sa(h, a.maxValue.value);\n    }\n    if (m === \"year\") {\n      const h = x.add({ years: 1 }).set({ day: 1, month: 1 });\n      return Sa(h, a.maxValue.value);\n    }\n    const D = x.add({ months: 1 }).set({ day: 1 });\n    return Sa(D, a.maxValue.value);\n  }, i = (m = \"month\", S) => {\n    if (!a.minValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const x = n.value[0].value;\n    if (S || a.prevPage.value) {\n      const h = Eu(x, S || a.prevPage.value);\n      return ke(h, a.minValue.value);\n    }\n    if (m === \"year\") {\n      const h = x.subtract({ years: 1 }).set({ day: 35, month: 13 });\n      return ke(h, a.minValue.value);\n    }\n    const D = x.subtract({ months: 1 }).set({ day: 35 });\n    return ke(D, a.minValue.value);\n  };\n  function u(m) {\n    var S;\n    return !!((S = a.isDateDisabled) != null && S.call(a, m) || a.disabled.value || a.maxValue.value && Sa(m, a.maxValue.value) || a.minValue.value && ke(m, a.minValue.value));\n  }\n  const d = (m) => {\n    var S;\n    return !!((S = a.isDateUnavailable) != null && S.call(a, m));\n  }, c = B(() => n.value.length ? n.value[0].rows[0].map((m) => t.dayOfWeek(Le(m), a.weekdayFormat.value)) : []), p = (m = \"month\", S) => {\n    const x = n.value[0].value;\n    if (S || a.nextPage.value) {\n      const E = Pu(x, S || a.nextPage.value), P = wt({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const $ = {};\n      if (!S) {\n        const R = P[0].value.compare(x);\n        R >= Et(x) && ($.day = 1), R >= 365 && ($.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...$ });\n      return;\n    }\n    const D = m === \"month\" ? x.add({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : x.add({ years: 1 }), h = wt({\n      dateObj: D,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  }, f = (m = \"month\", S) => {\n    const x = n.value[0].value;\n    if (S || a.prevPage.value) {\n      const E = Du(x, S || a.prevPage.value), P = wt({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const $ = {};\n      if (!S) {\n        const R = x.compare(P[0].value);\n        R >= Et(x) && ($.day = 1), R >= 365 && ($.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...$ });\n      return;\n    }\n    const D = m === \"month\" ? x.subtract({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : x.subtract({ years: 1 }), h = wt({\n      dateObj: D,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  };\n  te(a.placeholder, (m) => {\n    l.value.some((S) => Vo(S, m)) || (n.value = wt({\n      dateObj: m,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    }));\n  }), te([a.locale, a.weekStartsOn, a.fixedWeeks, a.numberOfMonths], () => {\n    n.value = wt({\n      dateObj: a.placeholder.value,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n  });\n  const v = B(() => {\n    if (!n.value.length)\n      return \"\";\n    if (a.locale.value !== t.getLocale() && t.setLocale(a.locale.value), n.value.length === 1) {\n      const $ = n.value[0].value;\n      return `${t.fullMonthAndYear(Le($), e.value)}`;\n    }\n    const m = Le(n.value[0].value), S = Le(n.value[n.value.length - 1].value), x = t.fullMonth(m, e.value), D = t.fullMonth(S, e.value), h = t.fullYear(m, e.value), E = t.fullYear(S, e.value);\n    return h === E ? `${x} - ${D} ${E}` : `${x} ${h} - ${D} ${E}`;\n  }), g = B(() => `${a.calendarLabel.value ?? \"Event Date\"}, ${v.value}`);\n  return {\n    isDateDisabled: u,\n    isDateUnavailable: d,\n    isNextButtonDisabled: r,\n    isPrevButtonDisabled: i,\n    grid: n,\n    weekdays: c,\n    visibleView: l,\n    isOutsideVisibleView: s,\n    formatter: t,\n    nextPage: p,\n    prevPage: f,\n    headingValue: v,\n    fullCalendarLabel: g\n  };\n}\nconst $u = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, Bu = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [Gt, Iu] = Q(\"CalendarRoot\"), Tu = /* @__PURE__ */ w({\n  __name: \"CalendarRoot\",\n  props: {\n    modelValue: {},\n    multiple: { type: Boolean, default: !1 },\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: p,\n      multiple: f,\n      minValue: v,\n      maxValue: g,\n      numberOfMonths: m,\n      preventDeselect: S,\n      isDateDisabled: x,\n      isDateUnavailable: D,\n      calendarLabel: h,\n      defaultValue: E,\n      nextPage: P,\n      prevPage: $,\n      dir: R\n    } = ne(e), { primitiveElement: M, currentElement: V } = Ae(), A = be(R), L = ae(e, \"modelValue\", n, {\n      defaultValue: E.value,\n      passive: e.modelValue === void 0\n    }), U = jt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: L.value\n    }), H = ae(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    });\n    function J(ue) {\n      H.value = ue.copy();\n    }\n    const {\n      fullCalendarLabel: N,\n      headingValue: F,\n      isDateDisabled: W,\n      isDateUnavailable: z,\n      isNextButtonDisabled: X,\n      isPrevButtonDisabled: G,\n      weekdays: Z,\n      isOutsideVisibleView: ee,\n      nextPage: fe,\n      prevPage: q,\n      formatter: oe,\n      grid: he\n    } = Wl({\n      locale: l,\n      placeholder: H,\n      weekStartsOn: d,\n      fixedWeeks: p,\n      numberOfMonths: m,\n      minValue: v,\n      maxValue: g,\n      disabled: s,\n      weekdayFormat: c,\n      pagedNavigation: u,\n      isDateDisabled: x.value,\n      isDateUnavailable: D.value,\n      calendarLabel: h,\n      nextPage: P,\n      prevPage: $\n    }), {\n      isInvalid: Ce,\n      isDateSelected: ge\n    } = xu({\n      date: L,\n      isDateDisabled: W,\n      isDateUnavailable: z\n    });\n    te(L, (ue) => {\n      if (Array.isArray(ue) && ue.length) {\n        const Se = ue[ue.length - 1];\n        Se && !Ee(H.value, Se) && J(Se);\n      } else !Array.isArray(ue) && ue && !Ee(H.value, ue) && J(ue);\n    });\n    function De(ue) {\n      if (f.value) {\n        if (Array.isArray(L.value)) {\n          if (!L.value) {\n            L.value = [ue.copy()];\n            return;\n          }\n          if (L.value.findIndex((Ve) => Te(Ve, ue)) === -1)\n            L.value = [...L.value, ue];\n          else if (!S.value) {\n            const Ve = L.value.filter((Ke) => !Te(Ke, ue));\n            if (!Ve.length) {\n              H.value = ue.copy(), L.value = void 0;\n              return;\n            }\n            L.value = Ve.map((Ke) => Ke.copy());\n          }\n        }\n      } else {\n        if (!L.value) {\n          L.value = ue.copy();\n          return;\n        }\n        !S.value && Ee(L.value, ue) ? (H.value = ue.copy(), L.value = void 0) : L.value = ue.copy();\n      }\n    }\n    return se(() => {\n      i.value && Cl(V.value);\n    }), Iu({\n      isDateUnavailable: z,\n      dir: A,\n      isDateDisabled: W,\n      locale: l,\n      formatter: oe,\n      modelValue: L,\n      placeholder: H,\n      disabled: s,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: p,\n      multiple: f,\n      numberOfMonths: m,\n      readonly: r,\n      preventDeselect: S,\n      fullCalendarLabel: N,\n      headingValue: F,\n      isInvalid: Ce,\n      isDateSelected: ge,\n      isNextButtonDisabled: X,\n      isPrevButtonDisabled: G,\n      isOutsideVisibleView: ee,\n      nextPage: fe,\n      prevPage: q,\n      parentElement: V,\n      onPlaceholderChange: J,\n      onDateChange: De\n    }), (ue, Se) => (b(), _(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: M,\n      as: ue.as,\n      \"as-child\": ue.asChild,\n      role: \"application\",\n      \"aria-label\": o(N),\n      \"data-readonly\": o(r) ? \"\" : void 0,\n      \"data-disabled\": o(s) ? \"\" : void 0,\n      \"data-invalid\": o(Ce) ? \"\" : void 0,\n      dir: o(A)\n    }, {\n      default: y(() => [\n        C(ue.$slots, \"default\", {\n          date: o(H),\n          grid: o(he),\n          weekDays: o(Z),\n          weekStartsOn: o(d),\n          locale: o(l),\n          fixedWeeks: o(p)\n        }),\n        Ue(\"div\", $u, [\n          Ue(\"div\", Bu, $e(o(N)), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), Ru = /* @__PURE__ */ w({\n  __name: \"CalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Au = /* @__PURE__ */ w({\n  __name: \"CalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Gt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          ve($e(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), Ou = /* @__PURE__ */ w({\n  __name: \"CalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = Gt(), n = B(() => e.disabled.value ? !0 : void 0), l = B(() => e.readonly.value ? !0 : void 0);\n    return (s, r) => (b(), _(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": l.value,\n      \"aria-disabled\": n.value,\n      \"data-readonly\": l.value && \"\",\n      \"data-disabled\": n.value && \"\"\n    }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), ku = /* @__PURE__ */ w({\n  __name: \"CalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = Gt();\n    return (e, n) => {\n      var l, s;\n      return b(), _(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isDateSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          C(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), Mu = /* @__PURE__ */ w({\n  __name: \"CalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vu = /* @__PURE__ */ w({\n  __name: \"CalendarNext\",\n  props: {\n    step: { default: \"month\" },\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = Gt();\n    return (l, s) => (b(), _(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }, {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Fu = /* @__PURE__ */ w({\n  __name: \"CalendarPrev\",\n  props: {\n    step: { default: \"month\" },\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = Gt();\n    return (l, s) => (b(), _(o(O), {\n      \"aria-label\": \"Previous page\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }, {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Lu = /* @__PURE__ */ w({\n  __name: \"CalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nu = /* @__PURE__ */ w({\n  __name: \"CalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zu = /* @__PURE__ */ w({\n  __name: \"CalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ku = /* @__PURE__ */ w({\n  __name: \"CalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = et(), n = Gt(), { primitiveElement: l, currentElement: s } = Ae(), r = B(() => t.day.day.toLocaleString(n.locale.value)), i = B(() => n.formatter.custom(Le(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), u = B(() => n.isDateDisabled(t.day)), d = B(\n      () => {\n        var h;\n        return (h = n.isDateUnavailable) == null ? void 0 : h.call(n, t.day);\n      }\n    ), c = B(() => fl(t.day, zn())), p = B(() => !vl(t.day, t.month)), f = B(\n      () => n.isOutsideVisibleView(t.day)\n    ), v = B(() => !n.disabled.value && Te(t.day, n.placeholder.value)), g = B(() => n.isDateSelected(t.day)), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])\";\n    function S(h) {\n      var E;\n      n.readonly.value || n.isDateDisabled(h) || (E = n.isDateUnavailable) != null && E.call(n, h) || n.onDateChange(h);\n    }\n    function x() {\n      S(t.day);\n    }\n    function D(h) {\n      h.preventDefault(), h.stopPropagation();\n      const E = n.parentElement.value, P = E ? Array.from(E.querySelectorAll(m)) : [];\n      let R = P.indexOf(s.value);\n      const M = 7, V = n.dir.value === \"rtl\" ? -1 : 1;\n      switch (h.code) {\n        case e.ARROW_RIGHT:\n          R += V;\n          break;\n        case e.ARROW_LEFT:\n          R -= V;\n          break;\n        case e.ARROW_UP:\n          R -= M;\n          break;\n        case e.ARROW_DOWN:\n          R += M;\n          break;\n        case e.ENTER:\n        case e.SPACE_CODE:\n          S(t.day);\n          return;\n        default:\n          return;\n      }\n      if (R >= 0 && R < P.length) {\n        P[R].focus();\n        return;\n      }\n      if (R < 0) {\n        if (n.isPrevButtonDisabled(\"month\"))\n          return;\n        n.prevPage(), le(() => {\n          const A = E ? Array.from(E.querySelectorAll(m)) : [];\n          A[A.length - Math.abs(R)].focus();\n        });\n        return;\n      }\n      if (R >= P.length) {\n        if (n.isNextButtonDisabled(\"month\"))\n          return;\n        n.nextPage(), le(() => {\n          (E ? Array.from(E.querySelectorAll(m)) : [])[R - P.length].focus();\n        });\n      }\n    }\n    return (h, E) => (b(), _(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": i.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-disabled\": p.value || u.value || d.value ? !0 : void 0,\n      \"data-selected\": g.value ? !0 : void 0,\n      \"data-value\": h.day.toString(),\n      \"data-disabled\": u.value || p.value ? \"\" : void 0,\n      \"data-unavailable\": d.value ? \"\" : void 0,\n      \"data-today\": c.value ? \"\" : void 0,\n      \"data-outside-view\": p.value ? \"\" : void 0,\n      \"data-outside-visible-view\": f.value ? \"\" : void 0,\n      \"data-focused\": v.value ? \"\" : void 0,\n      tabindex: v.value ? 0 : p.value || u.value ? void 0 : -1,\n      onClick: x,\n      onKeydown: [\n        re(D, [\"up\", \"down\", \"left\", \"right\", \"space\", \"enter\"]),\n        E[0] || (E[0] = re(ie(() => {\n        }, [\"prevent\"]), [\"enter\"]))\n      ]\n    }), {\n      default: y(() => [\n        C(h.$slots, \"default\", { dayValue: r.value }, () => [\n          ve($e(r.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-disabled\", \"data-selected\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-view\", \"data-outside-visible-view\", \"data-focused\", \"tabindex\"]));\n  }\n});\nfunction La(a) {\n  return a === \"indeterminate\";\n}\nfunction jl(a) {\n  return La(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nconst Hu = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [Wu, ju] = Q(\"CheckboxRoot\"), Iv = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ne(e), s = ae(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { forwardRef: r, currentElement: i } = T(), u = Qe(i), d = B(() => {\n      var c;\n      return e.id && i.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return ju({\n      disabled: l,\n      state: s\n    }), (c, p) => (b(), ce(_e, null, [\n      Y(o(O), k(c.$attrs, {\n        id: c.id,\n        ref: o(r),\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: c.as,\n        type: c.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": o(La)(o(s)) ? \"mixed\" : o(s),\n        \"aria-required\": !1,\n        \"aria-label\": c.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": o(jl)(o(s)),\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        disabled: o(l),\n        onKeydown: re(ie(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: p[0] || (p[0] = (f) => s.value = o(La)(o(s)) ? !0 : !o(s))\n      }), {\n        default: y(() => [\n          C(c.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      o(u) ? (b(), ce(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: c.value,\n        checked: !!o(s),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Hu)) : pe(\"\", !0)\n    ], 64));\n  }\n}), Tv = /* @__PURE__ */ w({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = T(), e = Wu();\n    return (n, l) => (b(), _(o(Pe), {\n      present: n.forceMount || o(La)(o(e).state.value) || o(e).state.value === !0\n    }, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(t),\n          \"data-state\": o(jl)(o(e).state.value),\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Ul, Uu] = Q(\"PopperRoot\"), It = /* @__PURE__ */ w({\n  __name: \"PopperRoot\",\n  setup(a) {\n    const t = I();\n    return Uu({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, n) => C(e.$slots, \"default\");\n  }\n}), Tt = /* @__PURE__ */ w({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = T(), l = Ul();\n    return te(n, () => {\n      l.onAnchorChange(t.element ?? n.value);\n    }), (s, r) => (b(), _(o(O), {\n      ref: o(e),\n      as: s.as,\n      \"as-child\": s.asChild\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction Gu(a) {\n  return a !== null;\n}\nfunction qu(a) {\n  return {\n    name: \"transformOrigin\",\n    options: a,\n    fn(t) {\n      var S, x, D;\n      const { placement: e, rects: n, middlewareData: l } = t, r = ((S = l.arrow) == null ? void 0 : S.centerOffset) !== 0, i = r ? 0 : a.arrowWidth, u = r ? 0 : a.arrowHeight, [d, c] = Bn(e), p = { start: \"0%\", center: \"50%\", end: \"100%\" }[c], f = (((x = l.arrow) == null ? void 0 : x.x) ?? 0) + i / 2, v = (((D = l.arrow) == null ? void 0 : D.y) ?? 0) + u / 2;\n      let g = \"\", m = \"\";\n      return d === \"bottom\" ? (g = r ? p : `${f}px`, m = `${-u}px`) : d === \"top\" ? (g = r ? p : `${f}px`, m = `${n.floating.height + u}px`) : d === \"right\" ? (g = `${-u}px`, m = r ? p : `${v}px`) : d === \"left\" && (g = `${n.floating.width + u}px`, m = r ? p : `${v}px`), { data: { x: g, y: m } };\n    }\n  };\n}\nfunction Bn(a) {\n  const [t, e = \"center\"] = a.split(\"-\");\n  return [t, e];\n}\nconst Gl = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: !0,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: !1,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: !1\n}, [Yu, Xu] = Q(\"PopperContent\"), Pt = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"PopperContent\",\n  props: /* @__PURE__ */ cl({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Gl\n  }),\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Ul(), { forwardRef: s, currentElement: r } = T(), i = I(), u = I(), { width: d, height: c } = Rl(u), p = B(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), f = B(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = B(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), g = B(() => ({\n      padding: f.value,\n      boundary: v.value.filter(Gu),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: v.value.length > 0\n    })), m = Ur(() => [\n      Er({\n        mainAxis: e.sideOffset + c.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.prioritizePosition && e.avoidCollisions && Fo({\n        ...g.value\n      }),\n      e.avoidCollisions && Pr({\n        mainAxis: !0,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Dr() : void 0,\n        ...g.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && Fo({\n        ...g.value\n      }),\n      $r({\n        ...g.value,\n        apply: ({ elements: A, rects: L, availableWidth: U, availableHeight: H }) => {\n          const { width: J, height: N } = L.reference, F = A.floating.style;\n          F.setProperty(\n            \"--radix-popper-available-width\",\n            `${U}px`\n          ), F.setProperty(\n            \"--radix-popper-available-height\",\n            `${H}px`\n          ), F.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${J}px`\n          ), F.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${N}px`\n          );\n        }\n      }),\n      u.value && Br({ element: u.value, padding: e.arrowPadding }),\n      qu({\n        arrowWidth: d.value,\n        arrowHeight: c.value\n      }),\n      e.hideWhenDetached && Ir({ strategy: \"referenceHidden\", ...g.value })\n    ]), { floatingStyles: S, placement: x, isPositioned: D, middlewareData: h } = xr(\n      l.anchor,\n      i,\n      {\n        strategy: \"fixed\",\n        placement: p,\n        whileElementsMounted: (...A) => Sr(...A, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: m\n      }\n    ), E = B(\n      () => Bn(x.value)[0]\n    ), P = B(\n      () => Bn(x.value)[1]\n    );\n    ye(() => {\n      D.value && n(\"placed\");\n    });\n    const $ = B(\n      () => {\n        var A;\n        return ((A = h.value.arrow) == null ? void 0 : A.centerOffset) !== 0;\n      }\n    ), R = I(\"\");\n    ye(() => {\n      r.value && (R.value = window.getComputedStyle(r.value).zIndex);\n    });\n    const M = B(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.x) ?? 0;\n    }), V = B(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.y) ?? 0;\n    });\n    return Xu({\n      placedSide: E,\n      onArrowChange: (A) => u.value = A,\n      arrowX: M,\n      arrowY: V,\n      shouldHideArrow: $\n    }), (A, L) => {\n      var U, H, J;\n      return b(), ce(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: i,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: Oe({\n          ...o(S),\n          transform: o(D) ? o(S).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: R.value,\n          \"--radix-popper-transform-origin\": [\n            (U = o(h).transformOrigin) == null ? void 0 : U.x,\n            (H = o(h).transformOrigin) == null ? void 0 : H.y\n          ].join(\" \"),\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...((J = o(h).hide) == null ? void 0 : J.referenceHidden) && {\n            visibility: \"hidden\",\n            pointerEvents: \"none\"\n          }\n        })\n      }, [\n        Y(o(O), k({ ref: o(s) }, A.$attrs, {\n          \"as-child\": e.asChild,\n          as: A.as,\n          \"data-side\": E.value,\n          \"data-align\": P.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: o(D) ? void 0 : \"none\"\n          }\n        }), {\n          default: y(() => [\n            C(A.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), Zu = /* @__PURE__ */ Ue(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), Ju = /* @__PURE__ */ w({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), k(t, {\n      width: e.width,\n      height: e.height,\n      viewBox: e.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: e.asChild ? void 0 : \"none\"\n    }), {\n      default: y(() => [\n        C(e.$slots, \"default\", {}, () => [\n          Zu\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), Qu = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, qt = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = T(), e = Yu(), n = B(() => Qu[e.placedSide.value]);\n    return (l, s) => {\n      var r, i, u, d;\n      return b(), ce(\"span\", {\n        ref: (c) => {\n          o(e).onArrowChange(c);\n        },\n        style: Oe({\n          position: \"absolute\",\n          left: (r = o(e).arrowX) != null && r.value ? `${(i = o(e).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (u = o(e).arrowY) != null && u.value ? `${(d = o(e).arrowY) == null ? void 0 : d.value}px` : void 0,\n          [n.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[o(e).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[o(e).placedSide.value],\n          visibility: o(e).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        Y(Ju, k(l.$attrs, {\n          ref: o(t),\n          style: {\n            display: \"block\"\n          },\n          as: l.as,\n          \"as-child\": l.asChild,\n          width: l.width,\n          height: l.height\n        }), {\n          default: y(() => [\n            C(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Yt = /* @__PURE__ */ w({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return T(), (t, e) => (b(), _(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: {\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      }\n    }, {\n      default: y(() => [\n        C(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), to = /* @__PURE__ */ w({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(a) {\n    const t = a, e = B(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((n, l) => typeof n == \"object\" ? Object.entries(n).map(([s, r]) => ({ name: `[${l}][${t.name}][${s}]`, value: r })) : { name: `[${t.name}][${l}]`, value: n }) : t.value !== null && typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, l]) => ({ name: `[${t.name}][${n}]`, value: l })) : []);\n    return (n, l) => (b(!0), ce(_e, null, va(e.value, (s) => (b(), _(Yt, {\n      key: s.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: s.name,\n      value: s.value,\n      required: n.required,\n      disabled: n.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n}), ed = \"data-radix-vue-collection-item\", [ao, td] = Q(\"CollectionProvider\");\nfunction ba(a = ed) {\n  const t = I(/* @__PURE__ */ new Map()), e = I(), n = td({\n    collectionRef: e,\n    itemMap: t,\n    attrName: a\n  }), { getItems: l } = Zt(n), s = B(() => Array.from(n.itemMap.value.values())), r = B(() => n.itemMap.value.size);\n  return { getItems: l, reactiveItems: s, itemMapSize: r };\n}\nconst Ca = w({\n  name: \"CollectionSlot\",\n  setup(a, { slots: t }) {\n    const e = ao(), { primitiveElement: n, currentElement: l } = Ae();\n    return te(l, () => {\n      e.collectionRef.value = l.value;\n    }), () => pt(Xn, { ref: n }, t);\n  }\n}), Xt = w({\n  name: \"CollectionItem\",\n  inheritAttrs: !1,\n  props: {\n    value: {\n      // It accepts any value\n      validator: () => !0\n    }\n  },\n  setup(a, { slots: t, attrs: e }) {\n    const n = ao(), { primitiveElement: l, currentElement: s } = Ae();\n    return ye((r) => {\n      if (s.value) {\n        const i = vr(s.value);\n        n.itemMap.value.set(i, { ref: s.value, value: a.value }), r(() => n.itemMap.value.delete(i));\n      }\n    }), () => pt(Xn, { ...e, [n.attrName]: \"\", ref: l }, t);\n  }\n});\nfunction Zt(a) {\n  const t = a ?? ao();\n  return { getItems: () => {\n    const n = t.collectionRef.value;\n    if (!n)\n      return [];\n    const l = Array.from(n.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (i, u) => l.indexOf(i.ref) - l.indexOf(u.ref)\n    );\n  } };\n}\nconst [nt, ad] = Q(\"ComboboxRoot\"), Rv = /* @__PURE__ */ w({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    selectedValue: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    resetSearchTermOnBlur: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\", \"update:selectedValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, disabled: s, dir: r } = ne(e), i = be(r), u = ae(e, \"searchTerm\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), d = ae(e, \"modelValue\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? l.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), c = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), p = ae(e, \"selectedValue\", n, {\n      defaultValue: void 0,\n      passive: e.selectedValue === void 0\n    });\n    async function f(N) {\n      var F, W;\n      c.value = N, await le(), N ? (d.value && (Array.isArray(d.value) && l.value ? p.value = (F = h().find((z) => {\n        var X, G;\n        return ((G = (X = z.ref) == null ? void 0 : X.dataset) == null ? void 0 : G.state) === \"checked\";\n      })) == null ? void 0 : F.value : p.value = d.value), (W = m.value) == null || W.focus(), H()) : (g.value = !1, e.resetSearchTermOnBlur && M());\n    }\n    function v(N) {\n      if (Array.isArray(d.value) && l.value) {\n        const F = d.value.findIndex((z) => Ye(z, N)), W = [...d.value];\n        F === -1 ? W.push(N) : W.splice(F, 1), d.value = W;\n      } else\n        d.value = N, f(!1);\n    }\n    const g = I(!1), m = I(), S = I(), { forwardRef: x, currentElement: D } = T(), { getItems: h, reactiveItems: E, itemMapSize: P } = ba(\"data-radix-vue-combobox-item\"), $ = I([]);\n    te(() => P.value, () => {\n      $.value = h().map((N) => N.value);\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    });\n    const R = B(() => {\n      if (g.value) {\n        if (e.filterFunction)\n          return e.filterFunction($.value, u.value);\n        const N = $.value.filter((F) => typeof F == \"string\");\n        if (N.length)\n          return N.filter((F) => {\n            var W;\n            return F.toLowerCase().includes((W = u.value) == null ? void 0 : W.toLowerCase());\n          });\n      }\n      return $.value;\n    });\n    function M() {\n      !l.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != \"object\" ? u.value = d.value.toString() : u.value = \"\" : u.value = \"\";\n    }\n    const V = B(() => R.value.findIndex((N) => Ye(N, p.value))), A = B(() => {\n      var N;\n      return (N = E.value.find((F) => Ye(F.value, p.value))) == null ? void 0 : N.ref;\n    }), L = B(() => JSON.stringify(d.value));\n    te(L, async () => {\n      await le(), await le(), M();\n    }, {\n      // If searchTerm is provided with value during initialization, we don't reset it immediately\n      immediate: !e.searchTerm\n    }), te(() => [R.value.length, u.value.length], async ([N, F], [W, z]) => {\n      await le(), await le(), N && (z > F || V.value === -1) && (p.value = R.value[0]);\n    });\n    const U = Qe(D);\n    function H() {\n      A.value instanceof Element && A.value.scrollIntoView({ block: \"nearest\" });\n    }\n    function J() {\n      A.value instanceof Element && A.value.focus && A.value.focus();\n    }\n    return ad({\n      searchTerm: u,\n      modelValue: d,\n      // @ts-expect-error ignoring\n      onValueChange: v,\n      isUserInputted: g,\n      multiple: l,\n      disabled: s,\n      open: c,\n      onOpenChange: f,\n      filteredOptions: R,\n      contentId: \"\",\n      inputElement: m,\n      selectedElement: A,\n      onInputElementChange: (N) => m.value = N,\n      onInputNavigation: async (N) => {\n        const F = V.value;\n        F === 0 && N === \"up\" || F === R.value.length - 1 && N === \"down\" || (F === -1 && R.value.length || N === \"home\" ? p.value = R.value[0] : N === \"end\" ? p.value = R.value[R.value.length - 1] : p.value = R.value[N === \"up\" ? F - 1 : F + 1], H(), J(), le(() => {\n          var W;\n          return (W = m.value) == null ? void 0 : W.focus({ preventScroll: !0 });\n        }));\n      },\n      onInputEnter: async () => {\n        var N;\n        R.value.length && p.value && A.value instanceof Element && ((N = A.value) == null || N.click());\n      },\n      selectedValue: p,\n      onSelectedValueChange: (N) => p.value = N,\n      parentElement: D,\n      contentElement: S,\n      onContentElementChange: (N) => S.value = N\n    }), (N, F) => (b(), _(o(It), null, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(x),\n          style: {\n            pointerEvents: o(c) ? \"auto\" : void 0\n          },\n          as: N.as,\n          \"as-child\": N.asChild,\n          dir: o(i)\n        }, N.$attrs), {\n          default: y(() => [\n            C(N.$slots, \"default\", {\n              open: o(c),\n              modelValue: o(d)\n            }),\n            o(U) && e.name ? (b(), _(o(to), {\n              key: 0,\n              name: e.name,\n              value: o(d)\n            }, null, 8, [\"name\", \"value\"])) : pe(\"\", !0)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Av = /* @__PURE__ */ w({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), { forwardRef: n, currentElement: l } = T();\n    se(() => {\n      const c = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      c && (e.onInputElementChange(c), setTimeout(() => {\n        t.autoFocus && (c == null || c.focus());\n      }, 1));\n    });\n    const s = B(() => t.disabled || e.disabled.value || !1), r = I();\n    mr(() => {\n      var c;\n      return r.value = (c = e.selectedElement.value) == null ? void 0 : c.id;\n    });\n    function i(c) {\n      e.open.value ? e.onInputNavigation(c.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(!0);\n    }\n    function u(c) {\n      e.open.value && e.onInputNavigation(c.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function d(c) {\n      var p;\n      e.searchTerm.value = (p = c.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;\n    }\n    return (c, p) => (b(), _(o(O), {\n      ref: o(n),\n      as: c.as,\n      \"as-child\": c.asChild,\n      type: c.type,\n      disabled: s.value,\n      value: o(e).searchTerm.value,\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"aria-disabled\": s.value ?? void 0,\n      \"aria-activedescendant\": r.value,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: d,\n      onKeydown: [\n        re(ie(i, [\"prevent\"]), [\"down\", \"up\"]),\n        re(o(e).onInputEnter, [\"enter\"]),\n        re(ie(u, [\"prevent\"]), [\"home\", \"end\"])\n      ]\n    }, {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"disabled\", \"value\", \"aria-expanded\", \"aria-controls\", \"aria-disabled\", \"aria-activedescendant\", \"onKeydown\"]));\n  }\n}), Ov = /* @__PURE__ */ w({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t } = T();\n    return (e, n) => (b(), _(o(Tt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(t),\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: y(() => [\n            C(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), kv = /* @__PURE__ */ w({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = nt(), n = B(() => t.disabled || e.disabled.value || !1);\n    return (l, s) => (b(), _(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      disabled: n.value,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"aria-disabled\": n.value ?? void 0,\n      onClick: s[0] || (s[0] = (r) => o(e).onOpenChange(!o(e).open.value))\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), Mv = /* @__PURE__ */ w({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = nt();\n    function n() {\n      var l;\n      e.searchTerm.value = \"\", (l = e.inputElement.value) == null || l.focus();\n    }\n    return (l, s) => (b(), _(o(O), k({\n      type: l.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: n\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [ql, nd] = Q(\"ComboboxGroup\"), Vv = /* @__PURE__ */ w({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { currentRef: e, currentElement: n } = T(), l = me(void 0, \"radix-vue-combobox-group\"), s = nt(), r = I(!1);\n    function i() {\n      if (!n.value)\n        return;\n      const u = n.value.querySelectorAll(\"[data-radix-vue-combobox-item]:not([data-hidden])\");\n      r.value = !!u.length;\n    }\n    return Pl(n, () => {\n      le(() => {\n        i();\n      });\n    }, { childList: !0 }), te(() => s.searchTerm.value, () => {\n      le(() => {\n        i();\n      });\n    }, { immediate: !0 }), nd({\n      id: l\n    }), (u, d) => Ha((b(), _(o(O), k(t, {\n      ref_key: \"currentRef\",\n      ref: e,\n      role: \"group\",\n      \"aria-labelledby\": o(l)\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [Ln, r.value]\n    ]);\n  }\n}), Fv = /* @__PURE__ */ w({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = ql({ id: \"\" });\n    return (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [od, ld] = Q(\"ComboboxContent\"), sd = /* @__PURE__ */ w({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { position: l } = ne(e), s = nt();\n    ha(e.bodyLock);\n    const { forwardRef: r, currentElement: i } = T();\n    ya(i);\n    const u = B(() => e.position === \"popper\" ? e : {}), d = Bt(u.value);\n    function c(f) {\n      s.onSelectedValueChange(\"\");\n    }\n    se(() => {\n      s.onContentElementChange(i.value);\n    });\n    const p = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return ld({ position: l }), (f, v) => (b(), _(o(Ca), null, {\n      default: y(() => [\n        f.dismissable ? (b(), _(o(yt), {\n          key: 0,\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": f.disableOutsidePointerEvents,\n          onDismiss: v[0] || (v[0] = (g) => o(s).onOpenChange(!1)),\n          onFocusOutside: v[1] || (v[1] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"focusOutside\", g);\n          }),\n          onInteractOutside: v[2] || (v[2] = (g) => n(\"interactOutside\", g)),\n          onEscapeKeyDown: v[3] || (v[3] = (g) => n(\"escapeKeyDown\", g)),\n          onPointerDownOutside: v[4] || (v[4] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"pointerDownOutside\", g);\n          })\n        }, {\n          default: y(() => [\n            (b(), _(Ge(o(l) === \"popper\" ? o(Pt) : o(O)), k({ ...f.$attrs, ...o(d) }, {\n              id: o(s).contentId,\n              ref: o(r),\n              role: \"listbox\",\n              \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...o(l) === \"popper\" ? p : {}\n              },\n              onPointerleave: c\n            }), {\n              default: y(() => [\n                C(f.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])) : (b(), _(Ge(o(l) === \"popper\" ? o(Pt) : o(O)), k({ key: 1 }, { ...f.$attrs, ...u.value }, {\n          id: o(s).contentId,\n          ref: o(r),\n          role: \"listbox\",\n          \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n          style: {\n            // flex layout so we can place the scroll buttons properly\n            display: \"flex\",\n            flexDirection: \"column\",\n            // reset the outline by default as the content MAY get focused\n            outline: \"none\",\n            ...o(l) === \"popper\" ? p : {}\n          },\n          onPointerleave: c\n        }), {\n          default: y(() => [\n            C(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"data-state\", \"style\"]))\n      ]),\n      _: 3\n    }));\n  }\n}), Lv = /* @__PURE__ */ w({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), { forwardRef: s } = T(), r = nt();\n    return r.contentId || (r.contentId = me(void 0, \"radix-vue-combobox-content\")), (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        Y(sd, k({ ...o(l), ...i.$attrs }, { ref: o(s) }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Nv = /* @__PURE__ */ w({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = nt(), n = B(() => e.filteredOptions.value.length === 0);\n    return (l, s) => n.value ? (b(), _(o(O), K(k({ key: 0 }, t)), {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n});\nfunction Xa(a) {\n  const t = Ga({\n    nonce: I()\n  });\n  return B(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.nonce) == null ? void 0 : e.value);\n  });\n}\nconst zv = /* @__PURE__ */ w({\n  __name: \"ComboboxViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), { nonce: n } = ne(t), l = Xa(n);\n    return (s, r) => (b(), ce(_e, null, [\n      Y(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          C(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      Y(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ve(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), [rd, id] = Q(\"ComboboxItem\"), ud = \"combobox.select\", Kv = /* @__PURE__ */ w({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ne(e), s = nt();\n    ql({ id: \"\", options: I([]) });\n    const { forwardRef: r } = T(), i = B(\n      () => {\n        var m, S;\n        return s.multiple.value && Array.isArray(s.modelValue.value) ? (m = s.modelValue.value) == null ? void 0 : m.some((x) => Ye(x, e.value)) : Ye((S = s.modelValue) == null ? void 0 : S.value, e.value);\n      }\n    ), u = B(() => Ye(s.selectedValue.value, e.value)), d = me(void 0, \"radix-vue-combobox-item\"), c = me(void 0, \"radix-vue-combobox-option\"), p = B(() => s.isUserInputted.value ? s.searchTerm.value === \"\" || !!s.filteredOptions.value.find((m) => Ye(m, e.value)) : !0);\n    async function f(m) {\n      n(\"select\", m), !(m != null && m.defaultPrevented) && !l.value && m && s.onValueChange(e.value);\n    }\n    function v(m) {\n      if (!m)\n        return;\n      const S = { originalEvent: m, value: e.value };\n      zt(ud, f, S);\n    }\n    async function g(m) {\n      await le(), !m.defaultPrevented && s.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return id({\n      isSelected: i\n    }), (m, S) => (b(), _(o(Xt), { value: m.value }, {\n      default: y(() => [\n        Ha(Y(o(O), {\n          id: o(c),\n          ref: o(r),\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": o(d),\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"aria-selected\": i.value,\n          \"data-state\": i.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": o(l) || void 0,\n          \"data-disabled\": o(l) ? \"\" : void 0,\n          as: m.as,\n          \"as-child\": m.asChild,\n          \"data-hidden\": p.value ? void 0 : !0,\n          onClick: v,\n          onPointermove: g\n        }, {\n          default: y(() => [\n            C(m.$slots, \"default\", {}, () => [\n              ve($e(m.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"id\", \"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\", \"data-hidden\"]), [\n          [Ln, p.value]\n        ])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), Hv = /* @__PURE__ */ w({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = rd();\n    return (n, l) => o(e).isSelected.value ? (b(), _(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), Wv = /* @__PURE__ */ w({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), k(t, { \"aria-hidden\": \"\" }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jv = /* @__PURE__ */ w({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), n = od();\n    return T(), (l, s) => o(e).open.value && o(n).position.value === \"popper\" ? (b(), _(o(qt), K(k({ key: 0 }, t)), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), Uv = /* @__PURE__ */ w({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Za = /* @__PURE__ */ w({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Tt), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), no = /* @__PURE__ */ w({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(qt), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Rt, Yl] = Q([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [wa, dd] = Q(\"MenuRoot\"), oo = /* @__PURE__ */ w({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: !1 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l, dir: s } = ne(e), r = be(s), i = ae(e, \"open\", n), u = I(), d = I(!1);\n    return ye((c) => {\n      if (!Je)\n        return;\n      const p = () => {\n        d.value = !0, document.addEventListener(\"pointerdown\", f, {\n          capture: !0,\n          once: !0\n        }), document.addEventListener(\"pointermove\", f, {\n          capture: !0,\n          once: !0\n        });\n      }, f = () => d.value = !1;\n      document.addEventListener(\"keydown\", p, { capture: !0 }), c(() => {\n        document.removeEventListener(\"keydown\", p, { capture: !0 }), document.removeEventListener(\"pointerdown\", f, {\n          capture: !0\n        }), document.removeEventListener(\"pointermove\", f, {\n          capture: !0\n        });\n      });\n    }), Yl({\n      open: i,\n      onOpenChange: (c) => {\n        i.value = c;\n      },\n      content: u,\n      onContentChange: (c) => {\n        u.value = c;\n      }\n    }), dd({\n      onClose: () => {\n        i.value = !1;\n      },\n      isUsingKeyboardRef: d,\n      dir: r,\n      modal: l\n    }), (c, p) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), cd = \"rovingFocusGroup.onEntryFocus\", pd = { bubbles: !1, cancelable: !0 }, Ja = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction fd(a, t) {\n  return t !== \"rtl\" ? a : a === \"ArrowLeft\" ? \"ArrowRight\" : a === \"ArrowRight\" ? \"ArrowLeft\" : a;\n}\nfunction Xl(a, t, e) {\n  const n = fd(a.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(n)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(n)))\n    return Ja[n];\n}\nfunction Zl(a, t = !1) {\n  const e = document.activeElement;\n  for (const n of a)\n    if (n === e || (n.focus({ preventScroll: t }), document.activeElement !== e))\n      return;\n}\nfunction vd(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nconst [md, hd] = Q(\"RovingFocusGroup\"), At = /* @__PURE__ */ w({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !1 },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    preventScrollOnEntryFocus: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { loop: s, orientation: r, dir: i } = ne(n), u = be(i), d = ae(n, \"currentTabStopId\", l, {\n      defaultValue: n.defaultCurrentTabStopId,\n      passive: n.currentTabStopId === void 0\n    }), c = I(!1), p = I(!1), f = I(0), { getItems: v } = ba();\n    function g(m) {\n      const S = !p.value;\n      if (m.currentTarget && m.target === m.currentTarget && S && !c.value) {\n        const x = new CustomEvent(cd, pd);\n        if (m.currentTarget.dispatchEvent(x), l(\"entryFocus\", x), !x.defaultPrevented) {\n          const D = v().map(($) => $.ref).filter(($) => $.dataset.disabled !== \"\"), h = D.find(($) => $.getAttribute(\"data-active\") === \"true\"), E = D.find(\n            ($) => $.id === d.value\n          ), P = [h, E, ...D].filter(\n            Boolean\n          );\n          Zl(P, n.preventScrollOnEntryFocus);\n        }\n      }\n      p.value = !1;\n    }\n    return t({\n      getItems: v\n    }), hd({\n      loop: s,\n      dir: u,\n      orientation: r,\n      currentTabStopId: d,\n      onItemFocus: (m) => {\n        d.value = m;\n      },\n      onItemShiftTab: () => {\n        c.value = !0;\n      },\n      onFocusableItemAdd: () => {\n        f.value++;\n      },\n      onFocusableItemRemove: () => {\n        f.value--;\n      }\n    }), (m, S) => (b(), _(o(Ca), null, {\n      default: y(() => [\n        Y(o(O), {\n          tabindex: c.value || f.value === 0 ? -1 : 0,\n          \"data-orientation\": o(r),\n          as: m.as,\n          \"as-child\": m.asChild,\n          dir: o(u),\n          style: { outline: \"none\" },\n          onMousedown: S[0] || (S[0] = (x) => p.value = !0),\n          onFocus: g,\n          onBlur: S[1] || (S[1] = (x) => c.value = !1)\n        }, {\n          default: y(() => [\n            C(m.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Ot = /* @__PURE__ */ w({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: !0 },\n    active: { type: Boolean, default: !0 },\n    allowShiftKey: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = md(), n = B(() => t.tabStopId || me()), l = B(\n      () => e.currentTabStopId.value === n.value\n    ), { getItems: s } = Zt();\n    se(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), Ie(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function r(i) {\n      if (i.key === \"Tab\" && i.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (i.target !== i.currentTarget)\n        return;\n      const u = Xl(\n        i,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (u !== void 0) {\n        if (i.metaKey || i.ctrlKey || i.altKey || !t.allowShiftKey && i.shiftKey)\n          return;\n        i.preventDefault();\n        let d = [...s().map((c) => c.ref).filter((c) => c.dataset.disabled !== \"\")];\n        if (u === \"last\")\n          d.reverse();\n        else if (u === \"prev\" || u === \"next\") {\n          u === \"prev\" && d.reverse();\n          const c = d.indexOf(\n            i.currentTarget\n          );\n          d = e.loop.value ? vd(d, c + 1) : d.slice(c + 1);\n        }\n        le(() => Zl(d));\n      }\n    }\n    return (i, u) => (b(), _(o(Xt), null, {\n      default: y(() => [\n        Y(o(O), {\n          tabindex: l.value ? 0 : -1,\n          \"data-orientation\": o(e).orientation.value,\n          \"data-active\": i.active,\n          \"data-disabled\": i.focusable ? void 0 : \"\",\n          as: i.as,\n          \"as-child\": i.asChild,\n          onMousedown: u[0] || (u[0] = (d) => {\n            i.focusable ? o(e).onItemFocus(n.value) : d.preventDefault();\n          }),\n          onFocus: u[1] || (u[1] = (d) => o(e).onItemFocus(n.value)),\n          onKeydown: r\n        }, {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [lo, yd] = Q(\"MenuContent\"), so = /* @__PURE__ */ w({\n  __name: \"MenuContentImpl\",\n  props: /* @__PURE__ */ cl({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Gl\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Rt(), s = wa(), { trapFocus: r, disableOutsidePointerEvents: i, loop: u } = ne(e);\n    Gn(), ha(i.value);\n    const d = I(\"\"), c = I(0), p = I(0), f = I(null), v = I(\"right\"), g = I(0), m = I(null), { createCollection: S } = Me(), { forwardRef: x, currentElement: D } = T(), h = S(D);\n    te(D, (A) => {\n      l.onContentChange(A);\n    });\n    const { handleTypeaheadSearch: E } = ga(h);\n    Ie(() => {\n      window.clearTimeout(c.value);\n    });\n    function P(A) {\n      var U, H;\n      return v.value === ((U = f.value) == null ? void 0 : U.side) && iu(A, (H = f.value) == null ? void 0 : H.area);\n    }\n    async function $(A) {\n      var L;\n      n(\"openAutoFocus\", A), !A.defaultPrevented && (A.preventDefault(), (L = D.value) == null || L.focus({\n        preventScroll: !0\n      }));\n    }\n    function R(A) {\n      if (A.defaultPrevented)\n        return;\n      const U = A.target.closest(\"[data-radix-menu-content]\") === A.currentTarget, H = A.ctrlKey || A.altKey || A.metaKey, J = A.key.length === 1, N = $t(\n        A,\n        document.activeElement,\n        D.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: s == null ? void 0 : s.dir.value,\n          focus: !0,\n          attributeName: \"[data-radix-vue-collection-item]:not([data-disabled])\"\n        }\n      );\n      if (N)\n        return N == null ? void 0 : N.focus();\n      if (A.code === \"Space\" || (U && (A.key === \"Tab\" && A.preventDefault(), !H && J && E(A.key)), A.target !== D.value) || !ou.includes(A.key))\n        return;\n      A.preventDefault();\n      const F = h.value;\n      Nl.includes(A.key) && F.reverse(), $n(F);\n    }\n    function M(A) {\n      var L, U;\n      (U = (L = A == null ? void 0 : A.currentTarget) == null ? void 0 : L.contains) != null && U.call(L, A.target) || (window.clearTimeout(c.value), d.value = \"\");\n    }\n    function V(A) {\n      var H;\n      if (!ua(A))\n        return;\n      const L = A.target, U = g.value !== A.clientX;\n      if ((H = A == null ? void 0 : A.currentTarget) != null && H.contains(L) && U) {\n        const J = A.clientX > g.value ? \"right\" : \"left\";\n        v.value = J, g.value = A.clientX;\n      }\n    }\n    return yd({\n      onItemEnter: (A) => !!P(A),\n      onItemLeave: (A) => {\n        var L;\n        P(A) || ((L = D.value) == null || L.focus(), m.value = null);\n      },\n      onTriggerLeave: (A) => !!P(A),\n      searchRef: d,\n      pointerGraceTimerRef: p,\n      onPointerGraceIntentChange: (A) => {\n        f.value = A;\n      }\n    }), (A, L) => (b(), _(o(Ya), {\n      \"as-child\": \"\",\n      trapped: o(r),\n      onMountAutoFocus: $,\n      onUnmountAutoFocus: L[7] || (L[7] = (U) => n(\"closeAutoFocus\", U))\n    }, {\n      default: y(() => [\n        Y(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": o(i),\n          onEscapeKeyDown: L[2] || (L[2] = (U) => n(\"escapeKeyDown\", U)),\n          onPointerDownOutside: L[3] || (L[3] = (U) => n(\"pointerDownOutside\", U)),\n          onFocusOutside: L[4] || (L[4] = (U) => n(\"focusOutside\", U)),\n          onInteractOutside: L[5] || (L[5] = (U) => n(\"interactOutside\", U)),\n          onDismiss: L[6] || (L[6] = (U) => n(\"dismiss\"))\n        }, {\n          default: y(() => [\n            Y(o(At), {\n              \"current-tab-stop-id\": m.value,\n              \"onUpdate:currentTabStopId\": L[0] || (L[0] = (U) => m.value = U),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: o(s).dir.value,\n              loop: o(u),\n              onEntryFocus: L[1] || (L[1] = (U) => {\n                n(\"entryFocus\", U), o(s).isUsingKeyboardRef.value || U.preventDefault();\n              })\n            }, {\n              default: y(() => [\n                Y(o(Pt), {\n                  ref: o(x),\n                  role: \"menu\",\n                  as: A.as,\n                  \"as-child\": A.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": o(Qn)(o(l).open.value),\n                  dir: o(s).dir.value,\n                  side: A.side,\n                  \"side-offset\": A.sideOffset,\n                  align: A.align,\n                  \"align-offset\": A.alignOffset,\n                  \"avoid-collisions\": A.avoidCollisions,\n                  \"collision-boundary\": A.collisionBoundary,\n                  \"collision-padding\": A.collisionPadding,\n                  \"arrow-padding\": A.arrowPadding,\n                  \"prioritize-position\": A.prioritizePosition,\n                  sticky: A.sticky,\n                  \"hide-when-detached\": A.hideWhenDetached,\n                  onKeydown: R,\n                  onBlur: M,\n                  onPointermove: V\n                }, {\n                  default: y(() => [\n                    C(A.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"prioritize-position\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Jl = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = lo(), { forwardRef: n } = T(), l = I(!1);\n    async function s(i) {\n      if (!i.defaultPrevented && ua(i)) {\n        if (t.disabled)\n          e.onItemLeave(i);\n        else if (!e.onItemEnter(i)) {\n          const d = i.currentTarget;\n          d == null || d.focus({ preventScroll: !0 });\n        }\n      }\n    }\n    async function r(i) {\n      await le(), !i.defaultPrevented && ua(i) && e.onItemLeave(i);\n    }\n    return (i, u) => (b(), _(o(Xt), null, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(n),\n          role: \"menuitem\",\n          tabindex: \"-1\"\n        }, i.$attrs, {\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"data-radix-vue-collection-item\": \"\",\n          \"aria-disabled\": i.disabled || void 0,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-highlighted\": l.value ? \"\" : void 0,\n          onPointermove: s,\n          onPointerleave: r,\n          onFocus: u[0] || (u[0] = async (d) => {\n            await le(), !(d.defaultPrevented || i.disabled) && (l.value = !0);\n          }),\n          onBlur: u[1] || (u[1] = async (d) => {\n            await le(), !d.defaultPrevented && (l.value = !1);\n          })\n        }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"data-highlighted\"])\n      ]),\n      _: 3\n    }));\n  }\n}), _a = /* @__PURE__ */ w({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), r = wa(), i = lo(), u = I(!1);\n    async function d() {\n      const c = s.value;\n      if (!e.disabled && c) {\n        const p = new CustomEvent(au, {\n          bubbles: !0,\n          cancelable: !0\n        });\n        n(\"select\", p), await le(), p.defaultPrevented ? u.value = !1 : r.onClose();\n      }\n    }\n    return (c, p) => (b(), _(Jl, k(e, {\n      ref: o(l),\n      onClick: d,\n      onPointerdown: p[0] || (p[0] = () => {\n        u.value = !0;\n      }),\n      onPointerup: p[1] || (p[1] = async (f) => {\n        var v;\n        await le(), !f.defaultPrevented && (u.value || (v = f.currentTarget) == null || v.click());\n      }),\n      onKeydown: p[2] || (p[2] = async (f) => {\n        const v = o(i).searchRef.value !== \"\";\n        c.disabled || v && f.key === \" \" || o(Dn).includes(f.key) && (f.currentTarget.click(), f.preventDefault());\n      })\n    }), {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [gd, Ql] = Q(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), ro = /* @__PURE__ */ w({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = gd({\n      checked: I(!1)\n    });\n    return (e, n) => (b(), _(o(Pe), {\n      present: e.forceMount || o(Fa)(o(t).checked.value) || o(t).checked.value === !0\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": o(eo)(o(t).checked.value)\n        }, {\n          default: y(() => [\n            C(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), io = /* @__PURE__ */ w({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: !1 },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ae(e, \"checked\", n);\n    return Ql({ checked: l }), (s, r) => (b(), _(_a, k({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": o(Fa)(o(l)) ? \"mixed\" : o(l),\n      \"data-state\": o(eo)(o(l)),\n      onSelect: r[0] || (r[0] = async (i) => {\n        n(\"select\", i), o(Fa)(o(l)) ? l.value = !0 : l.value = !o(l);\n      })\n    }), {\n      default: y(() => [\n        C(s.$slots, \"default\", { checked: o(l) })\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), bd = /* @__PURE__ */ w({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = xe(e, n), s = Rt(), { forwardRef: r, currentElement: i } = T();\n    return ya(i), (u, d) => (b(), _(so, k(o(l), {\n      ref: o(r),\n      \"trap-focus\": o(s).open.value,\n      \"disable-outside-pointer-events\": o(s).open.value,\n      \"disable-outside-scroll\": !0,\n      onDismiss: d[0] || (d[0] = (c) => o(s).onOpenChange(!1)),\n      onFocusOutside: d[1] || (d[1] = ie((c) => n(\"focusOutside\", c), [\"prevent\"]))\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Cd = /* @__PURE__ */ w({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = Rt();\n    return (r, i) => (b(), _(so, k(o(l), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      \"disable-outside-scroll\": !1,\n      onDismiss: i[0] || (i[0] = (u) => o(s).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uo = /* @__PURE__ */ w({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = Rt(), r = wa();\n    return (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        o(r).modal.value ? (b(), _(bd, K(k({ key: 0 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), _(Cd, K(k({ key: 1 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Qa = /* @__PURE__ */ w({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), k({ role: \"group\" }, t), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), co = /* @__PURE__ */ w({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), po = /* @__PURE__ */ w({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [wd, _d] = Q(\"MenuRadioGroup\"), fo = /* @__PURE__ */ w({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"modelValue\", t);\n    return _d({\n      modelValue: l,\n      onValueChange: (s) => {\n        l.value = s;\n      }\n    }), (s, r) => (b(), _(Qa, K(j(e)), {\n      default: y(() => [\n        C(s.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vo = /* @__PURE__ */ w({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { value: l } = ne(e), s = wd(), r = B(\n      () => s.modelValue.value === (l == null ? void 0 : l.value)\n    );\n    return Ql({ checked: r }), (i, u) => (b(), _(_a, k({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": r.value,\n      \"data-state\": o(eo)(r.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        n(\"select\", d), o(s).onValueChange(o(l));\n      })\n    }), {\n      default: y(() => [\n        C(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), mo = /* @__PURE__ */ w({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), k(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [es, xd] = Q(\"MenuSub\"), ho = /* @__PURE__ */ w({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"open\", t, {\n      defaultValue: !1,\n      passive: e.open === void 0\n    }), s = Rt(), r = I(), i = I();\n    return ye((u) => {\n      (s == null ? void 0 : s.open.value) === !1 && (l.value = !1), u(() => l.value = !1);\n    }), Yl({\n      open: l,\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      content: i,\n      onContentChange: (u) => {\n        i.value = u;\n      }\n    }), xd({\n      triggerId: \"\",\n      contentId: \"\",\n      trigger: r,\n      onTriggerChange: (u) => {\n        r.value = u;\n      }\n    }), (u, d) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), yo = /* @__PURE__ */ w({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = Rt(), r = wa(), i = es(), { forwardRef: u, currentElement: d } = T();\n    return i.contentId || (i.contentId = me(void 0, \"radix-vue-menu-sub-content\")), (c, p) => (b(), _(o(Pe), {\n      present: c.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        Y(so, k(o(l), {\n          id: o(i).contentId,\n          ref: o(u),\n          \"aria-labelledby\": o(i).triggerId,\n          align: \"start\",\n          side: o(r).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": !1,\n          \"disable-outside-scroll\": !1,\n          \"trap-focus\": !1,\n          onOpenAutoFocus: p[0] || (p[0] = ie((f) => {\n            var v;\n            o(r).isUsingKeyboardRef.value && ((v = o(d)) == null || v.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: p[1] || (p[1] = ie(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: p[2] || (p[2] = (f) => {\n            f.defaultPrevented || f.target !== o(i).trigger.value && o(s).onOpenChange(!1);\n          }),\n          onEscapeKeyDown: p[3] || (p[3] = (f) => {\n            o(r).onClose(), f.preventDefault();\n          }),\n          onKeydown: p[4] || (p[4] = (f) => {\n            var m, S;\n            const v = (m = f.currentTarget) == null ? void 0 : m.contains(f.target), g = o(su)[o(r).dir.value].includes(f.key);\n            v && g && (o(s).onOpenChange(!1), (S = o(i).trigger.value) == null || S.focus(), f.preventDefault());\n          })\n        }), {\n          default: y(() => [\n            C(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), go = /* @__PURE__ */ w({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Rt(), n = wa(), l = es(), s = lo(), r = I(null);\n    l.triggerId || (l.triggerId = me(void 0, \"radix-vue-menu-sub-trigger\"));\n    function i() {\n      r.value && window.clearTimeout(r.value), r.value = null;\n    }\n    Ie(() => {\n      i();\n    });\n    function u(p) {\n      !ua(p) || s.onItemEnter(p) || !t.disabled && !e.open.value && !r.value && (s.onPointerGraceIntentChange(null), r.value = window.setTimeout(() => {\n        e.onOpenChange(!0), i();\n      }, 100));\n    }\n    async function d(p) {\n      var v, g;\n      if (!ua(p))\n        return;\n      i();\n      const f = (v = e.content.value) == null ? void 0 : v.getBoundingClientRect();\n      if (f != null && f.width) {\n        const m = (g = e.content.value) == null ? void 0 : g.dataset.side, S = m === \"right\", x = S ? -5 : 5, D = f[S ? \"left\" : \"right\"], h = f[S ? \"right\" : \"left\"];\n        s.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: p.clientX + x, y: p.clientY },\n            { x: D, y: f.top },\n            { x: h, y: f.top },\n            { x: h, y: f.bottom },\n            { x: D, y: f.bottom }\n          ],\n          side: m\n        }), window.clearTimeout(s.pointerGraceTimerRef.value), s.pointerGraceTimerRef.value = window.setTimeout(\n          () => s.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (s.onTriggerLeave(p))\n          return;\n        s.onPointerGraceIntentChange(null);\n      }\n    }\n    async function c(p) {\n      var v;\n      const f = s.searchRef.value !== \"\";\n      t.disabled || f && p.key === \" \" || lu[n.dir.value].includes(p.key) && (e.onOpenChange(!0), await le(), (v = e.content.value) == null || v.focus(), p.preventDefault());\n    }\n    return (p, f) => (b(), _(Za, { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(Jl, k(t, {\n          id: o(l).triggerId,\n          ref: (v) => {\n            var g;\n            (g = o(l)) == null || g.onTriggerChange(v == null ? void 0 : v.$el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(l).contentId,\n          \"data-state\": o(Qn)(o(e).open.value),\n          onClick: f[0] || (f[0] = async (v) => {\n            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), o(e).open.value || o(e).onOpenChange(!0));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: c\n        }), {\n          default: y(() => [\n            C(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [ts, Sd] = Q(\"ContextMenuRoot\"), Gv = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, modal: s } = ne(e);\n    T();\n    const r = be(l), i = I(!1);\n    return Sd({\n      open: i,\n      onOpenChange: (u) => {\n        i.value = u;\n      },\n      dir: r,\n      modal: s\n    }), te(i, (u) => {\n      n(\"update:open\", u);\n    }), (u, d) => (b(), _(o(oo), {\n      open: i.value,\n      \"onUpdate:open\": d[0] || (d[0] = (c) => i.value = c),\n      dir: o(r),\n      modal: o(s)\n    }, {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction Uo(a) {\n  return a.pointerType !== \"mouse\";\n}\nconst qv = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ne(t), { forwardRef: n } = T(), l = ts(), s = I({ x: 0, y: 0 }), r = B(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: s.value.x,\n        right: s.value.x,\n        top: s.value.y,\n        bottom: s.value.y,\n        ...s.value\n      })\n    })), i = I(0);\n    function u() {\n      window.clearTimeout(i.value);\n    }\n    function d(v) {\n      s.value = { x: v.clientX, y: v.clientY }, l.onOpenChange(!0);\n    }\n    async function c(v) {\n      e.value || (await le(), v.defaultPrevented || (u(), d(v), v.preventDefault()));\n    }\n    async function p(v) {\n      e.value || (await le(), Uo(v) && !v.defaultPrevented && (u(), i.value = window.setTimeout(() => d(v), 700)));\n    }\n    async function f(v) {\n      e.value || (await le(), Uo(v) && !v.defaultPrevented && u());\n    }\n    return (v, g) => (b(), ce(_e, null, [\n      Y(o(Za), {\n        as: \"template\",\n        element: r.value\n      }, null, 8, [\"element\"]),\n      Y(o(O), k({\n        ref: o(n),\n        as: v.as,\n        \"as-child\": v.asChild,\n        \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": o(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, v.$attrs, {\n        onContextmenu: c,\n        onPointerdown: p,\n        onPointermove: f,\n        onPointercancel: f,\n        onPointerup: f\n      }), {\n        default: y(() => [\n          C(v.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), Yv = /* @__PURE__ */ w({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(po), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xv = /* @__PURE__ */ w({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    T();\n    const s = ts(), r = I(!1);\n    return (i, u) => (b(), _(o(uo), k(o(l), {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: u[0] || (u[0] = (d) => {\n        !d.defaultPrevented && r.value && d.preventDefault(), r.value = !1;\n      }),\n      onInteractOutside: u[1] || (u[1] = (d) => {\n        !d.defaultPrevented && !o(s).modal.value && (r.value = !0);\n      })\n    }), {\n      default: y(() => [\n        C(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zv = /* @__PURE__ */ w({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(no), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jv = /* @__PURE__ */ w({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(_a), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qv = /* @__PURE__ */ w({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(Qa), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), em = /* @__PURE__ */ w({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(mo), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), tm = /* @__PURE__ */ w({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(io), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), am = /* @__PURE__ */ w({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(ro), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nm = /* @__PURE__ */ w({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(co), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), om = /* @__PURE__ */ w({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(fo), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lm = /* @__PURE__ */ w({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(vo), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sm = /* @__PURE__ */ w({\n  __name: \"ContextMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), _(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), rm = /* @__PURE__ */ w({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return T(), (s, r) => (b(), _(o(yo), k(o(l), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), im = /* @__PURE__ */ w({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(go), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ed = [\"hour\", \"minute\", \"second\"];\nfunction Ft(a) {\n  const { formatter: t } = a, e = Kn.map((n) => [n, a.value[n]]);\n  if (\"hour\" in a.value) {\n    const n = yl.map((s) => s === \"dayPeriod\" ? [s, t.dayPeriod(Le(a.value))] : [s, a.value[s]]), l = [...e, ...n];\n    return Object.fromEntries(l);\n  }\n  return Object.fromEntries(e);\n}\nfunction as(a) {\n  const t = gl.map((e) => e === \"dayPeriod\" ? [e, \"AM\"] : [e, null]).filter(([e]) => e === \"literal\" || e === null ? !1 : a === \"day\" ? !Ed.includes(e) : !0);\n  return Object.fromEntries(t);\n}\nfunction Pd(a) {\n  const { segmentValues: t, formatter: e, locale: n } = a;\n  function l(r) {\n    if (\"hour\" in t) {\n      const i = t[r];\n      return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : e.part(a.dateRef.set({ [r]: i }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : yn(r, \"\", n.value);\n    } else {\n      if (Wr(r)) {\n        const i = t[r];\n        return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r) : e.part(a.dateRef.set({ [r]: i }), r) : yn(r, \"\", n.value);\n      }\n      return \"\";\n    }\n  }\n  return Object.keys(t).reduce((r, i) => {\n    if (!bl(i))\n      return r;\n    if (\"hour\" in t && i === \"dayPeriod\") {\n      const u = t[i];\n      u !== null ? r[i] = u : r[i] = yn(i, \"AM\", n.value);\n    } else\n      r[i] = l(i);\n    return r;\n  }, {});\n}\nfunction Dd(a) {\n  const { granularity: t, formatter: e, contentObj: n, hideTimeZone: l, hourCycle: s } = a;\n  return e.toParts(a.dateRef, jr(t, s)).map((u) => [\"literal\", \"timeZoneName\", null].includes(u.type) || !bl(u.type) ? {\n    part: u.type,\n    value: u.value\n  } : {\n    part: u.type,\n    value: n[u.type]\n  }).filter((u) => !(u.part === null || u.value === null || u.part === \"timeZoneName\" && (!ml(a.dateRef) || l)));\n}\nfunction In(a) {\n  const t = Pd(a), e = Dd({\n    contentObj: t,\n    ...a\n  });\n  return {\n    obj: t,\n    arr: e\n  };\n}\nfunction qe(a) {\n  const t = et();\n  return a === t.ARROW_RIGHT || a === t.ARROW_LEFT;\n}\nfunction _t(a) {\n  return !Number.isNaN(Number.parseInt(a));\n}\nfunction st(a) {\n  const t = et();\n  return !!([\n    t.ENTER,\n    t.ARROW_UP,\n    t.ARROW_DOWN,\n    t.ARROW_LEFT,\n    t.ARROW_RIGHT,\n    t.BACKSPACE,\n    t.SPACE,\n    \"a\",\n    \"A\",\n    \"p\",\n    \"P\"\n  ].includes(a) || _t(a));\n}\nfunction Na(a) {\n  return Array.from(a.querySelectorAll(\"[data-radix-vue-date-field-segment]\")).filter((t) => t.getAttribute(\"data-radix-vue-date-field-segment\") !== \"literal\");\n}\nconst $d = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Bd, Id] = Q(\"DateFieldRoot\"), Td = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"DateFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, granularity: d, defaultValue: c, dir: p } = ne(n), f = Un(n.locale), v = be(p), { primitiveElement: g, currentElement: m } = Ae(), S = I(/* @__PURE__ */ new Set());\n    se(() => {\n      Na(m.value).forEach((z) => S.value.add(z));\n    });\n    const x = ae(n, \"modelValue\", l, {\n      defaultValue: c.value,\n      passive: n.modelValue === void 0\n    }), D = jt({\n      defaultPlaceholder: n.placeholder,\n      granularity: d.value,\n      defaultValue: x.value\n    }), h = ae(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? D.copy(),\n      passive: n.placeholder === void 0\n    }), E = B(() => n.granularity ? ra(h.value) ? n.granularity : \"day\" : ra(h.value) ? \"minute\" : \"day\"), P = B(() => {\n      var z;\n      return x.value ? !!((z = u.value) != null && z.call(u, x.value) || n.minValue && ke(x.value, n.minValue) || n.maxValue && ke(n.maxValue, x.value)) : !1;\n    }), $ = as(E.value), R = I(x.value ? { ...Ft({ value: x.value, formatter: f }) } : { ...$ }), M = B(() => In({\n      granularity: E.value,\n      dateRef: h.value,\n      formatter: f,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: R.value,\n      locale: s\n    })), V = B(() => M.value.arr), A = B(() => V.value.filter(({ part: z }) => z !== \"literal\"));\n    te(s, (z) => {\n      f.getLocale() !== z && (f.setLocale(z), le(() => {\n        S.value.clear(), Na(m.value).forEach((X) => S.value.add(X));\n      }));\n    }), te(x, (z) => {\n      z !== void 0 && (!Ee(h.value, z) || h.value.compare(z) !== 0) && (h.value = z.copy());\n    }), te([x, s], ([z]) => {\n      z !== void 0 ? R.value = { ...Ft({ value: z, formatter: f }) } : R.value = { ...$ };\n    });\n    const L = I(null), U = B(() => Array.from(S.value).findIndex((z) => {\n      var X;\n      return z.getAttribute(\"data-radix-vue-date-field-segment\") === ((X = L.value) == null ? void 0 : X.getAttribute(\"data-radix-vue-date-field-segment\"));\n    })), H = B(() => {\n      const z = v.value === \"rtl\" ? -1 : 1;\n      return (z < 0 ? U.value < 0 : U.value > S.value.size - 1) ? null : Array.from(S.value)[U.value + z];\n    }), J = B(() => {\n      const z = v.value === \"rtl\" ? -1 : 1;\n      return (z > 0 ? U.value < 0 : U.value > S.value.size - 1) ? null : Array.from(S.value)[U.value - z];\n    }), N = et();\n    function F(z) {\n      var X, G;\n      qe(z.key) && (z.key === N.ARROW_LEFT && ((X = J.value) == null || X.focus()), z.key === N.ARROW_RIGHT && ((G = H.value) == null || G.focus()));\n    }\n    function W(z) {\n      L.value = z;\n    }\n    return Id({\n      isDateUnavailable: u.value,\n      locale: s,\n      modelValue: x,\n      placeholder: h,\n      disabled: r,\n      formatter: f,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: R,\n      isInvalid: P,\n      segmentContents: A,\n      elements: S,\n      setFocusedElement: W,\n      focusNext() {\n        var z;\n        (z = H.value) == null || z.focus();\n      }\n    }), t({\n      /** Helper to set the focused element inside the DateField */\n      setFocusedElement: W\n    }), (z, X) => (b(), ce(_e, null, [\n      Y(o(O), k(z.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: g,\n        role: \"group\",\n        \"aria-disabled\": o(r) ? !0 : void 0,\n        \"data-disabled\": o(r) ? \"\" : void 0,\n        \"data-readonly\": o(i) ? \"\" : void 0,\n        \"data-invalid\": P.value ? \"\" : void 0,\n        dir: o(v),\n        onKeydown: re(F, [\"left\", \"right\"])\n      }), {\n        default: y(() => [\n          C(z.$slots, \"default\", {\n            modelValue: o(x),\n            segments: V.value,\n            isInvalid: P.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n      Ue(\"input\", {\n        id: z.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: o(x) ? o(x).toString() : \"\",\n        name: z.name,\n        disabled: o(r),\n        required: z.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: X[0] || (X[0] = (G) => {\n          var Z, ee;\n          return (ee = (Z = Array.from(S.value)) == null ? void 0 : Z[0]) == null ? void 0 : ee.focus();\n        })\n      }, null, 40, $d)\n    ], 64));\n  }\n});\nfunction kt(a) {\n  return {\n    role: \"spinbutton\",\n    contenteditable: !0,\n    tabindex: a.disabled ? void 0 : 0,\n    spellcheck: !1,\n    inputmode: \"numeric\",\n    autocorrect: \"off\",\n    enterkeyhint: \"next\",\n    style: \"caret-color: transparent;\"\n  };\n}\nfunction Rd(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.day === null, l = t.day ? e.set({ day: t.day }) : e, s = l.day, r = 1, i = Et(l), u = n ? \"Empty\" : `${s}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"day,\",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Ad(a) {\n  const { segmentValues: t, placeholder: e, formatter: n } = a, l = t.month === null, s = t.month ? e.set({ month: t.month }) : e, r = s.month, i = 1, u = 12, d = l ? \"Empty\" : `${r} - ${n.fullMonth(Le(s))}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"month, \",\n    contenteditable: !0,\n    \"aria-valuemin\": i,\n    \"aria-valuemax\": u,\n    \"aria-valuenow\": r,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction Od(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.year === null, l = t.year ? e.set({ year: t.year }) : e, s = 1, r = 9999, i = l.year, u = n ? \"Empty\" : `${i}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"year, \",\n    \"aria-valuemin\": s,\n    \"aria-valuemax\": r,\n    \"aria-valuenow\": i,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction kd(a) {\n  const { segmentValues: t, hourCycle: e, placeholder: n } = a;\n  if (!(\"hour\" in t) || !(\"hour\" in n))\n    return {};\n  const l = t.hour === null, s = t.hour ? n.set({ hour: t.hour }) : n, r = e === 12 ? 1 : 0, i = e === 12 ? 12 : 23, u = s.hour, d = l ? \"Empty\" : `${u} ${t.dayPeriod ?? \"\"}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"hour, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": u,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction Md(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"minute\" in t) || !(\"minute\" in e))\n    return {};\n  const n = t.minute === null, s = (t.minute ? e.set({ minute: t.minute }) : e).minute, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"minute, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Vd(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"second\" in t) || !(\"second\" in e))\n    return {};\n  const n = t.second === null, s = (t.second ? e.set({ second: t.second }) : e).second, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...kt(a),\n    \"aria-label\": \"second, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Fd(a) {\n  const { segmentValues: t } = a;\n  if (!(\"dayPeriod\" in t))\n    return {};\n  const e = 0, n = 12, l = t.hour ? t.hour > 12 ? t.hour - 12 : t.hour : 0, s = t.dayPeriod ?? \"AM\";\n  return {\n    ...kt(a),\n    inputmode: \"text\",\n    \"aria-label\": \"AM/PM\",\n    \"aria-valuemin\": e,\n    \"aria-valuemax\": n,\n    \"aria-valuenow\": l,\n    \"aria-valuetext\": s\n  };\n}\nfunction Ld(a) {\n  return {\n    \"aria-hidden\": !0,\n    \"data-segment\": \"literal\"\n  };\n}\nfunction Nd(a) {\n  return {\n    role: \"textbox\",\n    \"aria-label\": \"timezone, \",\n    \"data-readonly\": !0,\n    \"data-segment\": \"timeZoneName\",\n    tabindex: a.disabled ? void 0 : 0,\n    style: \"caret-color: transparent;\"\n  };\n}\nconst zd = {\n  day: {\n    attrs: Rd\n  },\n  month: {\n    attrs: Ad\n  },\n  year: {\n    attrs: Od\n  },\n  hour: {\n    attrs: kd\n  },\n  minute: {\n    attrs: Md\n  },\n  second: {\n    attrs: Vd\n  },\n  dayPeriod: {\n    attrs: Fd\n  },\n  literal: {\n    attrs: Ld\n  },\n  timeZoneName: {\n    attrs: Nd\n  }\n};\nfunction ns(a) {\n  const t = et();\n  function e({ e: h, part: E, dateRef: P, prevValue: $ }) {\n    const R = h.key === t.ARROW_UP ? 1 : -1, M = 0, V = 59;\n    if ($ === null)\n      return R > 0 ? M : V;\n    const A = [E, R];\n    return P.set({ [E]: $ }).cycle(...A)[E];\n  }\n  function n(h) {\n    if (a.hasLeftFocus.value = !1, h === null)\n      return h;\n    const E = h.toString();\n    return E.length === 1 ? null : Number.parseInt(E.slice(0, -1));\n  }\n  function l({ e: h, part: E, dateRef: P, prevValue: $, hourCycle: R }) {\n    const M = h.key === t.ARROW_UP ? 1 : -1;\n    if ($ === null)\n      return P[E];\n    if (E === \"hour\" && \"hour\" in P) {\n      const A = [E, M, { hourCycle: R }];\n      return P.set({ [E]: $ }).cycle(...A)[E];\n    }\n    const V = [E, M];\n    return E === \"day\" && a.segmentValues.value.month !== null ? P.set({ [E]: $, month: a.segmentValues.value.month }).cycle(...V)[E] : P.set({ [E]: $ }).cycle(...V)[E];\n  }\n  function s(h, E, P) {\n    let $ = !1;\n    const R = Math.floor(h / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, P = null), P === null)\n      return E === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: $ }) : ((a.lastKeyZero.value || E > R) && ($ = !0), a.lastKeyZero.value = !1, { value: E, moveToNext: $ });\n    const M = P.toString().length, V = Number.parseInt(P.toString() + E.toString());\n    return M === 2 || V > h ? ((E > R || V > h) && ($ = !0), { value: E, moveToNext: $ }) : ($ = !0, { value: V, moveToNext: $ });\n  }\n  function r(h, E) {\n    let $ = !1;\n    const R = Math.floor(59 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: $ }) : ((a.lastKeyZero.value || h > R) && ($ = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: $ });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 59 ? (h > R && ($ = !0), { value: h, moveToNext: $ }) : ($ = !0, { value: V, moveToNext: $ });\n  }\n  function i(h, E) {\n    let $ = !1;\n    const R = Math.floor(24 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: $ }) : ((a.lastKeyZero.value || h > R) && ($ = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: $ });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 24 ? (h > R && ($ = !0), { value: h, moveToNext: $ }) : ($ = !0, { value: V, moveToNext: $ });\n  }\n  function u(h, E) {\n    let P = !1;\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return { value: h === 0 ? 1 : h, moveToNext: P };\n    const $ = E.toString() + h.toString();\n    return $.length > 4 ? { value: h === 0 ? 1 : h, moveToNext: P } : ($.length === 4 && (P = !0), { value: Number.parseInt($), moveToNext: P });\n  }\n  const d = B(() => zd[a.part].attrs({\n    disabled: a.disabled.value,\n    placeholder: a.placeholder.value,\n    hourCycle: a.hourCycle,\n    segmentValues: a.segmentValues.value,\n    formatter: a.formatter\n  }));\n  function c(h) {\n    if (!st(h.key) || qe(h.key))\n      return;\n    const E = a.segmentValues.value.day;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.day = l({ e: h, part: \"day\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (_t(h.key)) {\n      const P = Number.parseInt(h.key), $ = a.segmentValues.value.month, R = $ ? Et(a.placeholder.value.set({ month: $ })) : Et(a.placeholder.value), { value: M, moveToNext: V } = s(R, P, E);\n      a.segmentValues.value.day = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.day = n(E));\n  }\n  function p(h) {\n    if (!st(h.key) || qe(h.key))\n      return;\n    const E = a.segmentValues.value.month;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.month = l({ e: h, part: \"month\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (_t(h.key)) {\n      const P = Number.parseInt(h.key), { value: $, moveToNext: R } = s(12, P, E);\n      a.segmentValues.value.month = $, R && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.month = n(E));\n  }\n  function f(h) {\n    if (!st(h.key) || qe(h.key))\n      return;\n    const E = a.segmentValues.value.year;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.year = l({ e: h, part: \"year\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (_t(h.key)) {\n      const P = Number.parseInt(h.key), { value: $, moveToNext: R } = u(P, E);\n      a.segmentValues.value.year = $, R && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.year = n(E));\n  }\n  function v(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || qe(h.key) || !(\"hour\" in E) || !(\"hour\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.hour, $ = a.hourCycle;\n    if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n      a.segmentValues.value.hour = l({ e: h, part: \"hour\", dateRef: a.placeholder.value, prevValue: P, hourCycle: $ }), \"dayPeriod\" in a.segmentValues.value && (a.segmentValues.value.hour < 12 ? a.segmentValues.value.dayPeriod = \"AM\" : a.segmentValues.value.hour && (a.segmentValues.value.dayPeriod = \"PM\"));\n      return;\n    }\n    if (_t(h.key)) {\n      const R = Number.parseInt(h.key), { value: M, moveToNext: V } = i(R, P);\n      \"dayPeriod\" in a.segmentValues.value && M && M > 12 ? a.segmentValues.value.dayPeriod = \"PM\" : \"dayPeriod\" in a.segmentValues.value && M && (a.segmentValues.value.dayPeriod = \"AM\"), a.segmentValues.value.hour = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.hour = n(P));\n  }\n  function g(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || qe(h.key) || !(\"minute\" in E) || !(\"minute\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.minute;\n    if (a.segmentValues.value.minute = e({ e: h, part: \"minute\", dateRef: a.placeholder.value, prevValue: P }), _t(h.key)) {\n      const $ = Number.parseInt(h.key), { value: R, moveToNext: M } = r($, P);\n      a.segmentValues.value.minute = R, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.minute = n(P));\n  }\n  function m(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || qe(h.key) || !(\"second\" in E) || !(\"second\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.second;\n    if (a.segmentValues.value.second = e({ e: h, part: \"second\", dateRef: a.placeholder.value, prevValue: P }), _t(h.key)) {\n      const $ = Number.parseInt(h.key), { value: R, moveToNext: M } = r($, P);\n      a.segmentValues.value.second = R, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.second = n(P));\n  }\n  function S(h) {\n    if (!((!st(h.key) || qe(h.key)) && h.key !== \"a\" && h.key !== \"p\" || !(\"hour\" in a.placeholder.value) || !(\"dayPeriod\" in a.segmentValues.value))) {\n      if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n        if (a.segmentValues.value.dayPeriod === \"AM\") {\n          a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12;\n          return;\n        }\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      if ([\"a\", \"A\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"AM\") {\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      [\"p\", \"P\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"PM\" && (a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12);\n    }\n  }\n  function x(h) {\n    a.disabled.value && h.preventDefault();\n  }\n  function D(h) {\n    const E = a.disabled.value, P = a.readonly.value;\n    if (h.key !== t.TAB && h.preventDefault(), E || P)\n      return;\n    if ({\n      day: c,\n      month: p,\n      year: f,\n      hour: v,\n      minute: g,\n      second: m,\n      dayPeriod: S,\n      timeZoneName: () => {\n      }\n    }[a.part](h), !qe(h.key) && h.key !== t.TAB && h.key !== t.SHIFT && st(h.key) && Object.values(a.segmentValues.value).every((R) => R !== null)) {\n      const R = { ...a.segmentValues.value };\n      let M = a.placeholder.value.copy();\n      Object.keys(R).forEach((V) => {\n        const A = R[V];\n        M = M.set({ [V]: A });\n      }), a.modelValue.value = M.copy();\n    }\n  }\n  return {\n    handleSegmentClick: x,\n    handleSegmentKeydown: D,\n    attributes: d\n  };\n}\nconst Kd = /* @__PURE__ */ w({\n  __name: \"DateFieldInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Bd(), n = I(!0), l = I(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = ns({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues,\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: e.modelValue\n    }), u = B(() => e.disabled.value), d = B(() => e.readonly.value), c = B(() => e.isInvalid.value);\n    return (p, f) => (b(), _(o(O), k({\n      as: p.as,\n      \"as-child\": p.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : p.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": p.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Nn(p.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (v) => {\n        o(e).setFocusedElement(v.target);\n      }\n    } : {})), {\n      default: y(() => [\n        C(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), um = /* @__PURE__ */ w({\n  __name: \"DatePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Ru), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dm = /* @__PURE__ */ w({\n  __name: \"DatePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Au), K(j(t)), {\n      default: y(({ headingValue: l }) => [\n        C(e.$slots, \"default\", { headingValue: l }, () => [\n          ve($e(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cm = /* @__PURE__ */ w({\n  __name: \"DatePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Ou), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pm = /* @__PURE__ */ w({\n  __name: \"DatePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ku), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fm = /* @__PURE__ */ w({\n  __name: \"DatePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Mu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vm = /* @__PURE__ */ w({\n  __name: \"DatePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Vu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mm = /* @__PURE__ */ w({\n  __name: \"DatePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Fu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hm = /* @__PURE__ */ w({\n  __name: \"DatePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Lu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ym = /* @__PURE__ */ w({\n  __name: \"DatePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Nu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gm = /* @__PURE__ */ w({\n  __name: \"DatePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(zu), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bm = /* @__PURE__ */ w({\n  __name: \"DatePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Ku), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Cm = /* @__PURE__ */ w({\n  __name: \"DatePickerInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Kd), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [bo, Hd] = Q(\"DatePickerRoot\"), wm = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"DatePickerRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateDisabled: v,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: S,\n      id: x,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: $,\n      hideTimeZone: R,\n      hourCycle: M,\n      defaultValue: V,\n      dir: A\n    } = ne(e), L = be(A), U = ae(e, \"modelValue\", n, {\n      defaultValue: V.value,\n      passive: e.modelValue === void 0\n    }), H = B(() => jt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: U.value\n    })), J = ae(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? H.value.copy(),\n      passive: e.placeholder === void 0\n    }), N = ae(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), F = I();\n    return Hd({\n      isDateUnavailable: g.value,\n      isDateDisabled: v.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: r,\n      preventDeselect: f,\n      modelValue: U,\n      placeholder: J,\n      defaultOpen: m,\n      modal: S,\n      open: N,\n      id: x,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: $,\n      hideTimeZone: R,\n      hourCycle: M,\n      dateFieldRef: F,\n      dir: L,\n      onDateChange(W) {\n        !W || !U.value ? U.value = W : !f.value && Te(U.value, W) ? U.value = void 0 : U.value = W.copy();\n      },\n      onPlaceholderChange(W) {\n        Ee(W, J.value) || (J.value = W.copy());\n      }\n    }), (W, z) => (b(), _(o(ps), {\n      open: o(N),\n      \"onUpdate:open\": z[0] || (z[0] = (X) => Xe(N) ? N.value = X : null),\n      \"default-open\": o(m),\n      modal: o(S)\n    }, {\n      default: y(() => [\n        C(W.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), _m = /* @__PURE__ */ w({\n  __name: \"DatePickerCalendar\",\n  setup(a) {\n    const t = bo();\n    return (e, n) => (b(), _(o(Tu), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      dir: o(t).dir.value\n    }, {\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"initial-focus\": \"\",\n      multiple: !1,\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && o(Ee)(l, o(t).modelValue.value) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        C(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), xm = /* @__PURE__ */ w({\n  __name: \"DatePickerField\",\n  setup(a) {\n    const t = bo();\n    return (e, n) => (b(), _(o(Td), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && o(Ee)(o(t).modelValue.value, l) && l.compare(o(t).modelValue.value) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(o(t).placeholder.value, l) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        C(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Sm = /* @__PURE__ */ w({\n  __name: \"DatePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(bs), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Em = /* @__PURE__ */ w({\n  __name: \"DatePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ys), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pm = /* @__PURE__ */ w({\n  __name: \"DatePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(gs), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dm = /* @__PURE__ */ w({\n  __name: \"DatePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = bo();\n    return (n, l) => (b(), _(o(fs), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), $m = /* @__PURE__ */ w({\n  __name: \"DatePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return (s, r) => (b(), _(o(vs), null, {\n      default: y(() => [\n        Y(o(hs), K(j({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Bm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ap), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Im = /* @__PURE__ */ w({\n  __name: \"DateRangePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(np), K(j(t)), {\n      default: y(({ headingValue: l }) => [\n        C(e.$slots, \"default\", { headingValue: l }, () => [\n          ve($e(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(op), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(lp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Am = /* @__PURE__ */ w({\n  __name: \"DateRangePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(sp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Om = /* @__PURE__ */ w({\n  __name: \"DateRangePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(rp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), km = /* @__PURE__ */ w({\n  __name: \"DateRangePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ip), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(up), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(dp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(cp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(pp), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(Yd), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Co, Wd] = Q(\"DateRangePickerRoot\"), zm = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"DateRangePickerRoot\",\n  props: {\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateDisabled: v,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: S,\n      id: x,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: $,\n      hideTimeZone: R,\n      hourCycle: M,\n      dir: V\n    } = ne(e), A = be(V), L = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), U = jt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: L.value.start\n    }), H = ae(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    }), J = ae(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), N = I();\n    return Wd({\n      isDateUnavailable: g.value,\n      isDateDisabled: v.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: r,\n      preventDeselect: f,\n      modelValue: L,\n      placeholder: H,\n      defaultOpen: m,\n      modal: S,\n      open: J,\n      id: x,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: $,\n      hideTimeZone: R,\n      hourCycle: M,\n      dateFieldRef: N,\n      dir: A,\n      onStartValueChange(F) {\n        n(\"update:startValue\", F);\n      },\n      onDateChange(F) {\n        var W, z;\n        L.value = { start: (W = F.start) == null ? void 0 : W.copy(), end: (z = F.end) == null ? void 0 : z.copy() };\n      },\n      onPlaceholderChange(F) {\n        H.value = F.copy();\n      }\n    }), (F, W) => (b(), _(o(ps), {\n      open: o(J),\n      \"onUpdate:open\": W[0] || (W[0] = (z) => Xe(J) ? J.value = z : null),\n      \"default-open\": o(m),\n      modal: o(S)\n    }, {\n      default: y(() => [\n        C(F.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), Km = /* @__PURE__ */ w({\n  __name: \"DateRangePickerCalendar\",\n  setup(a) {\n    const t = Co();\n    return (e, n) => (b(), _(o(tp), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      dir: o(t).dir.value\n    }, {\n      \"initial-focus\": \"\",\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"onUpdate:startValue\": n[0] || (n[0] = (l) => {\n        o(t).onStartValueChange(l);\n      }),\n      \"onUpdate:modelValue\": n[1] || (n[1] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && o(Ee)(l.start, o(t).modelValue.value.start) && o(Ee)(l.end, o(t).modelValue.value.end) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[2] || (n[2] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        C(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Hm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerField\",\n  setup(a) {\n    const t = Co();\n    return (e, n) => (b(), _(o(qd), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && l.start.compare(o(t).modelValue.value.start) === 0 && l.end.compare(o(t).modelValue.value.end) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        C(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Wm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(bs), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ys), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Um = /* @__PURE__ */ w({\n  __name: \"DateRangePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(gs), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Co();\n    return (n, l) => (b(), _(o(fs), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), qm = /* @__PURE__ */ w({\n  __name: \"DateRangePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return (s, r) => (b(), _(o(vs), null, {\n      default: y(() => [\n        Y(o(hs), K(j({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), jd = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Ud, Gd] = Q(\"DateRangeFieldRoot\"), qd = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"DateRangeFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    var ee, fe;\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, dir: d } = ne(n), c = Un(n.locale), { primitiveElement: p, currentElement: f } = Ae(), v = I(/* @__PURE__ */ new Set()), g = be(d);\n    se(() => {\n      Na(f.value).forEach((q) => v.value.add(q));\n    });\n    const m = ae(n, \"modelValue\", l, {\n      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },\n      passive: n.modelValue === void 0\n    }), S = jt({\n      defaultPlaceholder: n.placeholder,\n      granularity: n.granularity,\n      defaultValue: m.value.start\n    }), x = ae(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? S.copy(),\n      passive: n.placeholder === void 0\n    }), D = B(() => n.granularity ? ra(x.value) ? n.granularity : \"day\" : ra(x.value) ? \"minute\" : \"day\"), h = B(() => {\n      var q;\n      return m.value.start ? !!((q = u.value) != null && q.call(u, m.value.start) || n.minValue && ke(m.value.start, n.minValue) || n.maxValue && ke(n.maxValue, m.value.start)) : !1;\n    }), E = B(() => {\n      var q;\n      return m.value.end ? !!((q = u.value) != null && q.call(u, m.value.end) || n.minValue && ke(m.value.end, n.minValue) || n.maxValue && ke(n.maxValue, m.value.end)) : !1;\n    }), P = B(() => h.value || E.value ? !0 : !m.value.start || !m.value.end ? !1 : !ke(m.value.start, m.value.end) || u.value !== void 0 && !hl(\n      m.value.start,\n      m.value.end,\n      u.value,\n      void 0\n    )), $ = as(D.value), R = I(m.value.start ? { ...Ft({ value: m.value.start, formatter: c }) } : { ...$ }), M = I(m.value.end ? { ...Ft({ value: m.value.end, formatter: c }) } : { ...$ }), V = B(() => In({\n      granularity: D.value,\n      dateRef: x.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: R.value,\n      locale: s\n    })), A = B(() => In({\n      granularity: D.value,\n      dateRef: x.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: M.value,\n      locale: s\n    })), L = B(() => ({\n      start: V.value.arr,\n      end: A.value.arr\n    })), U = B(() => ({ start: L.value.start.filter(({ part: q }) => q !== \"literal\"), end: L.value.end.filter(({ part: q }) => q !== \"literal\") })), H = I((ee = m.value.start) == null ? void 0 : ee.copy()), J = I((fe = m.value.end) == null ? void 0 : fe.copy());\n    te([H, J], ([q, oe]) => {\n      var Ce, ge;\n      const he = m.value;\n      if (!(he.start && he.end && q && oe && he.start.compare(q) === 0 && he.end.compare(oe) === 0))\n        if (q && oe) {\n          if (((Ce = m.value.start) == null ? void 0 : Ce.compare(q)) === 0 && ((ge = m.value.end) == null ? void 0 : ge.compare(oe)) === 0)\n            return;\n          m.value = { start: q.copy(), end: oe.copy() };\n        } else m.value.start && m.value.end && (m.value = { start: void 0, end: void 0 });\n    }), te(m, (q) => {\n      q.start && q.end && ((!H.value || q.start.compare(H.value) !== 0) && (H.value = q.start.copy()), (!J.value || q.end.compare(J.value) !== 0) && (J.value = q.end.copy()));\n    }), te([H, s], ([q]) => {\n      q !== void 0 ? R.value = { ...Ft({ value: q, formatter: c }) } : R.value = { ...$ };\n    }), te(s, (q) => {\n      c.getLocale() !== q && (c.setLocale(q), le(() => {\n        v.value.clear(), Na(f.value).forEach((oe) => v.value.add(oe));\n      }));\n    }), te(m, (q) => {\n      q.start !== void 0 && (!Ee(x.value, q.start) || x.value.compare(q.start) !== 0) && (x.value = q.start.copy());\n    }), te([J, s], ([q]) => {\n      q !== void 0 ? M.value = { ...Ft({ value: q, formatter: c }) } : M.value = { ...$ };\n    });\n    const N = I(null), F = B(() => Array.from(v.value).findIndex((q) => {\n      var oe, he;\n      return q.getAttribute(\"data-radix-vue-date-field-segment\") === ((oe = N.value) == null ? void 0 : oe.getAttribute(\"data-radix-vue-date-field-segment\")) && q.getAttribute(\"data-radix-vue-date-range-field-segment-type\") === ((he = N.value) == null ? void 0 : he.getAttribute(\"data-radix-vue-date-range-field-segment-type\"));\n    })), W = B(() => {\n      const q = g.value === \"rtl\" ? -1 : 1;\n      return (q < 0 ? F.value < 0 : F.value > v.value.size - 1) ? null : Array.from(v.value)[F.value + q];\n    }), z = B(() => {\n      const q = g.value === \"rtl\" ? -1 : 1;\n      return (q > 0 ? F.value < 0 : F.value > v.value.size - 1) ? null : Array.from(v.value)[F.value - q];\n    }), X = et();\n    function G(q) {\n      var oe, he;\n      qe(q.key) && (q.key === X.ARROW_LEFT && ((oe = z.value) == null || oe.focus()), q.key === X.ARROW_RIGHT && ((he = W.value) == null || he.focus()));\n    }\n    function Z(q) {\n      N.value = q;\n    }\n    return Gd({\n      isDateUnavailable: u.value,\n      locale: s,\n      startValue: H,\n      endValue: J,\n      placeholder: x,\n      disabled: r,\n      formatter: c,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: { start: R, end: M },\n      isInvalid: P,\n      segmentContents: U,\n      elements: v,\n      setFocusedElement: Z,\n      focusNext() {\n        var q;\n        (q = W.value) == null || q.focus();\n      }\n    }), t({\n      setFocusedElement: Z\n    }), (q, oe) => {\n      var he, Ce;\n      return b(), ce(_e, null, [\n        Y(o(O), k(q.$attrs, {\n          ref_key: \"primitiveElement\",\n          ref: p,\n          role: \"group\",\n          \"aria-disabled\": o(r) ? !0 : void 0,\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"data-readonly\": o(i) ? \"\" : void 0,\n          \"data-invalid\": P.value ? \"\" : void 0,\n          dir: o(g),\n          onKeydown: re(G, [\"left\", \"right\"])\n        }), {\n          default: y(() => [\n            C(q.$slots, \"default\", {\n              modelValue: o(m),\n              segments: L.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n        Ue(\"input\", {\n          id: q.id,\n          type: \"text\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"\",\n          value: `${(he = o(m).start) == null ? void 0 : he.toString()} - ${(Ce = o(m).end) == null ? void 0 : Ce.toString()}`,\n          name: q.name,\n          disabled: o(r),\n          required: q.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          },\n          onFocus: oe[0] || (oe[0] = (ge) => {\n            var De, ue;\n            return (ue = (De = Array.from(v.value)) == null ? void 0 : De[0]) == null ? void 0 : ue.focus();\n          })\n        }, null, 40, jd)\n      ], 64);\n    };\n  }\n}), Yd = /* @__PURE__ */ w({\n  __name: \"DateRangeFieldInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Ud(), n = I(!0), l = I(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = ns({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues[t.type],\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: t.type === \"start\" ? e.startValue : e.endValue\n    }), u = B(() => e.disabled.value), d = B(() => e.readonly.value), c = B(() => e.isInvalid.value);\n    return (p, f) => (b(), _(o(O), k({\n      as: p.as,\n      \"as-child\": p.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : p.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": p.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-radix-vue-date-range-field-segment-type\": p.type,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Nn(p.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (v) => {\n        o(e).setFocusedElement(v.target);\n      }\n    } : {})), {\n      default: y(() => [\n        C(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-radix-vue-date-range-field-segment-type\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), [os, Xd] = Q(\"DropdownMenuRoot\"), Ym = /* @__PURE__ */ w({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = I(), { modal: r, dir: i } = ne(e), u = be(i);\n    return Xd({\n      open: l,\n      onOpenChange: (d) => {\n        l.value = d;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      triggerId: \"\",\n      triggerElement: s,\n      contentId: \"\",\n      modal: r,\n      dir: u\n    }), (d, c) => (b(), _(o(oo), {\n      open: o(l),\n      \"onUpdate:open\": c[0] || (c[0] = (p) => Xe(l) ? l.value = p : null),\n      dir: o(u),\n      modal: o(r)\n    }, {\n      default: y(() => [\n        C(d.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), Xm = /* @__PURE__ */ w({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = os(), { forwardRef: n, currentElement: l } = T();\n    return se(() => {\n      e.triggerElement = l;\n    }), e.triggerId || (e.triggerId = me(void 0, \"radix-vue-dropdown-menu-trigger\")), (s, r) => (b(), _(o(Za), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), {\n          id: o(e).triggerId,\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-disabled\": s.disabled ? \"\" : void 0,\n          disabled: s.disabled,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          onClick: r[0] || (r[0] = async (i) => {\n            var u;\n            !s.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = o(e)) == null || u.onOpenToggle(), await le(), o(e).open.value && i.preventDefault());\n          }),\n          onKeydown: r[1] || (r[1] = re(\n            (i) => {\n              s.disabled || ([\"Enter\", \" \"].includes(i.key) && o(e).onOpenToggle(), i.key === \"ArrowDown\" && o(e).onOpenChange(!0), [\"Enter\", \" \", \"ArrowDown\"].includes(i.key) && i.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Zm = /* @__PURE__ */ w({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(po), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jm = /* @__PURE__ */ w({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    T();\n    const s = os(), r = I(!1);\n    function i(u) {\n      u.defaultPrevented || (r.value || setTimeout(() => {\n        var d;\n        (d = s.triggerElement.value) == null || d.focus();\n      }, 0), r.value = !1, u.preventDefault());\n    }\n    return s.contentId || (s.contentId = me(void 0, \"radix-vue-dropdown-menu-content\")), (u, d) => {\n      var c;\n      return b(), _(o(uo), k(o(l), {\n        id: o(s).contentId,\n        \"aria-labelledby\": (c = o(s)) == null ? void 0 : c.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: i,\n        onInteractOutside: d[0] || (d[0] = (p) => {\n          var m;\n          if (p.defaultPrevented) return;\n          const f = p.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n          (!o(s).modal.value || g) && (r.value = !0), (m = o(s).triggerElement.value) != null && m.contains(p.target) && p.preventDefault();\n        })\n      }), {\n        default: y(() => [\n          C(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\"]);\n    };\n  }\n}), Qm = /* @__PURE__ */ w({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(no), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), eh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(_a), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), th = /* @__PURE__ */ w({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(Qa), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ah = /* @__PURE__ */ w({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(mo), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(io), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), oh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(ro), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(co), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(fo), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return T(), (s, r) => (b(), _(o(vo), K(j(o(l))), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ih = /* @__PURE__ */ w({\n  __name: \"DropdownMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? !1\n    });\n    return T(), (s, r) => (b(), _(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), uh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return T(), (s, r) => (b(), _(o(yo), k(o(l), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dh = /* @__PURE__ */ w({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(go), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zd = [\"value\", \"name\", \"disabled\", \"required\"], [Jt, Jd] = Q(\"EditableRoot\"), ch = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"EditableRoot\",\n  props: {\n    defaultValue: {},\n    modelValue: {},\n    placeholder: { default: \"Enter text...\" },\n    dir: {},\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean },\n    activationMode: { default: \"focus\" },\n    selectOnFocus: { type: Boolean, default: !1 },\n    submitMode: { default: \"blur\" },\n    startWithEditMode: { type: Boolean },\n    maxLength: {},\n    autoResize: { type: Boolean, default: !1 },\n    id: {},\n    name: {},\n    required: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"submit\", \"update:state\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, {\n      id: s,\n      name: r,\n      defaultValue: i,\n      startWithEditMode: u,\n      placeholder: d,\n      maxLength: c,\n      disabled: p,\n      dir: f,\n      submitMode: v,\n      activationMode: g,\n      selectOnFocus: m,\n      readonly: S,\n      autoResize: x,\n      required: D\n    } = ne(n), h = I(), E = be(f), P = I(u.value ?? !1), $ = ae(n, \"modelValue\", l, {\n      defaultValue: i.value ?? \"\",\n      passive: n.modelValue === void 0\n    }), { primitiveElement: R, currentElement: M } = Ae(), V = Qe(M), A = B(() => typeof d.value == \"string\" ? { edit: d.value, preview: d.value } : d.value), L = I($.value);\n    function U() {\n      $.value = L.value, P.value = !1, l(\"update:state\", \"cancel\");\n    }\n    function H() {\n      P.value = !0, l(\"update:state\", \"edit\");\n    }\n    function J() {\n      L.value = $.value, P.value = !1, l(\"update:state\", \"submit\"), l(\"submit\", $.value);\n    }\n    function N() {\n      P.value && (v.value === \"blur\" || v.value === \"both\" ? J() : U());\n    }\n    const F = Fl(() => N(), M), W = Ll(() => N(), M), z = B(() => $.value === \"\");\n    return t({\n      /** Function to submit the value of the editable */\n      submit: J,\n      /** Function to cancel the value of the editable */\n      cancel: U,\n      /** Function to set the editable in edit mode */\n      edit: H\n    }), Jd({\n      id: s,\n      name: r,\n      disabled: p,\n      isEditing: P,\n      maxLength: c,\n      modelValue: $,\n      placeholder: A,\n      edit: H,\n      cancel: U,\n      submit: J,\n      activationMode: g,\n      submitMode: v,\n      selectOnFocus: m,\n      inputRef: h,\n      startWithEditMode: u,\n      isEmpty: z,\n      readonly: S,\n      autoResize: x\n    }), (X, G) => (b(), ce(_e, null, [\n      Y(o(O), k(X.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: R,\n        as: X.as,\n        \"as-child\": X.asChild,\n        dir: o(E),\n        onFocusCapture: o(W).onFocusCapture,\n        onBlurCapture: o(W).onBlurCapture,\n        onPointerdownCapture: o(F).onPointerDownCapture\n      }), {\n        default: y(() => [\n          C(X.$slots, \"default\", {\n            modelValue: o($),\n            isEditing: P.value,\n            isEmpty: z.value,\n            submit: J,\n            cancel: U,\n            edit: H\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"dir\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]),\n      o(V) ? (b(), ce(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: o($),\n        name: o(r),\n        disabled: o(p),\n        required: o(D),\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Zd)) : pe(\"\", !0)\n    ], 64));\n  }\n}), ph = /* @__PURE__ */ w({\n  __name: \"EditableArea\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Jt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      \"data-focus\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-focused\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-empty\": o(e).isEmpty.value ? \"\" : void 0,\n      \"data-readonly\": o(e).readonly.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      style: o(e).autoResize.value ? { display: \"inline-grid\" } : void 0\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"data-focus\", \"data-focused\", \"data-empty\", \"data-readonly\", \"data-disabled\", \"style\"]));\n  }\n}), fh = /* @__PURE__ */ w({\n  __name: \"EditableInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = et(), n = Jt(), l = B(() => n.disabled.value), s = B(() => {\n      var d;\n      return (d = n.placeholder.value) == null ? void 0 : d.edit;\n    }), { primitiveElement: r, currentElement: i } = Ae();\n    se(() => {\n      var d, c;\n      n.inputRef.value = i.value, n.startWithEditMode.value && ((d = n.inputRef.value) == null || d.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((c = n.inputRef.value) == null || c.select()));\n    }), te(n.isEditing, (d) => {\n      d && le(() => {\n        var c, p;\n        (c = n.inputRef.value) == null || c.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((p = n.inputRef.value) == null || p.select());\n      });\n    });\n    function u(d) {\n      (n.submitMode.value === \"enter\" || n.submitMode.value === \"both\") && d.key === e.ENTER && !d.shiftKey && !d.metaKey && n.submit();\n    }\n    return (d, c) => (b(), _(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: r\n    }, t, {\n      value: o(n).modelValue.value,\n      placeholder: s.value,\n      disabled: l.value,\n      \"data-disabled\": l.value ? \"\" : void 0,\n      \"data-readonly\": o(n).readonly.value ? \"\" : void 0,\n      readonly: o(n).readonly.value,\n      \"aria-label\": \"editable input\",\n      hidden: o(n).autoResize.value ? void 0 : !o(n).isEditing.value,\n      style: o(n).autoResize.value ? { all: \"unset\", gridArea: \"1 / 1 / auto / auto\", visibility: o(n).isEditing.value ? void 0 : \"hidden\" } : void 0,\n      onInput: c[0] || (c[0] = (p) => o(n).modelValue.value = p.target.value),\n      onKeydown: [\n        re(u, [\"enter\", \"space\"]),\n        re(o(n).cancel, [\"esc\"])\n      ]\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"value\", \"placeholder\", \"disabled\", \"data-disabled\", \"data-readonly\", \"readonly\", \"hidden\", \"style\", \"onKeydown\"]));\n  }\n}), vh = /* @__PURE__ */ w({\n  __name: \"EditablePreview\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Jt(), n = B(() => {\n      var r;\n      return (r = e.placeholder.value) == null ? void 0 : r.preview;\n    });\n    function l() {\n      e.activationMode.value === \"focus\" && e.edit();\n    }\n    function s() {\n      e.activationMode.value === \"dblclick\" && e.edit();\n    }\n    return (r, i) => (b(), _(o(O), k(t, {\n      tabindex: \"0\",\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      hidden: o(e).autoResize.value ? void 0 : o(e).isEditing.value,\n      style: o(e).autoResize.value ? {\n        whiteSpace: \"pre\",\n        userSelect: \"none\",\n        gridArea: \"1 / 1 / auto / auto\",\n        visibility: o(e).isEditing.value ? \"hidden\" : void 0,\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\"\n      } : void 0,\n      onFocusin: l,\n      onDblclick: s\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\", {}, () => [\n          ve($e(o(e).modelValue.value || n.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"hidden\", \"style\"]));\n  }\n}), mh = /* @__PURE__ */ w({\n  __name: \"EditableSubmitTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Jt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"submit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).submit\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"Submit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), hh = /* @__PURE__ */ w({\n  __name: \"EditableCancelTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Jt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"cancel\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).cancel\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"Cancel\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), yh = /* @__PURE__ */ w({\n  __name: \"EditableEditTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Jt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"edit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? \"\" : void 0,\n      onClick: o(e).edit\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"Edit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), [wo, Qd] = Q(\"HoverCardRoot\"), gh = /* @__PURE__ */ w({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { openDelay: l, closeDelay: s } = ne(e);\n    T();\n    const r = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = I(0), u = I(0), d = I(!1), c = I(!1), p = I(!1), f = I();\n    function v() {\n      clearTimeout(u.value), i.value = window.setTimeout(() => r.value = !0, l.value);\n    }\n    function g() {\n      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => r.value = !1, s.value));\n    }\n    function m() {\n      r.value = !1;\n    }\n    return Qd({\n      open: r,\n      onOpenChange(S) {\n        r.value = S;\n      },\n      onOpen: v,\n      onClose: g,\n      onDismiss: m,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: c,\n      isPointerInTransitRef: p,\n      triggerElement: f\n    }), (S, x) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(S.$slots, \"default\", { open: o(r) })\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction Tn(a) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : a();\n}\nfunction ec(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nconst bh = /* @__PURE__ */ w({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = T(), n = wo();\n    n.triggerElement = e;\n    function l() {\n      setTimeout(() => {\n        !n.isPointerInTransitRef.value && !n.open.value && n.onClose();\n      }, 0);\n    }\n    return (s, r) => (b(), _(o(Tt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(t),\n          \"as-child\": s.asChild,\n          as: s.as,\n          \"data-state\": o(n).open.value ? \"open\" : \"closed\",\n          \"data-grace-area-trigger\": \"\",\n          onPointerenter: r[0] || (r[0] = (i) => o(Tn)(o(n).onOpen)(i)),\n          onPointerleave: r[1] || (r[1] = (i) => o(Tn)(l)(i)),\n          onFocus: r[2] || (r[2] = (i) => o(n).onOpen()),\n          onBlur: r[3] || (r[3] = (i) => o(n).onClose())\n        }, {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Ch = /* @__PURE__ */ w({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), tc = /* @__PURE__ */ w({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Bt(e), { forwardRef: s, currentElement: r } = T(), i = wo(), { isPointerInTransit: u, onPointerExit: d } = Il(i.triggerElement, r);\n    li(i.isPointerInTransitRef, u, { direction: \"rtl\" }), d(() => {\n      i.onClose();\n    });\n    const c = I(!1);\n    let p;\n    ye((v) => {\n      if (c.value) {\n        const g = document.body;\n        p = g.style.userSelect || g.style.webkitUserSelect, g.style.userSelect = \"none\", g.style.webkitUserSelect = \"none\", v(() => {\n          g.style.userSelect = p, g.style.webkitUserSelect = p;\n        });\n      }\n    });\n    function f() {\n      c.value = !1, i.isPointerDownOnContentRef.value = !1, le(() => {\n        var g;\n        ((g = document.getSelection()) == null ? void 0 : g.toString()) !== \"\" && (i.hasSelectionRef.value = !0);\n      });\n    }\n    return se(() => {\n      r.value && (document.addEventListener(\"pointerup\", f), ec(r.value).forEach((g) => g.setAttribute(\"tabindex\", \"-1\")));\n    }), Ie(() => {\n      document.removeEventListener(\"pointerup\", f), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;\n    }), (v, g) => (b(), _(o(yt), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: g[1] || (g[1] = (m) => n(\"escapeKeyDown\", m)),\n      onPointerDownOutside: g[2] || (g[2] = (m) => n(\"pointerDownOutside\", m)),\n      onFocusOutside: g[3] || (g[3] = ie((m) => n(\"focusOutside\", m), [\"prevent\"])),\n      onDismiss: o(i).onDismiss\n    }, {\n      default: y(() => [\n        Y(o(Pt), k({ ...o(l), ...v.$attrs }, {\n          ref: o(s),\n          \"data-state\": o(i).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: c.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: c.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: g[0] || (g[0] = (m) => {\n            m.currentTarget.contains(m.target) && (c.value = !0), o(i).hasSelectionRef.value = !1, o(i).isPointerDownOnContentRef.value = !0;\n          })\n        }), {\n          default: y(() => [\n            C(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), wh = /* @__PURE__ */ w({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), { forwardRef: s } = T(), r = wo();\n    return (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        Y(tc, k(o(l), {\n          ref: o(s),\n          onPointerenter: u[0] || (u[0] = (d) => o(Tn)(o(r).onOpen)(d))\n        }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), _h = /* @__PURE__ */ w({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(qt), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xh = /* @__PURE__ */ w({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), k(t, {\n      onMousedown: n[0] || (n[0] = (l) => {\n        !l.defaultPrevented && l.detail > 1 && l.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction ac(a) {\n  return a == null ? void 0 : a.querySelector(\"[data-state=checked]\");\n}\nfunction nc(a, t, e) {\n  return a === void 0 ? !1 : Array.isArray(a) ? a.some((n) => Ht(n, t, e)) : Ht(a, t, e);\n}\nfunction Ht(a, t, e) {\n  return a === void 0 || t === void 0 ? !1 : typeof a == \"string\" ? a === t : typeof e == \"function\" ? e(a, t) : typeof e == \"string\" ? (a == null ? void 0 : a[e]) === (t == null ? void 0 : t[e]) : Ye(a, t);\n}\nconst [en, oc] = Q(\"ListboxRoot\"), Sh = /* @__PURE__ */ w({\n  __name: \"ListboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    multiple: { type: Boolean },\n    orientation: { default: \"vertical\" },\n    dir: {},\n    disabled: { type: Boolean },\n    selectionBehavior: { default: \"toggle\" },\n    highlightOnHover: { type: Boolean },\n    by: {},\n    name: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"highlight\", \"entryFocus\", \"leave\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, highlightOnHover: s, orientation: r, disabled: i, selectionBehavior: u, dir: d } = ne(e), { getItems: c } = ba(), { handleTypeaheadSearch: p } = ga(), { primitiveElement: f, currentElement: v } = Ae(), g = et(), m = be(d), S = Qe(v), x = I(), D = I(!1), h = I(!0), E = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? (l.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    });\n    function P(G) {\n      if (D.value = !0, Array.isArray(E.value)) {\n        const Z = E.value.findIndex((ee) => Ht(ee, G, e.by));\n        if (e.selectionBehavior === \"toggle\") {\n          const ee = [...E.value];\n          Z === -1 ? ee.push(G) : ee.splice(Z, 1), E.value = ee;\n        } else\n          E.value = [G], x.value = G;\n      } else\n        e.selectionBehavior === \"toggle\" && Ht(E.value, G, e.by) ? E.value = void 0 : E.value = G;\n      setTimeout(() => {\n        D.value = !1;\n      }, 1);\n    }\n    const $ = I(null), R = I(null), M = I(!1), V = ia(), A = ia();\n    function L() {\n      return c().map((G) => G.ref).filter((G) => G.dataset.disabled !== \"\");\n    }\n    function U(G) {\n      $.value = G, $.value.focus(), $.value.scrollIntoView({ block: \"nearest\" });\n      const Z = c().find((ee) => ee.ref === G);\n      n(\"highlight\", Z);\n    }\n    function H(G) {\n      $.value && $.value.click();\n    }\n    function J(G) {\n      if (D.value = !0, M.value)\n        A.trigger(G);\n      else {\n        const Z = G.altKey || G.ctrlKey || G.metaKey;\n        if (Z && G.key === \"a\" && l.value) {\n          const ee = c(), fe = ee.map((q) => q.value);\n          E.value = [...fe], G.preventDefault(), U(ee[ee.length - 1].ref);\n        } else if (!Z) {\n          const ee = p(G.key, L());\n          ee && U(ee);\n        }\n      }\n      setTimeout(() => {\n        D.value = !1;\n      }, 1);\n    }\n    function N(G) {\n      R.value = $.value, $.value = null, n(\"leave\", G);\n    }\n    function F(G) {\n      var ee, fe;\n      const Z = new CustomEvent(\"listbox.entryFocus\", { bubbles: !1, cancelable: !0 });\n      if ((ee = G.currentTarget) == null || ee.dispatchEvent(Z), n(\"entryFocus\", Z), !Z.defaultPrevented)\n        if (R.value)\n          U(R.value);\n        else {\n          const q = (fe = L()) == null ? void 0 : fe[0];\n          U(q);\n        }\n    }\n    function W(G) {\n      const Z = Xl(G, r.value, m.value);\n      if (!Z)\n        return;\n      let ee = L();\n      if ($.value) {\n        if (Z === \"last\")\n          ee.reverse();\n        else if (Z === \"prev\" || Z === \"next\") {\n          Z === \"prev\" && ee.reverse();\n          const fe = ee.indexOf($.value);\n          ee = ee.slice(fe + 1);\n        }\n        z(G, ee[0]);\n      }\n      if (ee.length) {\n        const fe = !$.value && Z === \"prev\" ? ee.length - 1 : 0;\n        U(ee[fe]);\n      }\n      if (M.value)\n        return A.trigger(G);\n    }\n    function z(G, Z) {\n      var fe;\n      if (!(M.value || e.selectionBehavior !== \"replace\" || !l.value || !Array.isArray(E.value) || (G.altKey || G.ctrlKey || G.metaKey) && !G.shiftKey) && G.shiftKey) {\n        const q = c().filter((Ce) => Ce.ref.dataset.disabled !== \"\");\n        let oe = (fe = q.find((Ce) => Ce.ref === Z)) == null ? void 0 : fe.value;\n        if (G.key === g.END ? oe = q[q.length - 1].value : G.key === g.HOME && (oe = q[0].value), !oe || !x.value)\n          return;\n        const he = St(q.map((Ce) => Ce.value), x.value, oe);\n        E.value = he;\n      }\n    }\n    async function X(G) {\n      if (M.value)\n        V.trigger(G);\n      else {\n        await le();\n        const ee = L().find((fe) => fe.dataset.state === \"checked\");\n        ee && U(ee);\n      }\n    }\n    return te(E, () => {\n      D.value || le(() => {\n        X();\n      });\n    }, { immediate: !0, deep: !0 }), oc({\n      modelValue: E,\n      // @ts-expect-error ignoring\n      onValueChange: P,\n      multiple: l,\n      orientation: r,\n      dir: m,\n      disabled: i,\n      highlightOnHover: s,\n      highlightedElement: $,\n      isVirtual: M,\n      virtualFocusHook: V,\n      virtualKeydownHook: A,\n      by: e.by,\n      firstValue: x,\n      selectionBehavior: u,\n      focusable: h,\n      onLeave: N,\n      onEnter: F,\n      onChangeHighlight: U,\n      onKeydownEnter: H,\n      onKeydownNavigation: W,\n      onKeydownTypeAhead: J\n    }), (G, Z) => (b(), _(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: f,\n      as: G.as,\n      \"as-child\": G.asChild,\n      dir: o(m),\n      \"data-disabled\": o(i) ? \"\" : void 0,\n      onPointerleave: N,\n      onFocusout: Z[0] || (Z[0] = (ee) => {\n        const fe = ee.relatedTarget || ee.target;\n        $.value && !o(v).contains(fe) && N(ee);\n      })\n    }, {\n      default: y(() => [\n        C(G.$slots, \"default\", { modelValue: o(E) }),\n        o(S) && e.name ? (b(), _(o(to), {\n          key: 0,\n          name: e.name,\n          value: o(E)\n        }, null, 8, [\"name\", \"value\"])) : pe(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"dir\", \"data-disabled\"]));\n  }\n}), Eh = /* @__PURE__ */ w({\n  __name: \"ListboxContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = en(), e = Dt(!1, 10);\n    return (n, l) => (b(), _(o(Ca), null, {\n      default: y(() => [\n        Y(o(O), {\n          role: \"listbox\",\n          as: n.as,\n          \"as-child\": n.asChild,\n          tabindex: o(t).focusable.value ? o(t).highlightedElement.value ? \"-1\" : \"0\" : void 0,\n          \"data-orientation\": o(t).orientation.value,\n          onMousedown: l[0] || (l[0] = ie((s) => e.value = !0, [\"left\"])),\n          onFocus: l[1] || (l[1] = (s) => {\n            o(e) || o(t).onEnter(s);\n          }),\n          onKeydown: [\n            l[2] || (l[2] = re(ie((s) => {\n              o(t).focusable.value && o(t).onKeydownNavigation(s);\n            }, [\"prevent\"]), [\"down\", \"up\", \"home\", \"end\"])),\n            re(o(t).onKeydownEnter, [\"enter\"]),\n            o(t).onKeydownTypeAhead\n          ]\n        }, {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"tabindex\", \"data-orientation\", \"onKeydown\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Ph = /* @__PURE__ */ w({\n  __name: \"ListboxFilter\",\n  props: {\n    modelValue: {},\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"modelValue\", t, {\n      defaultValue: \"\",\n      passive: e.modelValue === void 0\n    }), s = en();\n    s.focusable.value = !1;\n    const { primitiveElement: r, currentElement: i } = Ae();\n    return se(() => {\n      setTimeout(() => {\n        var u;\n        e.autoFocus && ((u = i.value) == null || u.focus());\n      }, 1);\n    }), (u, d) => (b(), _(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: r,\n      as: u.as,\n      \"as-child\": u.asChild,\n      value: o(l),\n      disabled: o(s).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(s).disabled.value ? \"\" : void 0,\n      type: \"text\",\n      onKeydown: [\n        re(ie(o(s).onKeydownNavigation, [\"prevent\"]), [\"down\", \"up\", \"home\", \"end\"]),\n        re(o(s).onKeydownEnter, [\"enter\"])\n      ],\n      onInput: d[0] || (d[0] = (c) => {\n        l.value = c.target.value;\n      })\n    }, {\n      default: y(() => [\n        C(u.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"value\", \"disabled\", \"data-disabled\", \"onKeydown\"]));\n  }\n}), lc = \"listbox.select\", [sc, rc] = Q(\"ListboxItem\"), Dh = /* @__PURE__ */ w({\n  __name: \"ListboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), r = me(void 0, \"radix-vue-listbox-item\"), i = en(), u = B(() => s.value === i.highlightedElement.value), d = B(() => nc(i.modelValue.value, e.value, i.by)), c = B(() => i.disabled.value || e.disabled);\n    async function p(v) {\n      n(\"select\", v), !(v != null && v.defaultPrevented) && !c.value && v && (i.onValueChange(e.value), i.onChangeHighlight(v.target));\n    }\n    function f(v) {\n      const g = { originalEvent: v, value: e.value };\n      zt(lc, p, g);\n    }\n    return rc({\n      isSelected: d\n    }), (v, g) => (b(), _(o(Xt), { value: v.value }, {\n      default: y(() => [\n        Y(o(O), {\n          id: o(r),\n          ref: o(l),\n          role: \"option\",\n          tabindex: o(i).focusable.value ? u.value ? \"0\" : \"-1\" : void 0,\n          \"aria-selected\": d.value,\n          as: v.as,\n          \"as-child\": v.asChild,\n          disabled: c.value ? \"\" : void 0,\n          \"data-disabled\": c.value ? \"\" : void 0,\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"data-state\": d.value ? \"checked\" : \"unchecked\",\n          onClick: f,\n          onKeydown: re(ie(f, [\"prevent\"]), [\"space\"]),\n          onPointermove: g[0] || (g[0] = (m) => {\n            o(i).highlightOnHover.value ? o(i).onChangeHighlight(o(s)) : o(i).focusable.value || o(i).onChangeHighlight(o(s));\n          })\n        }, {\n          default: y(() => [\n            C(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"tabindex\", \"aria-selected\", \"as\", \"as-child\", \"disabled\", \"data-disabled\", \"data-highlighted\", \"data-state\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), $h = /* @__PURE__ */ w({\n  __name: \"ListboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = sc();\n    return (n, l) => o(e).isSelected.value ? (b(), _(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n});\nfunction na(a, t, e) {\n  let n = e.initialDeps ?? [], l;\n  return () => {\n    var s, r, i, u;\n    let d;\n    e.key && ((s = e.debug) != null && s.call(e)) && (d = Date.now());\n    const c = a();\n    if (!(c.length !== n.length || c.some((v, g) => n[g] !== v)))\n      return l;\n    n = c;\n    let f;\n    if (e.key && ((r = e.debug) != null && r.call(e)) && (f = Date.now()), l = t(...c), e.key && ((i = e.debug) != null && i.call(e))) {\n      const v = Math.round((Date.now() - d) * 100) / 100, g = Math.round((Date.now() - f) * 100) / 100, m = g / 16, S = (x, D) => {\n        for (x = String(x); x.length < D; )\n          x = \" \" + x;\n        return x;\n      };\n      console.info(\n        `%c⏱ ${S(g, 5)} /${S(v, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * m, 120)\n        )}deg 100% 31%);`,\n        e == null ? void 0 : e.key\n      );\n    }\n    return (u = e == null ? void 0 : e.onChange) == null || u.call(e, l), l;\n  };\n}\nfunction xn(a, t) {\n  if (a === void 0)\n    throw new Error(\"Unexpected undefined\");\n  return a;\n}\nconst ic = (a, t) => Math.abs(a - t) < 1, uc = (a, t, e) => {\n  let n;\n  return function(...l) {\n    a.clearTimeout(n), n = a.setTimeout(() => t.apply(this, l), e);\n  };\n}, dc = (a) => a, cc = (a) => {\n  const t = Math.max(a.startIndex - a.overscan, 0), e = Math.min(a.endIndex + a.overscan, a.count - 1), n = [];\n  for (let l = t; l <= e; l++)\n    n.push(l);\n  return n;\n}, pc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  const l = (r) => {\n    const { width: i, height: u } = r;\n    t({ width: Math.round(i), height: Math.round(u) });\n  };\n  if (l(e.getBoundingClientRect()), !n.ResizeObserver)\n    return () => {\n    };\n  const s = new n.ResizeObserver((r) => {\n    const i = r[0];\n    if (i != null && i.borderBoxSize) {\n      const u = i.borderBoxSize[0];\n      if (u) {\n        l({ width: u.inlineSize, height: u.blockSize });\n        return;\n      }\n    }\n    l(e.getBoundingClientRect());\n  });\n  return s.observe(e, { box: \"border-box\" }), () => {\n    s.unobserve(e);\n  };\n}, Go = {\n  passive: !0\n}, fc = typeof window > \"u\" ? !0 : \"onscrollend\" in window, vc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  let l = 0;\n  const s = fc ? () => {\n  } : uc(\n    n,\n    () => {\n      t(l, !1);\n    },\n    a.options.isScrollingResetDelay\n  ), r = (d) => () => {\n    l = e[a.options.horizontal ? \"scrollLeft\" : \"scrollTop\"], s(), t(l, d);\n  }, i = r(!0), u = r(!1);\n  return u(), e.addEventListener(\"scroll\", i, Go), e.addEventListener(\"scrollend\", u, Go), () => {\n    e.removeEventListener(\"scroll\", i), e.removeEventListener(\"scrollend\", u);\n  };\n}, mc = (a, t, e) => {\n  if (t != null && t.borderBoxSize) {\n    const n = t.borderBoxSize[0];\n    if (n)\n      return Math.round(\n        n[e.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n  }\n  return Math.round(\n    a.getBoundingClientRect()[e.options.horizontal ? \"width\" : \"height\"]\n  );\n}, hc = (a, {\n  adjustments: t = 0,\n  behavior: e\n}, n) => {\n  var l, s;\n  const r = a + t;\n  (s = (l = n.scrollElement) == null ? void 0 : l.scrollTo) == null || s.call(l, {\n    [n.options.horizontal ? \"left\" : \"top\"]: r,\n    behavior: e\n  });\n};\nclass yc {\n  constructor(t) {\n    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {\n      let e = null;\n      const n = () => e || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : e = new this.targetWindow.ResizeObserver((l) => {\n        l.forEach((s) => {\n          this._measureElement(s.target, s);\n        });\n      }));\n      return {\n        disconnect: () => {\n          var l;\n          return (l = n()) == null ? void 0 : l.disconnect();\n        },\n        observe: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.observe(l, { box: \"border-box\" });\n        },\n        unobserve: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.unobserve(l);\n        }\n      };\n    })(), this.range = null, this.setOptions = (e) => {\n      Object.entries(e).forEach(([n, l]) => {\n        typeof l > \"u\" && delete e[n];\n      }), this.options = {\n        debug: !1,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: !1,\n        getItemKey: dc,\n        rangeExtractor: cc,\n        onChange: () => {\n        },\n        measureElement: mc,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: !0,\n        ...e\n      };\n    }, this.notify = (e, n) => {\n      var l, s;\n      const { startIndex: r, endIndex: i } = this.range ?? {\n        startIndex: void 0,\n        endIndex: void 0\n      }, u = this.calculateRange();\n      (e || r !== (u == null ? void 0 : u.startIndex) || i !== (u == null ? void 0 : u.endIndex)) && ((s = (l = this.options).onChange) == null || s.call(l, this, n));\n    }, this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((e) => e()), this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.observer.disconnect(), this.elementsCache.clear();\n    }, this._didMount = () => () => {\n      this.cleanup();\n    }, this._willUpdate = () => {\n      var e;\n      const n = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== n) {\n        if (this.cleanup(), !n) {\n          this.notify(!1, !1);\n          return;\n        }\n        this.scrollElement = n, this.scrollElement && \"ownerDocument\" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((e = this.scrollElement) == null ? void 0 : e.window) ?? null, this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        }), this.unsubs.push(\n          this.options.observeElementRect(this, (l) => {\n            this.scrollRect = l, this.notify(!1, !1);\n          })\n        ), this.unsubs.push(\n          this.options.observeElementOffset(this, (l, s) => {\n            this.scrollAdjustments = 0, this.scrollDirection = s ? this.getScrollOffset() < l ? \"forward\" : \"backward\" : null, this.scrollOffset = l;\n            const r = this.isScrolling;\n            this.isScrolling = s, this.notify(r !== s, s);\n          })\n        );\n      }\n    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? \"width\" : \"height\"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == \"function\" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (e, n) => {\n      const l = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();\n      for (let r = n - 1; r >= 0; r--) {\n        const i = e[r];\n        if (l.has(i.lane))\n          continue;\n        const u = s.get(\n          i.lane\n        );\n        if (u == null || i.end > u.end ? s.set(i.lane, i) : i.end < u.end && l.set(i.lane, !0), l.size === this.options.lanes)\n          break;\n      }\n      return s.size === this.options.lanes ? Array.from(s.values()).sort((r, i) => r.end === i.end ? r.index - i.index : r.end - i.end)[0] : void 0;\n    }, this.getMeasurementOptions = na(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (e, n, l, s, r) => (this.pendingMeasuredCacheIndexes = [], {\n        count: e,\n        paddingStart: n,\n        scrollMargin: l,\n        getItemKey: s,\n        enabled: r\n      }),\n      {\n        key: !1\n      }\n    ), this.getMeasurements = na(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count: e, paddingStart: n, scrollMargin: l, getItemKey: s, enabled: r }, i) => {\n        var u;\n        if (!r)\n          return this.measurementsCache = [], this.itemSizeCache.clear(), [];\n        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((p) => {\n          this.itemSizeCache.set(p.key, p.size);\n        }));\n        const d = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const c = this.measurementsCache.slice(0, d);\n        for (let p = d; p < e; p++) {\n          let f = (u = this.measurementsCache[p]) == null ? void 0 : u.measureElement;\n          f || (f = (E) => {\n            const P = s(p), $ = this.elementsCache.get(P);\n            if (!E) {\n              $ && (this.observer.unobserve($), this.elementsCache.delete(P));\n              return;\n            }\n            $ !== E && ($ && this.observer.unobserve($), this.observer.observe(E), this.elementsCache.set(P, E)), E.isConnected && this.resizeItem(\n              p,\n              this.options.measureElement(E, void 0, this)\n            );\n          });\n          const v = s(p), g = this.options.lanes === 1 ? c[p - 1] : this.getFurthestMeasurement(c, p), m = g ? g.end + this.options.gap : n + l, S = i.get(v), x = typeof S == \"number\" ? S : this.options.estimateSize(p), D = m + x, h = g ? g.lane : p % this.options.lanes;\n          c[p] = {\n            index: p,\n            start: m,\n            size: x,\n            end: D,\n            key: v,\n            lane: h,\n            measureElement: f\n          };\n        }\n        return this.measurementsCache = c, c;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    ), this.calculateRange = na(\n      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n      (e, n, l) => this.range = e.length > 0 && n > 0 ? gc({\n        measurements: e,\n        outerSize: n,\n        scrollOffset: l\n      }) : null,\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    ), this.getIndexes = na(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (e, n, l, s) => n === null ? [] : e({\n        startIndex: n.startIndex,\n        endIndex: n.endIndex,\n        overscan: l,\n        count: s\n      }),\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.indexFromElement = (e) => {\n      const n = this.options.indexAttribute, l = e.getAttribute(n);\n      return l ? parseInt(l, 10) : (console.warn(\n        `Missing attribute name '${n}={index}' on measured element.`\n      ), -1);\n    }, this._measureElement = (e, n) => {\n      const l = this.indexFromElement(e), s = this.getMeasurements()[l];\n      if (!s || !e.isConnected) {\n        this.elementsCache.forEach((i, u) => {\n          i === e && (this.observer.unobserve(e), this.elementsCache.delete(u));\n        });\n        return;\n      }\n      const r = this.elementsCache.get(s.key);\n      r !== e && (r && this.observer.unobserve(r), this.observer.observe(e), this.elementsCache.set(s.key, e)), this.resizeItem(l, this.options.measureElement(e, n, this));\n    }, this.resizeItem = (e, n) => {\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.itemSizeCache.get(l.key) ?? l.size, r = n - s;\n      r !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(l, r, this) : l.start < this.getScrollOffset() + this.scrollAdjustments) && (process.env.NODE_ENV !== \"production\" && this.options.debug && console.info(\"correction\", r), this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: this.scrollAdjustments += r,\n        behavior: void 0\n      })), this.pendingMeasuredCacheIndexes.push(l.index), this.itemSizeCache = new Map(this.itemSizeCache.set(l.key, n)), this.notify(!0, !1));\n    }, this.measureElement = (e) => {\n      e && this._measureElement(e, void 0);\n    }, this.getVirtualItems = na(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (e, n) => {\n        const l = [];\n        for (let s = 0, r = e.length; s < r; s++) {\n          const i = e[s], u = n[i];\n          l.push(u);\n        }\n        return l;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.getVirtualItemForOffset = (e) => {\n      const n = this.getMeasurements();\n      if (n.length !== 0)\n        return xn(\n          n[ls(\n            0,\n            n.length - 1,\n            (l) => xn(n[l]).start,\n            e\n          )]\n        );\n    }, this.getOffsetForAlignment = (e, n) => {\n      const l = this.getSize(), s = this.getScrollOffset();\n      n === \"auto\" && (e <= s ? n = \"start\" : e >= s + l ? n = \"end\" : n = \"start\"), n === \"start\" ? e = e : n === \"end\" ? e = e - l : n === \"center\" && (e = e - l / 2);\n      const r = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\", u = (this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[r] : this.scrollElement[r] : 0) - l;\n      return Math.max(Math.min(u, e), 0);\n    }, this.getOffsetForIndex = (e, n = \"auto\") => {\n      e = Math.max(0, Math.min(e, this.options.count - 1));\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.getSize(), r = this.getScrollOffset();\n      if (n === \"auto\")\n        if (l.end >= r + s - this.options.scrollPaddingEnd)\n          n = \"end\";\n        else if (l.start <= r + this.options.scrollPaddingStart)\n          n = \"start\";\n        else\n          return [r, n];\n      const i = n === \"end\" ? l.end + this.options.scrollPaddingEnd : l.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(i, n), n];\n    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {\n      this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);\n    }, this.scrollToOffset = (e, { align: n = \"start\", behavior: l } = {}) => {\n      this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getOffsetForAlignment(e, n), {\n        adjustments: void 0,\n        behavior: l\n      });\n    }, this.scrollToIndex = (e, { align: n = \"auto\", behavior: l } = {}) => {\n      e = Math.max(0, Math.min(e, this.options.count - 1)), this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      );\n      const s = this.getOffsetForIndex(e, n);\n      if (!s) return;\n      const [r, i] = s;\n      this._scrollToOffset(r, { adjustments: void 0, behavior: l }), l !== \"smooth\" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(\n          this.options.getItemKey(e)\n        )) {\n          const [d] = xn(\n            this.getOffsetForIndex(e, i)\n          );\n          ic(d, this.getScrollOffset()) || this.scrollToIndex(e, { align: i, behavior: l });\n        } else\n          this.scrollToIndex(e, { align: i, behavior: l });\n      }));\n    }, this.scrollBy = (e, { behavior: n } = {}) => {\n      this.cancelScrollToIndex(), n === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getScrollOffset() + e, {\n        adjustments: void 0,\n        behavior: n\n      });\n    }, this.getTotalSize = () => {\n      var e;\n      const n = this.getMeasurements();\n      let l;\n      return n.length === 0 ? l = this.options.paddingStart : l = this.options.lanes === 1 ? ((e = n[n.length - 1]) == null ? void 0 : e.end) ?? 0 : Math.max(\n        ...n.slice(-this.options.lanes).map((s) => s.end)\n      ), l - this.options.scrollMargin + this.options.paddingEnd;\n    }, this._scrollToOffset = (e, {\n      adjustments: n,\n      behavior: l\n    }) => {\n      this.options.scrollToFn(e, { behavior: l, adjustments: n }, this);\n    }, this.measure = () => {\n      var e, n;\n      this.itemSizeCache = /* @__PURE__ */ new Map(), (n = (e = this.options).onChange) == null || n.call(e, this, !1);\n    }, this.setOptions(t);\n  }\n}\nconst ls = (a, t, e, n) => {\n  for (; a <= t; ) {\n    const l = (a + t) / 2 | 0, s = e(l);\n    if (s < n)\n      a = l + 1;\n    else if (s > n)\n      t = l - 1;\n    else\n      return l;\n  }\n  return a > 0 ? a - 1 : 0;\n};\nfunction gc({\n  measurements: a,\n  outerSize: t,\n  scrollOffset: e\n}) {\n  const n = a.length - 1, s = ls(0, n, (i) => a[i].start, e);\n  let r = s;\n  for (; r < n && a[r].end < e + t; )\n    r++;\n  return { startIndex: s, endIndex: r };\n}\nfunction bc(a) {\n  const t = new yc(o(a)), e = Mn(t), n = t._didMount();\n  return te(\n    () => o(a).getScrollElement(),\n    (l) => {\n      l && t._willUpdate();\n    },\n    {\n      immediate: !0\n    }\n  ), te(\n    () => o(a),\n    (l) => {\n      t.setOptions({\n        ...l,\n        onChange: (s, r) => {\n          var i;\n          Mo(e), (i = l.onChange) == null || i.call(l, s, r);\n        }\n      }), t._willUpdate(), Mo(e);\n    },\n    {\n      immediate: !0\n    }\n  ), rl(n), e;\n}\nfunction ss(a) {\n  return bc(\n    B(() => ({\n      observeElementRect: pc,\n      observeElementOffset: vc,\n      scrollToFn: hc,\n      ...o(a)\n    }))\n  );\n}\nconst Bh = /* @__PURE__ */ w({\n  __name: \"ListboxVirtualizer\",\n  props: {\n    options: {},\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Wa(), n = en(), l = $l(), { getItems: s } = Zt();\n    n.isVirtual.value = !0;\n    const r = B(() => {\n      const f = l.value;\n      if (f) {\n        const v = window.getComputedStyle(f);\n        return {\n          start: Number.parseFloat(v.paddingBlockStart || v.paddingTop),\n          end: Number.parseFloat(v.paddingBlockEnd || v.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), i = ss(\n      {\n        get scrollPaddingStart() {\n          return r.value.start;\n        },\n        get scrollPaddingEnd() {\n          return r.value.end;\n        },\n        get count() {\n          return t.options.length;\n        },\n        get horizontal() {\n          return n.orientation.value === \"horizontal\";\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), u = B(() => i.value.getVirtualItems().map((f) => ({\n      item: f,\n      is: Fn(e.default({\n        option: t.options[f.index]\n      })[0], {\n        key: `${f.key}`,\n        \"data-index\": f.index,\n        \"aria-setsize\": t.options.length,\n        \"aria-posinset\": f.index + 1,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${f.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    n.virtualFocusHook.on((f) => {\n      const v = t.options.findIndex((g) => Array.isArray(n.modelValue.value) ? Ht(g, n.modelValue.value[0], n.by) : Ht(g, n.modelValue.value, n.by));\n      v !== -1 && (f == null || f.preventDefault(), i.value.scrollToIndex(v, { align: \"start\" }), requestAnimationFrame(() => {\n        const g = ac(l.value);\n        g && f && (g == null || g.focus());\n      }));\n    });\n    const d = Dt(\"\", 1e3), c = B(() => {\n      const f = (v) => t.textContent ? t.textContent(v) : v.toString().toLowerCase();\n      return t.options.map((v, g) => ({\n        index: g,\n        textContent: f(v)\n      }));\n    });\n    function p(f, v) {\n      var x, D, h, E;\n      if (!((x = n.firstValue) != null && x.value) || !n.multiple.value || !Array.isArray(n.modelValue.value))\n        return;\n      const m = (D = s().filter((P) => P.ref.dataset.disabled !== \"\").find((P) => P.ref === n.highlightedElement.value)) == null ? void 0 : D.value;\n      if (!m)\n        return;\n      let S = null;\n      switch (v) {\n        case \"prev\":\n        case \"next\": {\n          S = St(t.options, n.firstValue.value, m);\n          break;\n        }\n        case \"first\": {\n          S = St(t.options, n.firstValue.value, (h = t.options) == null ? void 0 : h[0]);\n          break;\n        }\n        case \"last\": {\n          S = St(t.options, n.firstValue.value, (E = t.options) == null ? void 0 : E[t.options.length - 1]);\n          break;\n        }\n      }\n      n.modelValue.value = S;\n    }\n    return n.virtualKeydownHook.on((f) => {\n      var S;\n      const v = f.altKey || f.ctrlKey || f.metaKey;\n      if (f.key === \"Tab\" && !v)\n        return;\n      let m = Ja[f.key];\n      if (v && f.key === \"a\" && n.multiple.value ? (f.preventDefault(), n.modelValue.value = [...t.options], m = \"last\") : f.shiftKey && m && p(f, m), [\"first\", \"last\"].includes(m)) {\n        f.preventDefault();\n        const x = m === \"first\" ? 0 : t.options.length - 1;\n        i.value.scrollToIndex(x), requestAnimationFrame(() => {\n          const D = s(), h = m === \"first\" ? D[0] : D[D.length - 1];\n          n.onChangeHighlight(h.ref);\n        });\n      } else if (!m && !v) {\n        d.value += f.key;\n        const x = Number((S = document.activeElement) == null ? void 0 : S.getAttribute(\"data-index\")), D = c.value[x].textContent, h = c.value.map(($) => $.textContent), E = Yn(h, d.value, D), P = c.value.find(($) => $.textContent === E);\n        P && (i.value.scrollToIndex(P.index, { align: \"start\" }), requestAnimationFrame(() => {\n          const $ = l.value.querySelector(`[data-index=\"${P.index}\"]`);\n          $ instanceof HTMLElement && n.onChangeHighlight($);\n        }));\n      }\n    }), (f, v) => (b(), ce(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: Oe({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(i).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ce(_e, null, va(u.value, ({ is: g, item: m }) => (b(), _(Ge(g), {\n        key: m.index\n      }))), 128))\n    ], 4));\n  }\n}), [Cc, wc] = Q(\"ListboxGroup\"), Ih = /* @__PURE__ */ w({\n  __name: \"ListboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = me(void 0, \"radix-vue-listbox-group\");\n    return wc({ id: e }), (n, l) => (b(), _(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Th = /* @__PURE__ */ w({\n  __name: \"ListboxGroupLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Cc({ id: \"\" });\n    return (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [tn, _c] = Q(\"MenubarRoot\"), Rh = /* @__PURE__ */ w({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), { createCollection: r } = Me(\"menubar\");\n    r(s);\n    const i = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = I(null), { dir: d, loop: c } = ne(e), p = be(d);\n    return _c({\n      modelValue: i,\n      dir: p,\n      loop: c,\n      onMenuOpen: (f) => {\n        i.value = f, u.value = f;\n      },\n      onMenuClose: () => {\n        i.value = \"\";\n      },\n      onMenuToggle: (f) => {\n        i.value = i.value ? \"\" : f, u.value = f;\n      }\n    }), (f, v) => (b(), _(o(At), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": v[0] || (v[0] = (g) => u.value = g),\n      orientation: \"horizontal\",\n      loop: o(c),\n      dir: o(p),\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(l),\n          role: \"menubar\"\n        }, {\n          default: y(() => [\n            C(f.$slots, \"default\", { modelValue: o(i) })\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [_o, xc] = Q(\"MenubarMenu\"), Ah = /* @__PURE__ */ w({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(a) {\n    const e = me(a.value), n = tn();\n    T();\n    const l = I(), s = I(!1), r = B(() => n.modelValue.value === e);\n    return te(r, () => {\n      r.value || (s.value = !1);\n    }), xc({\n      value: e,\n      triggerElement: l,\n      triggerId: e,\n      contentId: \"\",\n      wasKeyboardTriggerOpenRef: s\n    }), (i, u) => (b(), _(o(oo), {\n      open: r.value,\n      modal: !1,\n      dir: o(n).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || o(n).onMenuClose();\n      })\n    }, {\n      default: y(() => [\n        C(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), Oh = /* @__PURE__ */ w({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = tn(), e = _o(), { forwardRef: n, currentElement: l } = T(), s = I(!1), r = B(() => t.modelValue.value === e.value);\n    return se(() => {\n      e.triggerElement = l;\n    }), (i, u) => (b(), _(o(Ot), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      \"tab-stop-id\": o(e).value\n    }, {\n      default: y(() => [\n        Y(o(Za), { \"as-child\": \"\" }, {\n          default: y(() => [\n            Y(o(O), {\n              id: o(e).triggerId,\n              ref: o(n),\n              as: i.as,\n              type: i.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": r.value,\n              \"aria-controls\": r.value ? o(e).contentId : void 0,\n              \"data-highlighted\": s.value ? \"\" : void 0,\n              \"data-state\": r.value ? \"open\" : \"closed\",\n              \"data-disabled\": i.disabled ? \"\" : void 0,\n              disabled: i.disabled,\n              \"data-value\": o(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !i.disabled && d.button === 0 && d.ctrlKey === !1 && (o(t).onMenuOpen(o(e).value), r.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var c;\n                !!o(t).modelValue.value && !r.value && (o(t).onMenuOpen(o(e).value), (c = o(l)) == null || c.focus());\n              }),\n              onKeydown: u[2] || (u[2] = re((d) => {\n                i.disabled || ([\"Enter\", \" \"].includes(d.key) && o(t).onMenuToggle(o(e).value), d.key === \"ArrowDown\" && o(t).onMenuOpen(o(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (o(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => s.value = !0),\n              onBlur: u[4] || (u[4] = (d) => s.value = !1)\n            }, {\n              default: y(() => [\n                C(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), kh = /* @__PURE__ */ w({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(po), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mh = /* @__PURE__ */ w({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    T();\n    const s = tn(), r = _o();\n    r.contentId || (r.contentId = me(void 0, \"radix-vue-menubar-content\"));\n    const { injectCollection: i } = Me(\"menubar\"), u = i(), d = I(!1);\n    function c(p) {\n      const v = p.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), m = (s.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === p.key;\n      if (!m && v)\n        return;\n      let x = u.value.map((E) => E.dataset.value);\n      m && x.reverse();\n      const D = x.indexOf(r.value);\n      x = s.loop.value ? qn(x, D + 1) : x.slice(D + 1);\n      const [h] = x;\n      h && s.onMenuOpen(h);\n    }\n    return (p, f) => (b(), _(o(uo), k(o(l), {\n      id: o(r).contentId,\n      \"data-radix-menubar-content\": \"\",\n      \"aria-labelledby\": o(r).triggerId,\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: f[0] || (f[0] = (v) => {\n        var m;\n        !!!o(s).modelValue.value && !d.value && ((m = o(r).triggerElement.value) == null || m.focus()), d.value = !1, v.preventDefault();\n      }),\n      onFocusOutside: f[1] || (f[1] = (v) => {\n        const g = v.target;\n        o(u).some((S) => S.contains(g)) && v.preventDefault();\n      }),\n      onInteractOutside: f[2] || (f[2] = (v) => {\n        d.value = !0;\n      }),\n      onEntryFocus: f[3] || (f[3] = (v) => {\n        o(r).wasKeyboardTriggerOpenRef.value || v.preventDefault();\n      }),\n      onKeydown: re(c, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: y(() => [\n        C(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\"]));\n  }\n}), Vh = /* @__PURE__ */ w({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(no), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fh = /* @__PURE__ */ w({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(_a), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lh = /* @__PURE__ */ w({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(Qa), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nh = /* @__PURE__ */ w({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(mo), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zh = /* @__PURE__ */ w({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(io), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Kh = /* @__PURE__ */ w({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(ro), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Hh = /* @__PURE__ */ w({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(co), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wh = /* @__PURE__ */ w({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Re(t);\n    return T(), (s, r) => (b(), _(o(fo), K(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jh = /* @__PURE__ */ w({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return T(), (s, r) => (b(), _(o(vo), K(j(o(l))), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Uh = /* @__PURE__ */ w({\n  __name: \"MenubarSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen ?? !1,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), _(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Gh = /* @__PURE__ */ w({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    T();\n    const { injectCollection: s } = Me(\"menubar\"), r = tn(), i = _o(), u = s();\n    function d(c) {\n      if (c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let v = u.value.map((S) => S.dataset.value);\n      const g = v.indexOf(i.value);\n      v = r.loop.value ? qn(v, g + 1) : v.slice(g + 1);\n      const [m] = v;\n      m && r.onMenuOpen(m);\n    }\n    return (c, p) => (b(), _(o(yo), k(o(l), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: re(d, [\"arrow-right\"])\n    }), {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qh = /* @__PURE__ */ w({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(go), k(t, { \"data-radix-menubar-subtrigger\": \"\" }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [gt, rs] = Q([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), Yh = /* @__PURE__ */ w({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    disableClickTrigger: { type: Boolean, default: !1 },\n    disableHoverTrigger: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = I(\"\"), { forwardRef: r, currentElement: i } = T(), u = I(), d = I(), { createCollection: c } = Me(\"nav\");\n    c(u);\n    const { delayDuration: p, skipDelayDuration: f, dir: v, disableClickTrigger: g, disableHoverTrigger: m } = ne(e), S = be(v), x = Dt(!1, f), D = B(() => l.value !== \"\" || x.value ? 150 : p.value), h = Hn((E) => {\n      typeof E == \"string\" && (s.value = l.value, l.value = E);\n    }, D);\n    return rs({\n      isRootMenu: !0,\n      modelValue: l,\n      previousValue: s,\n      baseId: me(void 0, \"radix-navigation-menu\"),\n      disableClickTrigger: g,\n      disableHoverTrigger: m,\n      dir: S,\n      orientation: e.orientation,\n      rootNavigationMenu: i,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (E) => {\n        u.value = E;\n      },\n      viewport: d,\n      onViewportChange: (E) => {\n        d.value = E;\n      },\n      onTriggerEnter: (E) => {\n        h(E);\n      },\n      onTriggerLeave: () => {\n        x.value = !0, h(\"\");\n      },\n      onContentEnter: () => {\n        h();\n      },\n      onContentLeave: () => {\n        h(\"\");\n      },\n      onItemSelect: (E) => {\n        s.value = l.value, l.value = E;\n      },\n      onItemDismiss: () => {\n        s.value = l.value, l.value = \"\";\n      }\n    }), (E, P) => (b(), _(o(O), {\n      ref: o(r),\n      \"aria-label\": \"Main\",\n      as: E.as,\n      \"as-child\": E.asChild,\n      \"data-orientation\": E.orientation,\n      dir: o(S)\n    }, {\n      default: y(() => [\n        C(E.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction an(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction is(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction xo(a, t) {\n  return `${a}-content-${t}`;\n}\nconst ka = \"navigationMenu.rootContentDismiss\";\nfunction Rn(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction us(a) {\n  const t = document.activeElement;\n  return a.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));\n}\nfunction Sc(a) {\n  return a.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    a.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nfunction ds(a) {\n  return (t) => t.pointerType === \"mouse\" ? a(t) : void 0;\n}\nconst [So, Ec] = Q(\"NavigationMenuItem\"), Xh = /* @__PURE__ */ w({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const { injectCollection: e } = Me(\"nav\"), n = e(), l = gt(), s = me(t.value), r = I(), i = I(), u = xo(l.baseId, s);\n    let d = () => ({});\n    const c = I(!1);\n    async function p(m = \"start\") {\n      const S = document.getElementById(u);\n      if (S) {\n        d();\n        const x = Rn(S);\n        x.length && us(m === \"start\" ? x : x.reverse());\n      }\n    }\n    function f() {\n      const m = document.getElementById(u);\n      if (m) {\n        const S = Rn(m);\n        S.length && (d = Sc(S));\n      }\n    }\n    Ec({\n      value: s,\n      contentId: u,\n      triggerRef: r,\n      focusProxyRef: i,\n      wasEscapeCloseRef: c,\n      onEntryKeyDown: p,\n      onFocusProxyEnter: p,\n      onContentFocusOutside: f,\n      onRootContentClose: f\n    });\n    function v() {\n      var m;\n      l.onItemDismiss(), (m = r.value) == null || m.focus();\n    }\n    function g(m) {\n      const S = document.activeElement;\n      if (m.keyCode === 32 || m.key === \"Enter\")\n        if (l.modelValue.value === s) {\n          v(), m.preventDefault();\n          return;\n        } else {\n          m.target.click(), m.preventDefault();\n          return;\n        }\n      const x = n.value.filter(\n        (h) => {\n          var E;\n          return (E = h.parentElement) == null ? void 0 : E.hasAttribute(\"data-menu-item\");\n        }\n      ), D = $t(m, S, void 0, {\n        itemsArray: x,\n        loop: !1\n      });\n      D && (D == null || D.focus()), m.preventDefault(), m.stopPropagation();\n    }\n    return (m, S) => (b(), _(o(O), {\n      \"as-child\": m.asChild,\n      as: m.as,\n      \"data-menu-item\": \"\",\n      onKeydown: re(g, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: y(() => [\n        C(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Pc = /* @__PURE__ */ w({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Me(\"nav\"), s = l(), { forwardRef: r, currentElement: i } = T(), u = gt(), d = So(), c = is(u.baseId, d.value), p = xo(u.baseId, d.value), f = I(null), v = B(() => {\n      const E = s.value.map((A) => A.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && E.reverse();\n      const P = E.indexOf(u.modelValue.value), $ = E.indexOf(u.previousValue.value), R = d.value === u.modelValue.value, M = $ === E.indexOf(d.value);\n      if (!R && !M)\n        return f.value;\n      const V = (() => {\n        if (P !== $) {\n          if (R && $ !== -1)\n            return P > $ ? \"from-end\" : \"from-start\";\n          if (M && P !== -1)\n            return P > $ ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return f.value = V, V;\n    });\n    function g(h) {\n      var E, P;\n      if (n(\"focusOutside\", h), n(\"interactOutside\", h), !h.defaultPrevented) {\n        d.onContentFocusOutside();\n        const $ = h.target;\n        (P = (E = u.rootNavigationMenu) == null ? void 0 : E.value) != null && P.contains($) && h.preventDefault();\n      }\n    }\n    function m(h) {\n      var E;\n      if (n(\"pointerDownOutside\", h), !h.defaultPrevented) {\n        const P = h.target, $ = s.value.some(\n          (M) => M.contains(P)\n        ), R = u.isRootMenu && ((E = u.viewport.value) == null ? void 0 : E.contains(P));\n        ($ || R || !u.isRootMenu) && h.preventDefault();\n      }\n    }\n    ye((h) => {\n      const E = i.value;\n      if (u.isRootMenu && E) {\n        const P = () => {\n          var $;\n          u.onItemDismiss(), d.onRootContentClose(), E.contains(document.activeElement) && (($ = d.triggerRef.value) == null || $.focus());\n        };\n        E.addEventListener(ka, P), h(\n          () => E.removeEventListener(ka, P)\n        );\n      }\n    });\n    function S(h) {\n      var E, P;\n      n(\"escapeKeyDown\", h), h.defaultPrevented || (u.onItemDismiss(), (P = (E = d.triggerRef) == null ? void 0 : E.value) == null || P.focus(), d.wasEscapeCloseRef.value = !0);\n    }\n    function x(h) {\n      var M;\n      const E = h.altKey || h.ctrlKey || h.metaKey, P = h.key === \"Tab\" && !E, $ = Rn(h.currentTarget);\n      if (P) {\n        const V = document.activeElement, A = $.findIndex(\n          (H) => H === V\n        ), U = h.shiftKey ? $.slice(0, A).reverse() : $.slice(A + 1, $.length);\n        if (us(U))\n          h.preventDefault();\n        else {\n          (M = d.focusProxyRef.value) == null || M.focus();\n          return;\n        }\n      }\n      const R = $t(\n        h,\n        document.activeElement,\n        void 0,\n        { itemsArray: $, loop: !1, enableIgnoredElement: !0 }\n      );\n      R == null || R.focus();\n    }\n    function D() {\n      var E;\n      const h = new Event(ka, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      (E = i.value) == null || E.dispatchEvent(h);\n    }\n    return (h, E) => (b(), _(o(yt), k({\n      id: o(p),\n      ref: o(r),\n      \"aria-labelledby\": o(c),\n      \"data-motion\": v.value,\n      \"data-state\": o(an)(o(u).modelValue.value === o(d).value),\n      \"data-orientation\": o(u).orientation\n    }, e, {\n      onKeydown: x,\n      onEscapeKeyDown: S,\n      onPointerDownOutside: m,\n      onFocusOutside: g,\n      onDismiss: D\n    }), {\n      default: y(() => [\n        C(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), Zh = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Re(n), { forwardRef: s } = T(), r = ja(), i = gt(), u = So(), d = B(() => u.value === i.modelValue.value), c = B(() => i.viewport.value && !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : !1);\n    return (p, f) => o(r) ? (b(), _(Wt, {\n      key: 0,\n      to: o(i).viewport.value,\n      disabled: !o(i).viewport.value\n    }, [\n      Y(o(Pe), {\n        present: p.forceMount || d.value || c.value\n      }, {\n        default: y(() => [\n          Y(Pc, k({\n            ref: o(s),\n            \"data-state\": o(an)(d.value),\n            style: {\n              pointerEvents: !d.value && o(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...p.$attrs, ...e, ...o(l) }, {\n            onPointerenter: f[0] || (f[0] = (v) => o(i).onContentEnter(o(u).value)),\n            onPointerleave: f[1] || (f[1] = (v) => o(ds)(() => o(i).onContentLeave())(v)),\n            onPointerDownOutside: f[2] || (f[2] = (v) => n(\"pointerDownOutside\", v)),\n            onFocusOutside: f[3] || (f[3] = (v) => n(\"focusOutside\", v)),\n            onInteractOutside: f[4] || (f[4] = (v) => n(\"interactOutside\", v))\n          }), {\n            default: y(() => [\n              C(p.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : pe(\"\", !0);\n  }\n}), Jh = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), { injectCollection: n } = Me(\"nav\"), l = n(), s = gt(), r = I(), i = B(() => s.orientation === \"horizontal\"), u = B(() => !!s.modelValue.value), d = I();\n    function c() {\n      d.value && (r.value = {\n        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,\n        offset: i.value ? d.value.offsetLeft : d.value.offsetTop\n      });\n    }\n    return ye(() => {\n      if (!s.modelValue.value) {\n        r.value = void 0;\n        return;\n      }\n      const p = l.value;\n      d.value = p.find(\n        (f) => f.id.includes(s.modelValue.value)\n      ), c();\n    }), Ze(d, c), Ze(s.indicatorTrack, c), (p, f) => o(s).indicatorTrack.value ? (b(), _(Wt, {\n      key: 0,\n      to: o(s).indicatorTrack.value\n    }, [\n      Y(o(Pe), {\n        present: p.forceMount || u.value\n      }, {\n        default: y(() => {\n          var v, g, m, S;\n          return [\n            Y(o(O), k({\n              ref: o(e),\n              \"aria-hidden\": \"\",\n              \"data-state\": u.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": o(s).orientation,\n              \"as-child\": t.asChild,\n              as: p.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(v = r.value) == null ? void 0 : v.size}px`,\n                  transform: `translateX(${(g = r.value) == null ? void 0 : g.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(m = r.value) == null ? void 0 : m.size}px`,\n                  transform: `translateY(${(S = r.value) == null ? void 0 : S.offset}px)`\n                }\n              }\n            }, p.$attrs), {\n              default: y(() => [\n                C(p.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : pe(\"\", !0);\n  }\n}), Qh = /* @__PURE__ */ w({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    async function l(s) {\n      var r;\n      if (n(\"select\", s), await le(), !s.defaultPrevented && !s.metaKey) {\n        const i = new CustomEvent(\n          ka,\n          {\n            bubbles: !0,\n            cancelable: !0\n          }\n        );\n        (r = s.target) == null || r.dispatchEvent(i);\n      }\n    }\n    return (s, r) => (b(), _(o(O), {\n      as: s.as,\n      \"data-active\": s.active ? \"\" : void 0,\n      \"aria-current\": s.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: l\n    }, {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), ey = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(a) {\n    const t = a, e = gt(), { forwardRef: n, currentElement: l } = T();\n    return se(() => {\n      e.onIndicatorTrackChange(l.value);\n    }), (s, r) => (b(), _(o(O), {\n      ref: o(n),\n      style: { position: \"relative\" }\n    }, {\n      default: y(() => [\n        Y(o(O), k(s.$attrs, {\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"data-orientation\": o(e).orientation\n        }), {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), ty = /* @__PURE__ */ w({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = I(\"\"), r = gt(), { forwardRef: i, currentElement: u } = T(), d = I(), c = I(), { createCollection: p } = Me(\"nav\");\n    return p(d), rs({\n      ...r,\n      isRootMenu: !1,\n      modelValue: l,\n      previousValue: s,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (f) => {\n        d.value = f;\n      },\n      viewport: c,\n      onViewportChange: (f) => {\n        c.value = f;\n      },\n      onTriggerEnter: (f) => {\n        l.value = f;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (f) => {\n        l.value = f;\n      },\n      onItemDismiss: () => {\n        l.value = \"\";\n      }\n    }), (f, v) => (b(), _(o(O), {\n      ref: o(i),\n      \"data-orientation\": f.orientation,\n      \"as-child\": e.asChild,\n      as: f.as\n    }, {\n      default: y(() => [\n        C(f.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), Dc = [\"aria-owns\"], ay = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = gt(), n = So(), { forwardRef: l, currentElement: s } = T(), r = I(\"\"), i = I(\"\"), u = Dt(!1, 300), d = I(!1), c = B(() => n.value === e.modelValue.value);\n    se(() => {\n      n.triggerRef = s, r.value = is(e.baseId, n.value), i.value = xo(e.baseId, n.value);\n    });\n    function p() {\n      e.disableHoverTrigger.value || (d.value = !1, n.wasEscapeCloseRef.value = !1);\n    }\n    function f(D) {\n      if (!e.disableHoverTrigger.value && D.pointerType === \"mouse\") {\n        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(n.value), u.value = !0;\n      }\n    }\n    function v(D) {\n      if (!e.disableHoverTrigger.value && D.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = !1;\n      }\n    }\n    function g(D) {\n      D.pointerType === \"mouse\" && e.disableClickTrigger.value || u.value || (c.value ? e.onItemSelect(\"\") : e.onItemSelect(n.value), d.value = c.value);\n    }\n    function m(D) {\n      const E = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      c.value && D.key === E && (n.onEntryKeyDown(), D.preventDefault(), D.stopPropagation());\n    }\n    function S(D) {\n      n.focusProxyRef.value = Be(D);\n    }\n    function x(D) {\n      const h = document.getElementById(n.contentId), E = D.relatedTarget, P = E === s.value, $ = h == null ? void 0 : h.contains(E);\n      (P || !$) && n.onFocusProxyEnter(P ? \"start\" : \"end\");\n    }\n    return (D, h) => (b(), ce(_e, null, [\n      Y(o(O), k({\n        id: r.value,\n        ref: o(l),\n        disabled: D.disabled,\n        \"data-disabled\": D.disabled ? \"\" : void 0,\n        \"data-state\": o(an)(c.value),\n        \"aria-expanded\": c.value,\n        \"aria-controls\": i.value,\n        \"as-child\": t.asChild,\n        as: D.as\n      }, D.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: p,\n        onPointermove: f,\n        onPointerleave: v,\n        onClick: g,\n        onKeydown: m\n      }), {\n        default: y(() => [\n          C(D.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      c.value ? (b(), ce(_e, { key: 0 }, [\n        Y(o(Yt), {\n          ref: S,\n          \"aria-hidden\": \"\",\n          tabindex: 0,\n          onFocus: x\n        }),\n        o(e).viewport ? (b(), ce(\"span\", {\n          key: 0,\n          \"aria-owns\": i.value\n        }, null, 8, Dc)) : pe(\"\", !0)\n      ], 64)) : pe(\"\", !0)\n    ], 64));\n  }\n}), ny = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = T(), n = gt(), l = I(), s = B(() => !!n.modelValue.value), r = B(() => n.modelValue.value);\n    te(e, () => {\n      e.value && n.onViewportChange(e.value);\n    });\n    const i = I();\n    return te([r, s], async () => {\n      var d, c;\n      if (await le(), !e.value)\n        return;\n      const u = (c = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : c[0];\n      i.value = u;\n    }, { immediate: !0 }), Ze(i, () => {\n      i.value && (l.value = {\n        width: i.value.offsetWidth,\n        height: i.value.offsetHeight\n      });\n    }), (u, d) => (b(), _(o(Pe), {\n      present: u.forceMount || s.value\n    }, {\n      default: y(() => {\n        var c, p;\n        return [\n          Y(o(O), k(u.$attrs, {\n            ref: o(t),\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": o(an)(s.value),\n            \"data-orientation\": o(n).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !s.value && o(n).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": l.value ? `${(c = l.value) == null ? void 0 : c.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": l.value ? `${(p = l.value) == null ? void 0 : p.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (f) => o(n).onContentEnter(o(n).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (f) => o(ds)(() => o(n).onContentLeave())(f))\n          }), {\n            default: y(() => [\n              C(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction cs(a) {\n  const { disabled: t } = a, e = I(), n = ia(), l = () => window.clearTimeout(e.value), s = (f) => {\n    l(), !t.value && (n.trigger(), e.value = window.setTimeout(() => {\n      s(60);\n    }, f));\n  }, r = () => {\n    s(400);\n  }, i = () => {\n    l();\n  }, u = I(!1), d = B(() => Be(a.target) || window), c = (f) => {\n    f.button !== 0 || u.value || (f.preventDefault(), u.value = !0, r());\n  }, p = () => {\n    u.value = !1, i();\n  };\n  return je(d, \"pointerdown\", c), window && (je(window, \"pointerup\", p), je(window, \"pointercancel\", p)), {\n    isPressed: u,\n    onTrigger: n.on\n  };\n}\nfunction qo(a, t = I({})) {\n  return wl(() => new Tr(a.value, t.value));\n}\nfunction $c(a, t = I({})) {\n  return wl(() => new Rr(a.value, t.value));\n}\nfunction Yo(a, t, e) {\n  let n = a === \"+\" ? t + e : t - e;\n  if (t % 1 !== 0 || e % 1 !== 0) {\n    const l = t.toString().split(\".\"), s = e.toString().split(\".\"), r = l[1] && l[1].length || 0, i = s[1] && s[1].length || 0, u = 10 ** Math.max(r, i);\n    t = Math.round(t * u), e = Math.round(e * u), n = a === \"+\" ? t + e : t - e, n /= u;\n  }\n  return n;\n}\nconst Bc = [\"value\", \"name\", \"disabled\", \"required\"], [Eo, Ic] = Q(\"NumberFieldRoot\"), oy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"NumberFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    modelValue: {},\n    min: {},\n    max: {},\n    step: { default: 1 },\n    formatOptions: {},\n    locale: { default: \"en-US\" },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l, min: s, max: r, step: i, locale: u, formatOptions: d, id: c } = ne(e), p = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { primitiveElement: f, currentElement: v } = Ae(), g = Qe(v), m = I(), S = B(\n      () => H(p.value) === s.value || (s.value && !isNaN(p.value) ? Yo(\"-\", p.value, i.value) < s.value : !1)\n    ), x = B(\n      () => H(p.value) === r.value || (r.value && !isNaN(p.value) ? Yo(\"+\", p.value, i.value) > r.value : !1)\n    );\n    function D(N, F = 1) {\n      var z;\n      const W = R.parse(((z = m.value) == null ? void 0 : z.value) ?? \"\");\n      e.disabled || (isNaN(W) ? p.value = s.value ?? 0 : N === \"increase\" ? p.value = H(W + (i.value ?? 1) * F) : p.value = H(W - (i.value ?? 1) * F));\n    }\n    function h(N = 1) {\n      D(\"increase\", N);\n    }\n    function E(N = 1) {\n      D(\"decrease\", N);\n    }\n    function P(N) {\n      N === \"min\" && s.value !== void 0 ? p.value = H(s.value) : N === \"max\" && r.value !== void 0 && (p.value = H(r.value));\n    }\n    const $ = qo(u, d), R = $c(u, d), M = B(() => $.resolvedOptions().maximumFractionDigits > 0 ? \"decimal\" : \"numeric\"), V = qo(u, d), A = B(() => isNaN(p.value) ? \"\" : V.format(p.value));\n    function L(N) {\n      return R.isValidPartialNumber(N, s.value, r.value);\n    }\n    function U(N) {\n      m.value && (m.value.value = N);\n    }\n    function H(N) {\n      let F;\n      return i.value === void 0 || isNaN(i.value) ? F = Kt(N, s.value, r.value) : F = Ar(N, s.value, r.value, i.value), F = R.parse($.format(F)), F;\n    }\n    function J(N) {\n      const F = R.parse(N);\n      return p.value = H(F), N.length ? (isNaN(F), U(A.value)) : U(N);\n    }\n    return Ic({\n      modelValue: p,\n      handleDecrease: E,\n      handleIncrease: h,\n      handleMinMaxValue: P,\n      inputMode: M,\n      inputEl: m,\n      onInputElement: (N) => m.value = N,\n      textValue: A,\n      validate: L,\n      applyInputValue: J,\n      disabled: l,\n      max: r,\n      min: s,\n      isDecreaseDisabled: S,\n      isIncreaseDisabled: x,\n      id: c\n    }), (N, F) => (b(), ce(_e, null, [\n      Y(o(O), k(N.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: f,\n        role: \"group\",\n        as: N.as,\n        \"as-child\": N.asChild\n      }), {\n        default: y(() => [\n          C(N.$slots, \"default\", {\n            modelValue: o(p),\n            textValue: A.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\"]),\n      o(g) ? (b(), ce(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: o(p),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Bc)) : pe(\"\", !0)\n    ], 64));\n  }\n}), ly = /* @__PURE__ */ w({\n  __name: \"NumberFieldInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, { primitiveElement: e, currentElement: n } = Ae(), l = Eo();\n    function s(r) {\n      r.target === document.activeElement && (Math.abs(r.deltaY) <= Math.abs(r.deltaX) || (r.preventDefault(), r.deltaY > 0 ? l.handleIncrease() : r.deltaY < 0 && l.handleDecrease()));\n    }\n    return se(() => {\n      l.onInputElement(n.value);\n    }), (r, i) => (b(), _(o(O), k(t, {\n      id: o(l).id.value,\n      ref_key: \"primitiveElement\",\n      ref: e,\n      role: \"spinbutton\",\n      type: \"text\",\n      tabindex: \"0\",\n      value: o(l).textValue.value,\n      inputmode: o(l).inputMode.value,\n      disabled: o(l).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(l).disabled.value ? \"\" : void 0,\n      autocomplete: \"off\",\n      autocorrect: \"off\",\n      spellcheck: \"false\",\n      \"aria-roledescription\": \"Number field\",\n      \"aria-valuenow\": o(l).modelValue.value,\n      \"aria-valuemin\": o(l).min.value,\n      \"aria-valuemax\": o(l).max.value,\n      onKeydown: [\n        i[0] || (i[0] = re(ie((u) => o(l).handleIncrease(), [\"prevent\"]), [\"up\"])),\n        i[1] || (i[1] = re(ie((u) => o(l).handleDecrease(), [\"prevent\"]), [\"down\"])),\n        i[2] || (i[2] = re(ie((u) => o(l).handleIncrease(10), [\"prevent\"]), [\"page-up\"])),\n        i[3] || (i[3] = re(ie((u) => o(l).handleDecrease(10), [\"prevent\"]), [\"page-down\"])),\n        i[4] || (i[4] = re(ie((u) => o(l).handleMinMaxValue(\"min\"), [\"prevent\"]), [\"home\"])),\n        i[5] || (i[5] = re(ie((u) => o(l).handleMinMaxValue(\"max\"), [\"prevent\"]), [\"end\"]))\n      ],\n      onWheel: s,\n      onBeforeinput: i[6] || (i[6] = (u) => {\n        const d = u.target;\n        let c = d.value.slice(0, d.selectionStart ?? void 0) + (u.data ?? \"\") + d.value.slice(d.selectionEnd ?? void 0);\n        o(l).validate(c) || u.preventDefault();\n      }),\n      onBlur: i[7] || (i[7] = (u) => {\n        var d;\n        return o(l).applyInputValue((d = u.target) == null ? void 0 : d.value);\n      })\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"value\", \"inputmode\", \"disabled\", \"data-disabled\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\"]));\n  }\n}), sy = /* @__PURE__ */ w({\n  __name: \"NumberFieldIncrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Eo(), n = B(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isIncreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Ae(), { isPressed: r, onTrigger: i } = cs({ target: s, disabled: n });\n    return i(() => {\n      e.handleIncrease();\n    }), (u, d) => (b(), _(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Increase\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ie(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), ry = /* @__PURE__ */ w({\n  __name: \"NumberFieldDecrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Eo(), n = B(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isDecreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Ae(), { isPressed: r, onTrigger: i } = cs({ target: s, disabled: n });\n    return i(() => {\n      e.handleDecrease();\n    }), (u, d) => (b(), _(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Decrease\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ie(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), [Qt, Tc] = Q(\"PaginationRoot\"), iy = /* @__PURE__ */ w({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { siblingCount: l, disabled: s, showEdges: r } = ne(e);\n    T();\n    const i = ae(e, \"page\", n, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = B(() => Math.max(1, Math.ceil(e.total / e.itemsPerPage)));\n    return Tc({\n      page: i,\n      onPageChange(d) {\n        i.value = d;\n      },\n      pageCount: u,\n      siblingCount: l,\n      disabled: s,\n      showEdges: r\n    }), (d, c) => (b(), _(o(O), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: y(() => [\n        C(d.$slots, \"default\", {\n          page: o(i),\n          pageCount: u.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), uy = /* @__PURE__ */ w({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), k(t, { \"data-type\": \"ellipsis\" }), {\n      default: y(() => [\n        C(e.$slots, \"default\", {}, () => [\n          ve(\"…\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dy = /* @__PURE__ */ w({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Qt();\n    return T(), (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"First Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: o(e).page.value === 1 || o(e).disabled.value,\n      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(1))\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), cy = /* @__PURE__ */ w({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Qt();\n    return T(), (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"Last Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: o(e).page.value === o(e).pageCount.value || o(e).disabled.value,\n      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(o(e).pageCount.value))\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction rt(a, t) {\n  const e = t - a + 1;\n  return Array.from({ length: e }, (n, l) => l + a);\n}\nfunction Rc(a) {\n  return a.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst Ba = \"ellipsis\";\nfunction Ac(a, t, e, n) {\n  const s = t, r = Math.max(a - e, 1), i = Math.min(a + e, s);\n  if (n) {\n    const d = Math.min(2 * e + 5, t) - 2, c = r > 3 && Math.abs(s - d - 1 + 1) > 2 && Math.abs(r - 1) > 2, p = i < s - 2 && Math.abs(s - d) > 2 && Math.abs(s - i) > 2;\n    if (!c && p)\n      return [...rt(1, d), Ba, s];\n    if (c && !p) {\n      const v = rt(s - d + 1, s);\n      return [1, Ba, ...v];\n    }\n    if (c && p) {\n      const v = rt(r, i);\n      return [1, Ba, ...v, Ba, s];\n    }\n    return rt(1, s);\n  } else {\n    const u = e * 2 + 1;\n    return t < u ? rt(1, s) : a <= e + 1 ? rt(1, u) : t - a <= e ? rt(t - u + 1, s) : rt(r, i);\n  }\n}\nconst py = /* @__PURE__ */ w({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Qt(), n = B(() => Rc(\n      Ac(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (l, s) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(l.$slots, \"default\", { items: n.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fy = /* @__PURE__ */ w({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Qt(), n = B(() => e.page.value === t.value);\n    return (l, s) => (b(), _(o(O), k(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${l.value}`,\n      \"aria-current\": n.value ? \"page\" : void 0,\n      \"data-selected\": n.value ? \"true\" : void 0,\n      disabled: o(e).disabled.value,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      onClick: s[0] || (s[0] = (r) => o(e).onPageChange(l.value))\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve($e(l.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), vy = /* @__PURE__ */ w({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Qt();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"Next Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: o(e).page.value === o(e).pageCount.value || o(e).disabled.value,\n      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(o(e).page.value + 1))\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), my = /* @__PURE__ */ w({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Qt();\n    return (n, l) => {\n      var s;\n      return b(), _(o(O), k(t, {\n        \"aria-label\": \"Previous Page\",\n        type: n.as === \"button\" ? \"button\" : void 0,\n        disabled: o(e).page.value === 1 || ((s = o(e).disabled) == null ? void 0 : s.value),\n        onClick: l[0] || (l[0] = (r) => o(e).onPageChange(o(e).page.value - 1))\n      }), {\n        default: y(() => [\n          C(n.$slots, \"default\", {}, () => [\n            ve(\"Prev page\")\n          ])\n        ]),\n        _: 3\n      }, 16, [\"type\", \"disabled\"]);\n    };\n  }\n}), Oc = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [kc, Mc] = Q(\"PinInputRoot\"), hy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { mask: l, otp: s, placeholder: r, type: i, disabled: u, dir: d } = ne(e), { forwardRef: c } = T(), p = be(d), f = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), v = I(/* @__PURE__ */ new Set());\n    function g(S) {\n      v.value.add(S);\n    }\n    const m = B(() => f.value.filter((x) => !!x).length === v.value.size);\n    return te(f, () => {\n      m.value && n(\"complete\", f.value);\n    }, { deep: !0 }), Mc({\n      modelValue: f,\n      mask: l,\n      otp: s,\n      placeholder: r,\n      type: i,\n      dir: p,\n      disabled: u,\n      isCompleted: m,\n      inputElements: v,\n      onInputElementChange: g\n    }), (S, x) => (b(), ce(_e, null, [\n      Y(o(O), k(S.$attrs, {\n        ref: o(c),\n        dir: o(p),\n        \"data-complete\": m.value ? \"\" : void 0,\n        \"data-disabled\": o(u) ? \"\" : void 0\n      }), {\n        default: y(() => [\n          C(S.$slots, \"default\", { modelValue: o(f) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      Ue(\"input\", {\n        id: S.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: o(f).join(\"\"),\n        name: S.name,\n        disabled: o(u),\n        required: S.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: x[0] || (x[0] = (D) => {\n          var h, E;\n          return (E = (h = Array.from(v.value)) == null ? void 0 : h[0]) == null ? void 0 : E.focus();\n        })\n      }, null, 40, Oc)\n    ], 64));\n  }\n}), Vc = [\"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\"], yy = /* @__PURE__ */ w({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = kc(), n = B(() => Array.from(e.inputElements.value)), l = B(() => t.disabled || e.disabled.value), s = B(() => e.otp.value), r = B(() => e.type.value === \"number\"), i = B(() => e.mask.value), u = I();\n    function d(h) {\n      var $;\n      const E = h.target;\n      if (((($ = h.data) == null ? void 0 : $.length) ?? 0) > 1) {\n        S(E.value);\n        return;\n      }\n      if (r.value && !/^\\d*$/.test(E.value)) {\n        E.value = E.value.replace(/\\D/g, \"\");\n        return;\n      }\n      E.value = E.value.slice(-1), D(t.index, E.value);\n      const P = n.value[t.index + 1];\n      P && P.focus();\n    }\n    function c(h) {\n      $t(h, document.activeElement, void 0, {\n        itemsArray: n.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function p(h) {\n      if (h.preventDefault(), h.target.value)\n        D(t.index, \"\");\n      else {\n        const $ = n.value[t.index - 1];\n        $ && ($.focus(), D(t.index - 1, \"\"));\n      }\n    }\n    function f(h) {\n      h.key === \"Delete\" && (h.preventDefault(), D(t.index, \"\"));\n    }\n    function v(h) {\n      const E = h.target;\n      E.setSelectionRange(1, 1), E.value || (E.placeholder = \"\");\n    }\n    function g(h) {\n      const E = h.target;\n      le(() => {\n        E.value || (E.placeholder = e.placeholder.value);\n      });\n    }\n    function m(h) {\n      h.preventDefault();\n      const E = h.clipboardData;\n      if (!E)\n        return;\n      const P = E.getData(\"text\");\n      S(P);\n    }\n    function S(h) {\n      var R;\n      const E = [...e.modelValue.value], P = h.length >= n.value.length ? 0 : t.index, $ = Math.min(P + h.length, n.value.length);\n      for (let M = P; M < $; M++) {\n        const V = n.value[M], A = h[M - P];\n        r.value && !/^\\d*$/.test(A) || (E[M] = A, V.focus());\n      }\n      e.modelValue.value = E, (R = n.value[$]) == null || R.focus();\n    }\n    function x(h) {\n      let E = h.length - 1;\n      for (; E >= 0 && h[E] === \"\"; )\n        h.pop(), E--;\n      return h;\n    }\n    function D(h, E) {\n      const P = [...e.modelValue.value];\n      P[h] = E, e.modelValue.value = x(P);\n    }\n    return se(() => {\n      e.onInputElementChange(u.value);\n    }), Ie(() => {\n      var h;\n      (h = e.inputElements) == null || h.value.delete(u.value);\n    }), (h, E) => (b(), ce(\"input\", {\n      ref_key: \"inputRef\",\n      ref: u,\n      autocapitalize: \"none\",\n      autocomplete: s.value ? \"one-time-code\" : \"false\",\n      type: i.value ? \"password\" : \"text\",\n      inputmode: r.value ? \"numeric\" : \"text\",\n      pattern: r.value ? \"[0-9]*\" : void 0,\n      placeholder: o(e).placeholder.value,\n      value: o(e).modelValue.value.at(h.index),\n      disabled: l.value,\n      \"data-disabled\": l.value ? \"\" : void 0,\n      \"data-complete\": o(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${h.index + 1} of ${n.value.length}`,\n      onInput: E[0] || (E[0] = (P) => d(P)),\n      onKeydown: [\n        re(c, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        re(p, [\"backspace\"]),\n        re(f, [\"delete\"])\n      ],\n      onFocus: v,\n      onBlur: g,\n      onPaste: m\n    }, null, 40, Vc));\n  }\n}), [Mt, Fc] = Q(\"PopoverRoot\"), ps = /* @__PURE__ */ w({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l } = ne(e), s = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = I(), i = I(!1);\n    return Fc({\n      contentId: \"\",\n      modal: l,\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerElement: r,\n      hasCustomAnchor: i\n    }), (u, d) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(u.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }));\n  }\n}), fs = /* @__PURE__ */ w({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Mt(), { forwardRef: n, currentElement: l } = T();\n    return se(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), _(Ge(o(e).hasCustomAnchor.value ? o(O) : o(Tt)), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).contentId,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          as: s.as,\n          \"as-child\": t.asChild,\n          onClick: o(e).onOpenToggle\n        }, {\n          default: y(() => [\n            C(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), vs = /* @__PURE__ */ w({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ms = /* @__PURE__ */ w({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Bt(e), { forwardRef: s } = T(), r = Mt();\n    return Gn(), (i, u) => (b(), _(o(Ya), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        Y(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: u[0] || (u[0] = (d) => n(\"pointerDownOutside\", d)),\n          onInteractOutside: u[1] || (u[1] = (d) => n(\"interactOutside\", d)),\n          onEscapeKeyDown: u[2] || (u[2] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[3] || (u[3] = (d) => n(\"focusOutside\", d)),\n          onDismiss: u[4] || (u[4] = (d) => o(r).onOpenChange(!1))\n        }, {\n          default: y(() => [\n            Y(o(Pt), k(o(l), {\n              id: o(r).contentId,\n              ref: o(s),\n              \"data-state\": o(r).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: y(() => [\n                C(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Lc = /* @__PURE__ */ w({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Mt(), s = I(!1);\n    ha(!0);\n    const r = xe(e, n), { forwardRef: i, currentElement: u } = T();\n    return ya(u), (d, c) => (b(), _(ms, k(o(r), {\n      ref: o(i),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: c[0] || (c[0] = ie(\n        (p) => {\n          var f;\n          n(\"closeAutoFocus\", p), s.value || (f = o(l).triggerElement.value) == null || f.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: c[1] || (c[1] = (p) => {\n        n(\"pointerDownOutside\", p);\n        const f = p.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n        s.value = g;\n      }),\n      onFocusOutside: c[2] || (c[2] = ie(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), Nc = /* @__PURE__ */ w({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Mt(), s = I(!1), r = I(!1), i = xe(e, n);\n    return (u, d) => (b(), _(ms, k(o(i), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (s.value || (p = o(l).triggerElement.value) == null || p.focus(), c.preventDefault()), s.value = !1, r.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (c) => {\n        var v;\n        n(\"interactOutside\", c), c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (r.value = !0));\n        const p = c.target;\n        ((v = o(l).triggerElement.value) == null ? void 0 : v.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && r.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        C(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hs = /* @__PURE__ */ w({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Mt(), s = xe(e, n), { forwardRef: r } = T();\n    return l.contentId || (l.contentId = me(void 0, \"radix-vue-popover-content\")), (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), _(Lc, k({ key: 0 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), _(Nc, k({ key: 1 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ys = /* @__PURE__ */ w({\n  __name: \"PopoverArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(qt), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gs = /* @__PURE__ */ w({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Mt();\n    return (n, l) => (b(), _(o(O), {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      as: n.as,\n      \"as-child\": t.asChild,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }, {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), bs = /* @__PURE__ */ w({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = Mt();\n    return pl(() => {\n      e.hasCustomAnchor.value = !0;\n    }), Ie(() => {\n      e.hasCustomAnchor.value = !1;\n    }), (n, l) => (b(), _(o(Tt), K(j(t)), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), da = 100, [zc, Kc] = Q(\"ProgressRoot\"), Po = (a) => typeof a == \"number\";\nfunction Hc(a, t) {\n  return Nt(a) || Po(a) && !Number.isNaN(a) && a <= t && a >= 0 ? a : (console.error(`Invalid prop \\`value\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${da} if no \\`max\\` prop is set)\n  - \\`null\\`  or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction Wc(a) {\n  return Po(a) && !Number.isNaN(a) && a > 0 ? a : (console.error(\n    `Invalid prop \\`max\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${da}\\`.`\n  ), da);\n}\nconst gy = /* @__PURE__ */ w({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: da },\n    getValueLabel: { type: Function, default: (a, t) => `${Math.round(a / t * da)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = ae(e, \"modelValue\", n, {\n      passive: e.modelValue === void 0\n    }), s = ae(e, \"max\", n, {\n      passive: e.max === void 0\n    });\n    te(\n      () => l.value,\n      async (i) => {\n        const u = Hc(i, e.max);\n        u !== i && (await le(), l.value = u);\n      },\n      { immediate: !0 }\n    ), te(\n      () => e.max,\n      (i) => {\n        const u = Wc(e.max);\n        u !== i && (s.value = u);\n      },\n      { immediate: !0 }\n    );\n    const r = B(() => Nt(l.value) ? \"indeterminate\" : l.value === s.value ? \"complete\" : \"loading\");\n    return Kc({\n      modelValue: l,\n      max: s,\n      progressState: r\n    }), (i, u) => (b(), _(o(O), {\n      \"as-child\": i.asChild,\n      as: i.as,\n      \"aria-valuemax\": o(s),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": Po(o(l)) ? o(l) : void 0,\n      \"aria-valuetext\": i.getValueLabel(o(l), o(s)),\n      \"aria-label\": i.getValueLabel(o(l), o(s)),\n      role: \"progressbar\",\n      \"data-state\": r.value,\n      \"data-value\": o(l) ?? void 0,\n      \"data-max\": o(s)\n    }, {\n      default: y(() => [\n        C(i.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), by = /* @__PURE__ */ w({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = zc();\n    return T(), (n, l) => {\n      var s;\n      return b(), _(o(O), k(t, {\n        \"data-state\": o(e).progressState.value,\n        \"data-value\": ((s = o(e).modelValue) == null ? void 0 : s.value) ?? void 0,\n        \"data-max\": o(e).max.value\n      }), {\n        default: y(() => [\n          C(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [jc, Uc] = Q(\"RadioGroupRoot\"), Cy = /* @__PURE__ */ w({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: !1 },\n    name: {},\n    required: { type: Boolean, default: !1 },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = T(), s = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: r, loop: i, orientation: u, name: d, required: c, dir: p } = ne(e), f = be(p);\n    return Uc({\n      modelValue: s,\n      changeModelValue: (v) => {\n        s.value = v;\n      },\n      disabled: r,\n      loop: i,\n      orientation: u,\n      name: d == null ? void 0 : d.value,\n      required: c\n    }), (v, g) => (b(), _(o(At), {\n      \"as-child\": \"\",\n      orientation: o(u),\n      dir: o(f),\n      loop: o(i)\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(l),\n          role: \"radiogroup\",\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"as-child\": v.asChild,\n          as: v.as,\n          required: o(c),\n          \"aria-orientation\": o(u),\n          \"aria-required\": o(c),\n          dir: o(f),\n          name: o(d)\n        }, {\n          default: y(() => [\n            C(v.$slots, \"default\", { modelValue: o(s) })\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Gc = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], qc = /* @__PURE__ */ w({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ae(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: s } = ne(e), { forwardRef: r, currentElement: i } = T(), u = Qe(i), d = B(() => {\n      var p;\n      return e.id && i.value ? ((p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText) ?? e.value : void 0;\n    });\n    function c(p) {\n      l.value = !0, u.value && p.stopPropagation();\n    }\n    return (p, f) => (b(), _(o(O), k(p.$attrs, {\n      id: p.id,\n      ref: o(r),\n      role: \"radio\",\n      type: p.as === \"button\" ? \"button\" : void 0,\n      as: p.as,\n      \"aria-checked\": o(l),\n      \"aria-label\": d.value,\n      \"as-child\": p.asChild,\n      disabled: p.disabled ? \"\" : void 0,\n      \"data-state\": o(l) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": p.disabled ? \"\" : void 0,\n      value: o(s),\n      required: p.required,\n      name: p.name,\n      onClick: ie(c, [\"stop\"])\n    }), {\n      default: y(() => [\n        C(p.$slots, \"default\", { checked: o(l) }),\n        o(u) ? (b(), ce(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"\",\n          value: o(s),\n          checked: !!o(l),\n          name: p.name,\n          disabled: p.disabled,\n          required: p.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          }\n        }, null, 8, Gc)) : pe(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\"]));\n  }\n}), [Yc, Xc] = Q(\"RadioGroupItem\"), wy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = T(), l = jc(), s = B(() => l.disabled.value || t.disabled), r = B(() => l.required.value || t.required), i = B(() => {\n      var p;\n      return ((p = l.modelValue) == null ? void 0 : p.value) === t.value;\n    });\n    Xc({ disabled: s, checked: i });\n    const u = I(!1), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    je(\"keydown\", (p) => {\n      d.includes(p.key) && (u.value = !0);\n    }), je(\"keyup\", () => {\n      u.value = !1;\n    });\n    function c() {\n      setTimeout(() => {\n        var p;\n        u.value && ((p = n.value) == null || p.click());\n      }, 0);\n    }\n    return (p, f) => (b(), _(o(Ot), {\n      checked: i.value,\n      disabled: s.value,\n      \"as-child\": \"\",\n      focusable: !s.value,\n      active: i.value\n    }, {\n      default: y(() => [\n        Y(qc, k({ ...p.$attrs, ...t }, {\n          ref: o(e),\n          checked: i.value,\n          required: r.value,\n          disabled: s.value,\n          \"onUpdate:checked\": f[0] || (f[0] = (v) => o(l).changeModelValue(p.value)),\n          onKeydown: f[1] || (f[1] = re(ie(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: c\n        }), {\n          default: y(() => [\n            C(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\", \"disabled\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), _y = /* @__PURE__ */ w({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = T(), e = Yc();\n    return (n, l) => (b(), _(o(Pe), {\n      present: n.forceMount || o(e).checked.value\n    }, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(t),\n          \"data-state\": o(e).checked.value ? \"checked\" : \"unchecked\",\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction Zc(a) {\n  const t = B(() => a.start.value ? !!a.isDateDisabled(a.start.value) : !1), e = B(() => a.end.value ? !!a.isDateDisabled(a.end.value) : !1), n = B(\n    () => t.value || e.value ? !1 : !!(a.start.value && a.end.value && ke(a.end.value, a.start.value))\n  ), l = (c) => a.start.value ? Te(a.start.value, c) : !1, s = (c) => a.end.value ? Te(a.end.value, c) : !1, r = (c) => a.start.value && Te(a.start.value, c) || a.end.value && Te(a.end.value, c) ? !0 : a.end.value && a.start.value ? wr(c, a.start.value, a.end.value) : !1, i = B(() => {\n    if (a.start.value && a.end.value || !a.start.value || !a.focusedValue.value)\n      return null;\n    const c = ke(a.start.value, a.focusedValue.value), p = c ? a.start.value : a.focusedValue.value, f = c ? a.focusedValue.value : a.start.value;\n    return Te(p.add({ days: 1 }), f) ? {\n      start: p,\n      end: f\n    } : hl(p, f, a.isDateUnavailable, a.isDateDisabled) ? {\n      start: p,\n      end: f\n    } : null;\n  });\n  return {\n    isInvalid: n,\n    isSelected: r,\n    highlightedRange: i,\n    isSelectionStart: l,\n    isSelectionEnd: s,\n    isHighlightedStart: (c) => !i.value || !i.value.start ? !1 : Te(i.value.start, c),\n    isHighlightedEnd: (c) => !i.value || !i.value.end ? !1 : Te(i.value.end, c)\n  };\n}\nconst Jc = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, Qc = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [ea, ep] = Q(\"RangeCalendarRoot\"), tp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarRoot\",\n  props: {\n    defaultPlaceholder: {},\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    modelValue: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      disabled: l,\n      readonly: s,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateUnavailable: v,\n      isDateDisabled: g,\n      calendarLabel: m,\n      maxValue: S,\n      minValue: x,\n      locale: D,\n      dir: h,\n      nextPage: E,\n      prevPage: P\n    } = ne(e), { primitiveElement: $, currentElement: R } = Ae(), M = be(h), V = I(), A = I(), L = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), U = jt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: L.value.start\n    }), H = I(L.value.start), J = I(L.value.end), N = ae(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    });\n    function F(we) {\n      N.value = we.copy();\n    }\n    const {\n      fullCalendarLabel: W,\n      headingValue: z,\n      isDateDisabled: X,\n      isDateUnavailable: G,\n      isNextButtonDisabled: Z,\n      isPrevButtonDisabled: ee,\n      grid: fe,\n      weekdays: q,\n      isOutsideVisibleView: oe,\n      nextPage: he,\n      prevPage: Ce,\n      formatter: ge\n    } = Wl({\n      locale: D,\n      placeholder: N,\n      weekStartsOn: u,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      minValue: x,\n      maxValue: S,\n      disabled: l,\n      weekdayFormat: d,\n      pagedNavigation: i,\n      isDateDisabled: g.value,\n      isDateUnavailable: v.value,\n      calendarLabel: m,\n      nextPage: E,\n      prevPage: P\n    }), {\n      isInvalid: De,\n      isSelected: ue,\n      highlightedRange: Se,\n      isSelectionStart: Ve,\n      isSelectionEnd: Ke,\n      isHighlightedStart: aa,\n      isHighlightedEnd: ir\n    } = Zc({\n      start: H,\n      end: J,\n      isDateDisabled: X,\n      isDateUnavailable: G,\n      focusedValue: A\n    });\n    return te(L, (we) => {\n      we.start && we.end && (H.value && !Ee(H.value, we.start) && (H.value = we.start.copy()), J.value && !Ee(J.value, we.end) && (J.value = we.end.copy()));\n    }), te(H, (we) => {\n      we && !Ee(we, N.value) && F(we), n(\"update:startValue\", we);\n    }), te([H, J], ([we, ot]) => {\n      const He = L.value;\n      if (!(He && He.start && He.end && we && ot && Ee(He.start, we) && Ee(He.end, ot)))\n        if (we && ot) {\n          if (He.start && He.end && Ee(He.start, we) && Ee(He.end, ot))\n            return;\n          ke(ot, we) ? L.value = {\n            start: ot.copy(),\n            end: we.copy()\n          } : L.value = {\n            start: we.copy(),\n            end: ot.copy()\n          };\n        } else He.start && He.end && (L.value = {\n          start: void 0,\n          end: void 0\n        });\n    }), ep({\n      isDateUnavailable: G,\n      startValue: H,\n      endValue: J,\n      formatter: ge,\n      modelValue: L,\n      placeholder: N,\n      disabled: l,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: s,\n      preventDeselect: f,\n      fullCalendarLabel: W,\n      headingValue: z,\n      isInvalid: De,\n      isDateDisabled: X,\n      highlightedRange: Se,\n      focusedValue: A,\n      lastPressedDateValue: V,\n      isSelected: ue,\n      isSelectionEnd: Ke,\n      isSelectionStart: Ve,\n      isNextButtonDisabled: Z,\n      isPrevButtonDisabled: ee,\n      isOutsideVisibleView: oe,\n      nextPage: he,\n      prevPage: Ce,\n      parentElement: R,\n      onPlaceholderChange: F,\n      locale: D,\n      dir: M,\n      isHighlightedStart: aa,\n      isHighlightedEnd: ir\n    }), se(() => {\n      r.value && Cl(R.value);\n    }), (we, ot) => (b(), _(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: $,\n      as: we.as,\n      \"as-child\": we.asChild,\n      role: \"application\",\n      \"aria-label\": o(W),\n      \"data-readonly\": o(s) ? \"\" : void 0,\n      \"data-disabled\": o(l) ? \"\" : void 0,\n      \"data-invalid\": o(De) ? \"\" : void 0,\n      dir: o(M)\n    }, {\n      default: y(() => [\n        Ue(\"div\", Jc, [\n          Ue(\"div\", Qc, $e(o(W)), 1)\n        ]),\n        C(we.$slots, \"default\", {\n          date: o(N),\n          grid: o(fe),\n          weekDays: o(q),\n          weekStartsOn: o(u),\n          locale: o(D),\n          fixedWeeks: o(c)\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), ap = /* @__PURE__ */ w({\n  __name: \"RangeCalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), np = /* @__PURE__ */ w({\n  __name: \"RangeCalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), _(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          ve($e(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), op = /* @__PURE__ */ w({\n  __name: \"RangeCalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), _(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": o(e).readonly ? !0 : void 0,\n      \"aria-disabled\": o(e).disabled ? !0 : void 0,\n      \"data-readonly\": o(e).readonly ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled ? \"\" : void 0\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), lp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = ea();\n    return (e, n) => {\n      var l, s;\n      return b(), _(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          C(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), sp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarNext\",\n  props: {\n    step: {},\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = ea();\n    return (l, s) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), ip = /* @__PURE__ */ w({\n  __name: \"RangeCalendarPrev\",\n  props: {\n    step: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = ea();\n    return (l, s) => (b(), _(o(O), k(t, {\n      \"aria-label\": \"Previous page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\", {}, () => [\n          ve(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), up = /* @__PURE__ */ w({\n  __name: \"RangeCalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pp = /* @__PURE__ */ w({\n  __name: \"RangeCalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = ea(), n = et(), { primitiveElement: l, currentElement: s } = Ae(), r = B(() => e.formatter.custom(Le(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), i = B(() => e.isDateDisabled(t.day)), u = B(() => {\n      var V;\n      return (V = e.isDateUnavailable) == null ? void 0 : V.call(e, t.day);\n    }), d = B(() => e.isSelected(t.day)), c = B(() => e.isSelectionStart(t.day)), p = B(() => e.isSelectionEnd(t.day)), f = B(() => e.isHighlightedStart(t.day)), v = B(() => e.isHighlightedEnd(t.day)), g = B(() => e.highlightedRange.value ? _r(t.day, e.highlightedRange.value.start, e.highlightedRange.value.end) : !1), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])\", S = B(() => fl(t.day, zn())), x = B(() => !vl(t.day, t.month)), D = B(\n      () => e.isOutsideVisibleView(t.day)\n    ), h = B(() => t.day.day.toLocaleString(e.locale.value)), E = B(() => !e.disabled.value && Te(t.day, e.placeholder.value));\n    function P(V) {\n      var A;\n      if (!e.readonly.value && !(e.isDateDisabled(V) || (A = e.isDateUnavailable) != null && A.call(e, V))) {\n        if (e.lastPressedDateValue.value = V.copy(), e.startValue.value && e.highlightedRange.value === null) {\n          if (Te(V, e.startValue.value) && !e.preventDeselect.value && !e.endValue.value) {\n            e.startValue.value = void 0, e.onPlaceholderChange(V);\n            return;\n          } else if (!e.endValue.value) {\n            e.lastPressedDateValue.value && Te(e.lastPressedDateValue.value, V) && (e.startValue.value = V.copy());\n            return;\n          }\n        }\n        if (e.startValue.value && Te(e.startValue.value, V) && !e.preventDeselect.value && !e.endValue.value) {\n          e.startValue.value = void 0, e.onPlaceholderChange(V);\n          return;\n        }\n        e.startValue.value ? e.endValue.value ? e.endValue.value && e.startValue.value && (e.endValue.value = void 0, e.startValue.value = V.copy()) : e.endValue.value = V.copy() : e.startValue.value = V.copy();\n      }\n    }\n    function $() {\n      P(t.day);\n    }\n    function R() {\n      var V;\n      e.isDateDisabled(t.day) || (V = e.isDateUnavailable) != null && V.call(e, t.day) || (e.focusedValue.value = t.day.copy());\n    }\n    function M(V) {\n      V.preventDefault(), V.stopPropagation();\n      const A = e.parentElement.value, L = A ? Array.from(A.querySelectorAll(m)) : [];\n      let H = L.indexOf(s.value);\n      const J = 7, N = e.dir.value === \"rtl\" ? -1 : 1;\n      switch (V.code) {\n        case n.ARROW_RIGHT:\n          H += N;\n          break;\n        case n.ARROW_LEFT:\n          H -= N;\n          break;\n        case n.ARROW_UP:\n          H -= J;\n          break;\n        case n.ARROW_DOWN:\n          H += J;\n          break;\n        case n.ENTER:\n        case n.SPACE_CODE:\n          P(t.day);\n          return;\n        default:\n          return;\n      }\n      if (H >= 0 && H < L.length) {\n        L[H].focus();\n        return;\n      }\n      if (H < 0) {\n        if (e.isPrevButtonDisabled(\"month\"))\n          return;\n        e.prevPage(), le(() => {\n          const F = A ? Array.from(A.querySelectorAll(m)) : [];\n          F[F.length - Math.abs(H)].focus();\n        });\n        return;\n      }\n      if (H >= L.length) {\n        if (e.isNextButtonDisabled(\"month\"))\n          return;\n        e.nextPage(), le(() => {\n          (A ? Array.from(A.querySelectorAll(m)) : [])[H - L.length].focus();\n        });\n      }\n    }\n    return (V, A) => (b(), _(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": r.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-selected\": d.value ? !0 : void 0,\n      \"aria-disabled\": x.value || i.value || u.value ? !0 : void 0,\n      \"data-highlighted\": g.value ? \"\" : void 0,\n      \"data-selection-start\": c.value ? !0 : void 0,\n      \"data-selection-end\": p.value ? !0 : void 0,\n      \"data-highlighted-start\": f.value ? !0 : void 0,\n      \"data-highlighted-end\": v.value ? !0 : void 0,\n      \"data-selected\": d.value ? !0 : void 0,\n      \"data-outside-visible-view\": D.value ? \"\" : void 0,\n      \"data-value\": V.day.toString(),\n      \"data-disabled\": i.value || x.value ? \"\" : void 0,\n      \"data-unavailable\": u.value ? \"\" : void 0,\n      \"data-today\": S.value ? \"\" : void 0,\n      \"data-outside-month\": x.value ? \"\" : void 0,\n      \"data-focused\": E.value ? \"\" : void 0,\n      tabindex: E.value ? 0 : x.value || i.value ? void 0 : -1,\n      onClick: $,\n      onFocusin: R,\n      onMouseenter: R,\n      onKeydown: re(M, [\"up\", \"down\", \"left\", \"right\", \"enter\", \"space\"])\n    }), {\n      default: y(() => [\n        C(V.$slots, \"default\", { dayValue: h.value }, () => [\n          ve($e(h.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-selected\", \"aria-disabled\", \"data-highlighted\", \"data-selection-start\", \"data-selection-end\", \"data-highlighted-start\", \"data-highlighted-end\", \"data-selected\", \"data-outside-visible-view\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-month\", \"data-focused\", \"tabindex\"]));\n  }\n}), [ze, fp] = Q(\"ScrollAreaRoot\"), xy = /* @__PURE__ */ w({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = I(0), l = I(0), s = I(), r = I(), i = I(), u = I(), d = I(!1), c = I(!1), { type: p, dir: f, scrollHideDelay: v } = ne(e), g = be(f);\n    function m() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0\n      });\n    }\n    function S() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0,\n        left: 0\n      });\n    }\n    t({\n      /** Viewport element within ScrollArea */\n      viewport: s,\n      /** Scroll viewport to top */\n      scrollTop: m,\n      /** Scroll viewport to top-left */\n      scrollTopLeft: S\n    });\n    const { forwardRef: x, currentElement: D } = T();\n    return fp({\n      type: p,\n      dir: g,\n      scrollHideDelay: v,\n      scrollArea: D,\n      viewport: s,\n      onViewportChange: (h) => {\n        s.value = h || void 0;\n      },\n      content: r,\n      onContentChange: (h) => {\n        r.value = h;\n      },\n      scrollbarX: i,\n      scrollbarXEnabled: d,\n      scrollbarY: u,\n      scrollbarYEnabled: c,\n      onScrollbarXChange: (h) => {\n        i.value = h || void 0;\n      },\n      onScrollbarYChange: (h) => {\n        u.value = h || void 0;\n      },\n      onScrollbarXEnabledChange: (h) => {\n        d.value = h;\n      },\n      onScrollbarYEnabledChange: (h) => {\n        c.value = h;\n      },\n      onCornerWidthChange: (h) => {\n        n.value = h;\n      },\n      onCornerHeightChange: (h) => {\n        l.value = h;\n      }\n    }), (h, E) => (b(), _(o(O), {\n      ref: o(x),\n      \"as-child\": e.asChild,\n      as: h.as,\n      dir: o(g),\n      style: Oe({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${n.value}px`,\n        \"--radix-scroll-area-corner-height\": `${l.value}px`\n      })\n    }, {\n      default: y(() => [\n        C(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), Sy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, { nonce: n } = ne(e), l = Xa(n), s = ze(), r = I();\n    se(() => {\n      s.onViewportChange(r.value), s.onContentChange(u.value);\n    }), t({\n      viewportElement: r\n    });\n    const { forwardRef: i, currentElement: u } = T();\n    return (d, c) => (b(), ce(_e, null, [\n      Ue(\"div\", k({\n        ref_key: \"viewportElement\",\n        ref: r,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: o(s).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: o(s).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, d.$attrs, { tabindex: 0 }), [\n        Y(o(O), {\n          ref: o(i),\n          style: { minWidth: \"100%\", display: \"table\" },\n          \"as-child\": e.asChild,\n          as: d.as\n        }, {\n          default: y(() => [\n            C(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ], 16),\n      Y(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ve(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nfunction Cs(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction nn(a) {\n  const t = ws(a.viewport, a.content), e = a.scrollbar.paddingStart + a.scrollbar.paddingEnd, n = (a.scrollbar.size - e) * t;\n  return Math.max(n, 18);\n}\nfunction ws(a, t) {\n  const e = a / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction vp(a, t = () => {\n}) {\n  let e = { left: a.scrollLeft, top: a.scrollTop }, n = 0;\n  return function l() {\n    const s = { left: a.scrollLeft, top: a.scrollTop }, r = e.left !== s.left, i = e.top !== s.top;\n    (r || i) && t(), e = s, n = window.requestAnimationFrame(l);\n  }(), () => window.cancelAnimationFrame(n);\n}\nfunction Xo(a, t, e = \"ltr\") {\n  const n = nn(t), l = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - l, r = t.content - t.viewport, i = s - n, u = e === \"ltr\" ? [0, r] : [r * -1, 0], d = Kt(\n    a,\n    u[0],\n    u[1]\n  );\n  return Cs([0, r], [0, i])(d);\n}\nfunction Ia(a) {\n  return a ? Number.parseInt(a, 10) : 0;\n}\nfunction mp(a, t, e, n = \"ltr\") {\n  const l = nn(e), s = l / 2, r = t || s, i = l - r, u = e.scrollbar.paddingStart + r, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, c = e.content - e.viewport, p = n === \"ltr\" ? [0, c] : [c * -1, 0];\n  return Cs(\n    [u, d],\n    p\n  )(a);\n}\nfunction Zo(a, t) {\n  return a > 0 && a < t;\n}\nconst _s = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ze(), s = on(), r = ln(), { forwardRef: i, currentElement: u } = T(), d = I(\"\"), c = I();\n    function p(x) {\n      var D, h;\n      if (c.value) {\n        const E = x.clientX - ((D = c.value) == null ? void 0 : D.left), P = x.clientY - ((h = c.value) == null ? void 0 : h.top);\n        n(\"onDragScroll\", { x: E, y: P });\n      }\n    }\n    function f(x) {\n      x.button === 0 && (x.target.setPointerCapture(x.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", l.viewport && (l.viewport.value.style.scrollBehavior = \"auto\"), p(x));\n    }\n    function v(x) {\n      p(x);\n    }\n    function g(x) {\n      const D = x.target;\n      D.hasPointerCapture(x.pointerId) && D.releasePointerCapture(x.pointerId), document.body.style.webkitUserSelect = d.value, l.viewport && (l.viewport.value.style.scrollBehavior = \"\"), c.value = void 0;\n    }\n    function m(x) {\n      var P;\n      const D = x.target, h = (P = u.value) == null ? void 0 : P.contains(D), E = s.sizes.value.content - s.sizes.value.viewport;\n      h && s.handleWheelScroll(x, E);\n    }\n    se(() => {\n      document.addEventListener(\"wheel\", m, { passive: !1 });\n    }), Ie(() => {\n      document.removeEventListener(\"wheel\", m);\n    });\n    function S() {\n      var x, D, h, E, P;\n      u.value && (e.isHorizontal ? s.handleSizeChange({\n        content: ((x = l.viewport.value) == null ? void 0 : x.scrollWidth) ?? 0,\n        viewport: ((D = l.viewport.value) == null ? void 0 : D.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: Ia(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ia(getComputedStyle(u.value).paddingRight)\n        }\n      }) : s.handleSizeChange({\n        content: ((h = l.viewport.value) == null ? void 0 : h.scrollHeight) ?? 0,\n        viewport: ((E = l.viewport.value) == null ? void 0 : E.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((P = u.value) == null ? void 0 : P.clientHeight) ?? 0,\n          paddingStart: Ia(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ia(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return Ze(u, S), Ze(l.content, S), (x, D) => (b(), _(o(O), {\n      ref: o(i),\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: o(r).as.value,\n      \"as-child\": o(r).asChild.value,\n      onPointerdown: f,\n      onPointermove: v,\n      onPointerup: g\n    }, {\n      default: y(() => [\n        C(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), hp = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(a) {\n    const t = ze(), e = on(), { forwardRef: n, currentElement: l } = T();\n    se(() => {\n      l.value && t.onScrollbarXChange(l.value);\n    });\n    const s = B(() => e.sizes.value);\n    return (r, i) => (b(), _(_s, {\n      ref: o(n),\n      \"is-horizontal\": !0,\n      \"data-orientation\": \"horizontal\",\n      style: Oe({\n        bottom: 0,\n        left: o(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: o(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": s.value ? `${o(nn)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.x))\n    }, {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), yp = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(a) {\n    const t = ze(), e = on(), { forwardRef: n, currentElement: l } = T();\n    se(() => {\n      l.value && t.onScrollbarYChange(l.value);\n    });\n    const s = B(() => e.sizes.value);\n    return (r, i) => (b(), _(_s, {\n      ref: o(n),\n      \"is-horizontal\": !1,\n      \"data-orientation\": \"vertical\",\n      style: Oe({\n        top: 0,\n        right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": s.value ? `${o(nn)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.y))\n    }, {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [on, gp] = Q(\"ScrollAreaScrollbarVisible\"), Do = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(a) {\n    const t = ze(), e = ln(), { forwardRef: n } = T(), l = I({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), s = B(() => {\n      const x = ws(l.value.viewport, l.value.content);\n      return x > 0 && x < 1;\n    }), r = I(), i = I(0);\n    function u(x, D) {\n      if (v.value) {\n        const h = t.viewport.value.scrollLeft + x.deltaY;\n        t.viewport.value.scrollLeft = h, Zo(h, D) && x.preventDefault();\n      } else {\n        const h = t.viewport.value.scrollTop + x.deltaY;\n        t.viewport.value.scrollTop = h, Zo(h, D) && x.preventDefault();\n      }\n    }\n    function d(x, D) {\n      v.value ? i.value = D.x : i.value = D.y;\n    }\n    function c(x) {\n      i.value = 0;\n    }\n    function p(x) {\n      l.value = x;\n    }\n    function f(x, D) {\n      return mp(\n        x,\n        i.value,\n        l.value,\n        D\n      );\n    }\n    const v = B(\n      () => e.isHorizontal.value\n    );\n    function g(x) {\n      v.value ? t.viewport.value.scrollLeft = f(\n        x,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = f(x);\n    }\n    function m() {\n      if (v.value) {\n        if (t.viewport.value && r.value) {\n          const x = t.viewport.value.scrollLeft, D = Xo(\n            x,\n            l.value,\n            t.dir.value\n          );\n          r.value.style.transform = `translate3d(${D}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && r.value) {\n        const x = t.viewport.value.scrollTop, D = Xo(x, l.value);\n        r.value.style.transform = `translate3d(0, ${D}px, 0)`;\n      }\n    }\n    function S(x) {\n      r.value = x;\n    }\n    return gp({\n      sizes: l,\n      hasThumb: s,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: c,\n      handleSizeChange: p,\n      onThumbPositionChange: m,\n      onThumbChange: S,\n      onDragScroll: g\n    }), (x, D) => v.value ? (b(), _(hp, k({ key: 0 }, x.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        C(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (b(), _(yp, k({ key: 1 }, x.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        C(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xs = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = ze(), e = ln(), { forwardRef: n } = T(), l = I(!1), s = Hn(() => {\n      if (t.viewport.value) {\n        const r = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        l.value = e.isHorizontal.value ? r : i;\n      }\n    }, 10);\n    return se(() => s()), Ze(t.viewport, s), Ze(t.content, s), (r, i) => (b(), _(o(Pe), {\n      present: r.forceMount || l.value\n    }, {\n      default: y(() => [\n        Y(Do, k(r.$attrs, {\n          ref: o(n),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            C(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), bp = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = ze(), { forwardRef: e } = T();\n    let n;\n    const l = I(!1);\n    function s() {\n      window.clearTimeout(n), l.value = !0;\n    }\n    function r() {\n      n = window.setTimeout(() => {\n        l.value = !1;\n      }, t.scrollHideDelay.value);\n    }\n    return se(() => {\n      const i = t.scrollArea.value;\n      i && (i.addEventListener(\"pointerenter\", s), i.addEventListener(\"pointerleave\", r));\n    }), Ie(() => {\n      const i = t.scrollArea.value;\n      i && (window.clearTimeout(n), i.removeEventListener(\"pointerenter\", s), i.removeEventListener(\"pointerleave\", r));\n    }), (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || l.value\n    }, {\n      default: y(() => [\n        Y(xs, k(i.$attrs, {\n          ref: o(e),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Cp = /* @__PURE__ */ w({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = ze(), e = ln(), { forwardRef: n } = T(), { state: l, dispatch: s } = Al(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    ye((i) => {\n      if (l.value === \"idle\") {\n        const u = window.setTimeout(\n          () => s(\"HIDE\"),\n          t.scrollHideDelay.value\n        );\n        i(() => {\n          window.clearTimeout(u);\n        });\n      }\n    });\n    const r = Hn(() => s(\"SCROLL_END\"), 100);\n    return ye((i) => {\n      const u = t.viewport.value, d = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (u) {\n        let c = u[d];\n        const p = () => {\n          const f = u[d];\n          c !== f && (s(\"SCROLL\"), r()), c = f;\n        };\n        u.addEventListener(\"scroll\", p), i(() => {\n          u.removeEventListener(\"scroll\", p);\n        });\n      }\n    }), (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(l) !== \"hidden\"\n    }, {\n      default: y(() => [\n        Y(Do, k(i.$attrs, { ref: o(n) }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [ln, wp] = Q(\"ScrollAreaScrollbar\"), Ey = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), n = ze(), l = B(() => t.orientation === \"horizontal\");\n    te(\n      l,\n      () => {\n        l.value ? n.onScrollbarXEnabledChange(!0) : n.onScrollbarYEnabledChange(!0);\n      },\n      { immediate: !0 }\n    ), Ie(() => {\n      n.onScrollbarXEnabledChange(!1), n.onScrollbarYEnabledChange(!1);\n    });\n    const { orientation: s, forceMount: r, asChild: i, as: u } = ne(t);\n    return wp({\n      orientation: s,\n      forceMount: r,\n      isHorizontal: l,\n      as: u,\n      asChild: i\n    }), (d, c) => o(n).type.value === \"hover\" ? (b(), _(bp, k({ key: 0 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"scroll\" ? (b(), _(Cp, k({ key: 1 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"auto\" ? (b(), _(xs, k({ key: 2 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"always\" ? (b(), _(Do, k({ key: 3 }, d.$attrs, {\n      ref: o(e),\n      \"data-state\": \"visible\"\n    }), {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), Py = /* @__PURE__ */ w({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ze(), n = on();\n    function l(f) {\n      const g = f.target.getBoundingClientRect(), m = f.clientX - g.left, S = f.clientY - g.top;\n      n.handleThumbDown(f, { x: m, y: S });\n    }\n    function s(f) {\n      n.handleThumbUp(f);\n    }\n    const { forwardRef: r, currentElement: i } = T(), u = I(), d = B(() => e.viewport.value);\n    function c() {\n      if (!u.value) {\n        const f = vp(\n          d.value,\n          n.onThumbPositionChange\n        );\n        u.value = f, n.onThumbPositionChange();\n      }\n    }\n    const p = B(() => n.sizes.value);\n    return ui(p, () => {\n      n.onThumbChange(i.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener(\"scroll\", c));\n    }), Ie(() => {\n      var f;\n      d.value.removeEventListener(\"scroll\", c), (f = e.viewport.value) == null || f.removeEventListener(\"scroll\", c);\n    }), (f, v) => (b(), _(o(O), {\n      ref: o(r),\n      \"data-state\": o(n).hasThumb ? \"visible\" : \"hidden\",\n      style: {\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      },\n      \"as-child\": t.asChild,\n      as: f.as,\n      onPointerdown: l,\n      onPointerup: s\n    }, {\n      default: y(() => [\n        C(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"as-child\", \"as\"]));\n  }\n}), _p = /* @__PURE__ */ w({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(a) {\n    const t = ze(), e = I(0), n = I(0), l = B(() => !!e.value && !!n.value);\n    function s() {\n      var u;\n      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(i), n.value = i;\n    }\n    function r() {\n      var u;\n      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(i), e.value = i;\n    }\n    return Ze(t.scrollbarX.value, s), Ze(t.scrollbarY.value, r), te(() => t.scrollbarX.value, s), te(() => t.scrollbarY.value, r), (i, u) => {\n      var d;\n      return l.value ? (b(), _(o(O), k({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${n.value}px`,\n          position: \"absolute\",\n          right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = i.$parent) == null ? void 0 : d.$props), {\n        default: y(() => [\n          C(i.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : pe(\"\", !0);\n    };\n  }\n}), Dy = /* @__PURE__ */ w({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), n = ze(), l = B(\n      () => !!n.scrollbarX.value && !!n.scrollbarY.value\n    ), s = B(\n      () => n.type.value !== \"scroll\" && l.value\n    );\n    return (r, i) => s.value ? (b(), _(_p, k({ key: 0 }, t, { ref: o(e) }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), xp = [\"default-value\"], Sp = /* @__PURE__ */ w({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ne(t), n = I();\n    return (l, s) => (b(), _(o(Yt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Ha(Ue(\"select\", k({\n          ref_key: \"selectElement\",\n          ref: n\n        }, t, {\n          \"onUpdate:modelValue\": s[0] || (s[0] = (r) => Xe(e) ? e.value = r : null),\n          \"default-value\": o(e)\n        }), [\n          C(l.$slots, \"default\")\n        ], 16, xp), [\n          [hr, o(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Ep = {\n  key: 0,\n  value: \"\"\n}, [bt, Ss] = Q(\"SelectRoot\"), [Pp, Dp] = Q(\"SelectRoot\"), $y = /* @__PURE__ */ w({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), s = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = I(), i = I(), u = I({\n      x: 0,\n      y: 0\n    }), d = I(!1), { required: c, disabled: p, dir: f } = ne(e), v = be(f);\n    Ss({\n      triggerElement: r,\n      onTriggerChange: (x) => {\n        r.value = x;\n      },\n      valueElement: i,\n      onValueElementChange: (x) => {\n        i.value = x;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (x) => {\n        d.value = x;\n      },\n      contentId: \"\",\n      modelValue: l,\n      onValueChange: (x) => {\n        l.value = x;\n      },\n      open: s,\n      required: c,\n      onOpenChange: (x) => {\n        s.value = x;\n      },\n      dir: v,\n      triggerPointerDownPosRef: u,\n      disabled: p\n    });\n    const g = Qe(r), m = I(/* @__PURE__ */ new Set()), S = B(() => Array.from(m.value).map((x) => {\n      var D;\n      return (D = x.props) == null ? void 0 : D.value;\n    }).join(\";\"));\n    return Dp({\n      onNativeOptionAdd: (x) => {\n        m.value.add(x);\n      },\n      onNativeOptionRemove: (x) => {\n        m.value.delete(x);\n      }\n    }), (x, D) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(x.$slots, \"default\", {\n          modelValue: o(l),\n          open: o(s)\n        }),\n        o(g) ? (b(), _(Sp, k({ key: S.value }, x.$attrs, {\n          \"aria-hidden\": \"\",\n          tabindex: \"-1\",\n          required: o(c),\n          name: x.name,\n          autocomplete: x.autocomplete,\n          disabled: o(p),\n          value: o(l),\n          onChange: D[0] || (D[0] = (h) => l.value = h.target.value)\n        }), {\n          default: y(() => [\n            o(l) === void 0 ? (b(), ce(\"option\", Ep)) : pe(\"\", !0),\n            (b(!0), ce(_e, null, va(Array.from(m.value), (h) => (b(), _(Ge(h), k({ ref_for: !0 }, h.props, {\n              key: h.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : pe(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), $p = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], Bp = [\" \", \"Enter\"], at = 10;\nfunction Es(a) {\n  return a === \"\" || Nt(a);\n}\nconst By = /* @__PURE__ */ w({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = B(() => {\n      var v;\n      return ((v = e.disabled) == null ? void 0 : v.value) || t.disabled;\n    }), { forwardRef: l, currentElement: s } = T();\n    e.contentId || (e.contentId = me(void 0, \"radix-vue-select-content\")), se(() => {\n      e.triggerElement = s;\n    });\n    const { injectCollection: r } = Me(), i = r(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = ga(i);\n    function p() {\n      n.value || (e.onOpenChange(!0), c());\n    }\n    function f(v) {\n      p(), e.triggerPointerDownPosRef.value = {\n        x: Math.round(v.pageX),\n        y: Math.round(v.pageY)\n      };\n    }\n    return (v, g) => (b(), _(o(Tt), { \"as-child\": \"\" }, {\n      default: y(() => {\n        var m, S, x, D;\n        return [\n          Y(o(O), {\n            ref: o(l),\n            role: \"combobox\",\n            type: v.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": o(e).contentId,\n            \"aria-expanded\": o(e).open.value || !1,\n            \"aria-required\": (m = o(e).required) == null ? void 0 : m.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: n.value,\n            dir: (S = o(e)) == null ? void 0 : S.dir.value,\n            \"data-state\": (x = o(e)) != null && x.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": n.value ? \"\" : void 0,\n            \"data-placeholder\": o(Es)((D = o(e).modelValue) == null ? void 0 : D.value) ? \"\" : void 0,\n            \"as-child\": v.asChild,\n            as: v.as,\n            onClick: g[0] || (g[0] = (h) => {\n              var E;\n              (E = h == null ? void 0 : h.currentTarget) == null || E.focus();\n            }),\n            onPointerdown: g[1] || (g[1] = (h) => {\n              if (h.pointerType === \"touch\")\n                return h.preventDefault();\n              const E = h.target;\n              E.hasPointerCapture(h.pointerId) && E.releasePointerCapture(h.pointerId), h.button === 0 && h.ctrlKey === !1 && (f(h), h.preventDefault());\n            }),\n            onPointerup: g[2] || (g[2] = ie(\n              (h) => {\n                h.pointerType === \"touch\" && f(h);\n              },\n              [\"prevent\"]\n            )),\n            onKeydown: g[3] || (g[3] = (h) => {\n              const E = o(u) !== \"\";\n              !(h.ctrlKey || h.altKey || h.metaKey) && h.key.length === 1 && E && h.key === \" \" || (o(d)(h.key), o($p).includes(h.key) && (p(), h.preventDefault()));\n            })\n          }, {\n            default: y(() => [\n              C(v.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), Iy = /* @__PURE__ */ w({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [$o, Ip] = Q(\"SelectItemAlignedPosition\"), Tp = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Me(), s = bt(), r = Ct(), i = l(), u = I(!1), d = I(!0), c = I(), { forwardRef: p, currentElement: f } = T(), { viewport: v, selectedItem: g, selectedItemText: m, focusSelectedItem: S } = r;\n    function x() {\n      if (s.triggerElement.value && s.valueElement.value && c.value && f.value && (v != null && v.value) && (g != null && g.value) && (m != null && m.value)) {\n        const E = s.triggerElement.value.getBoundingClientRect(), P = f.value.getBoundingClientRect(), $ = s.valueElement.value.getBoundingClientRect(), R = m.value.getBoundingClientRect();\n        if (s.dir.value !== \"rtl\") {\n          const ge = R.left - P.left, De = $.left - ge, ue = E.left - De, Se = E.width + ue, Ve = Math.max(Se, P.width), Ke = window.innerWidth - at, aa = Kt(De, at, Ke - Ve);\n          c.value.style.minWidth = `${Se}px`, c.value.style.left = `${aa}px`;\n        } else {\n          const ge = P.right - R.right, De = window.innerWidth - $.right - ge, ue = window.innerWidth - E.right - De, Se = E.width + ue, Ve = Math.max(Se, P.width), Ke = window.innerWidth - at, aa = Kt(\n            De,\n            at,\n            Ke - Ve\n          );\n          c.value.style.minWidth = `${Se}px`, c.value.style.right = `${aa}px`;\n        }\n        const M = i.value, V = window.innerHeight - at * 2, A = v.value.scrollHeight, L = window.getComputedStyle(f.value), U = Number.parseInt(\n          L.borderTopWidth,\n          10\n        ), H = Number.parseInt(L.paddingTop, 10), J = Number.parseInt(\n          L.borderBottomWidth,\n          10\n        ), N = Number.parseInt(\n          L.paddingBottom,\n          10\n        ), F = U + H + A + N + J, W = Math.min(\n          g.value.offsetHeight * 5,\n          F\n        ), z = window.getComputedStyle(v.value), X = Number.parseInt(z.paddingTop, 10), G = Number.parseInt(\n          z.paddingBottom,\n          10\n        ), Z = E.top + E.height / 2 - at, ee = V - Z, fe = g.value.offsetHeight / 2, q = g.value.offsetTop + fe, oe = U + H + q, he = F - oe;\n        if (oe <= Z) {\n          const ge = g.value === M[M.length - 1];\n          c.value.style.bottom = \"0px\";\n          const De = f.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, ue = Math.max(\n            ee,\n            fe + (ge ? G : 0) + De + J\n          ), Se = oe + ue;\n          c.value.style.height = `${Se}px`;\n        } else {\n          const ge = g.value === M[0];\n          c.value.style.top = \"0px\";\n          const ue = Math.max(\n            Z,\n            U + v.value.offsetTop + (ge ? X : 0) + fe\n          ) + he;\n          c.value.style.height = `${ue}px`, v.value.scrollTop = oe - Z + v.value.offsetTop;\n        }\n        c.value.style.margin = `${at}px 0`, c.value.style.minHeight = `${W}px`, c.value.style.maxHeight = `${V}px`, n(\"placed\"), requestAnimationFrame(() => u.value = !0);\n      }\n    }\n    const D = I(\"\");\n    se(async () => {\n      await le(), x(), f.value && (D.value = window.getComputedStyle(f.value).zIndex);\n    });\n    function h(E) {\n      E && d.value === !0 && (x(), S == null || S(), d.value = !1);\n    }\n    return Ip({\n      contentWrapper: c,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: h\n    }), (E, P) => (b(), ce(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: c,\n      style: Oe({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: D.value\n      })\n    }, [\n      Y(o(O), k({\n        ref: o(p),\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...E.$attrs, ...e }), {\n        default: y(() => [\n          C(E.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16)\n    ], 4));\n  }\n}), Rp = /* @__PURE__ */ w({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: at },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const e = Bt(a);\n    return (n, l) => (b(), _(o(Pt), k(o(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ta = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [Ct, Ap] = Q(\"SelectContent\"), Op = /* @__PURE__ */ w({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: { default: \"item-aligned\" },\n    bodyLock: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = bt();\n    Gn(), ha(e.bodyLock);\n    const { createCollection: s } = Me(), r = I();\n    ya(r);\n    const i = s(r), { search: u, handleTypeaheadSearch: d } = ga(i), c = I(), p = I(), f = I(), v = I(!1), g = I(!1);\n    function m() {\n      p.value && r.value && $n([p.value, r.value]);\n    }\n    te(v, () => {\n      m();\n    });\n    const { onOpenChange: S, triggerPointerDownPosRef: x } = l;\n    ye((P) => {\n      if (!r.value)\n        return;\n      let $ = { x: 0, y: 0 };\n      const R = (V) => {\n        var A, L;\n        $ = {\n          x: Math.abs(\n            Math.round(V.pageX) - (((A = x.value) == null ? void 0 : A.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(V.pageY) - (((L = x.value) == null ? void 0 : L.y) ?? 0)\n          )\n        };\n      }, M = (V) => {\n        var A;\n        V.pointerType !== \"touch\" && ($.x <= 10 && $.y <= 10 ? V.preventDefault() : (A = r.value) != null && A.contains(V.target) || S(!1), document.removeEventListener(\"pointermove\", R), x.value = null);\n      };\n      x.value !== null && (document.addEventListener(\"pointermove\", R), document.addEventListener(\"pointerup\", M, {\n        capture: !0,\n        once: !0\n      })), P(() => {\n        document.removeEventListener(\"pointermove\", R), document.removeEventListener(\"pointerup\", M, {\n          capture: !0\n        });\n      });\n    });\n    function D(P) {\n      const $ = P.ctrlKey || P.altKey || P.metaKey;\n      if (P.key === \"Tab\" && P.preventDefault(), !$ && P.key.length === 1 && d(P.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(P.key)) {\n        let R = i.value;\n        if ([\"ArrowUp\", \"End\"].includes(P.key) && (R = R.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(P.key)) {\n          const M = P.target, V = R.indexOf(M);\n          R = R.slice(V + 1);\n        }\n        setTimeout(() => $n(R)), P.preventDefault();\n      }\n    }\n    const h = B(() => e.position === \"popper\" ? e : {}), E = Bt(h.value);\n    return Ap({\n      content: r,\n      viewport: c,\n      onViewportChange: (P) => {\n        c.value = P;\n      },\n      itemRefCallback: (P, $, R) => {\n        var A, L;\n        const M = !g.value && !R;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((L = l.modelValue) == null ? void 0 : L.value) === $ || M) && (p.value = P, M && (g.value = !0));\n      },\n      selectedItem: p,\n      selectedItemText: f,\n      onItemLeave: () => {\n        var P;\n        (P = r.value) == null || P.focus();\n      },\n      itemTextRefCallback: (P, $, R) => {\n        var A, L;\n        const M = !g.value && !R;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((L = l.modelValue) == null ? void 0 : L.value) === $ || M) && (f.value = P);\n      },\n      focusSelectedItem: m,\n      position: e.position,\n      isPositioned: v,\n      searchRef: u\n    }), (P, $) => (b(), _(o(Ya), {\n      \"as-child\": \"\",\n      onMountAutoFocus: $[6] || ($[6] = ie(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: $[7] || ($[7] = (R) => {\n        var M;\n        n(\"closeAutoFocus\", R), !R.defaultPrevented && ((M = o(l).triggerElement.value) == null || M.focus({ preventScroll: !0 }), R.preventDefault());\n      })\n    }, {\n      default: y(() => [\n        Y(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: $[2] || ($[2] = ie(() => {\n          }, [\"prevent\"])),\n          onDismiss: $[3] || ($[3] = (R) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: $[4] || ($[4] = (R) => n(\"escapeKeyDown\", R)),\n          onPointerDownOutside: $[5] || ($[5] = (R) => n(\"pointerDownOutside\", R))\n        }, {\n          default: y(() => [\n            (b(), _(Ge(\n              P.position === \"popper\" ? Rp : Tp\n            ), k({ ...P.$attrs, ...o(E) }, {\n              id: o(l).contentId,\n              ref: (R) => {\n                r.value = o(Be)(R);\n              },\n              role: \"listbox\",\n              \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n              dir: o(l).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: $[0] || ($[0] = ie(() => {\n              }, [\"prevent\"])),\n              onPlaced: $[1] || ($[1] = (R) => v.value = !0),\n              onKeydown: D\n            }), {\n              default: y(() => [\n                C(P.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), kp = /* @__PURE__ */ w({\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(a) {\n    return Ss(a.context), (e, n) => C(e.$slots, \"default\");\n  }\n}), Mp = { key: 1 }, Ty = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, l = xe(e, t), s = bt(), r = I();\n    se(() => {\n      r.value = new DocumentFragment();\n    });\n    const i = I(), u = B(() => e.forceMount || s.open.value);\n    return (d, c) => {\n      var p;\n      return u.value ? (b(), _(o(Pe), {\n        key: 0,\n        ref_key: \"presenceRef\",\n        ref: i,\n        present: !0\n      }, {\n        default: y(() => [\n          Y(Op, K(j({ ...o(l), ...d.$attrs })), {\n            default: y(() => [\n              C(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16)\n        ]),\n        _: 3\n      }, 512)) : !((p = i.value) != null && p.present) && r.value ? (b(), ce(\"div\", Mp, [\n        (b(), _(Wt, { to: r.value }, [\n          Y(kp, { context: o(s) }, {\n            default: y(() => [\n              C(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"]))\n      ])) : pe(\"\", !0);\n    };\n  }\n}), Ry = /* @__PURE__ */ w({\n  __name: \"SelectArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = Ct();\n    return (l, s) => o(e).open.value && o(n).position === \"popper\" ? (b(), _(o(qt), K(k({ key: 0 }, t)), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), Ay = /* @__PURE__ */ w({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(O), k({ \"aria-hidden\": \"\" }, t), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Ps, Vp] = Q(\"SelectItem\"), Oy = /* @__PURE__ */ w({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ne(t), n = bt(), l = Ct(ta), { forwardRef: s, currentElement: r } = T(), i = B(() => {\n      var m;\n      return ((m = n.modelValue) == null ? void 0 : m.value) === t.value;\n    }), u = I(!1), d = I(t.textValue ?? \"\"), c = me(void 0, \"radix-vue-select-item-text\");\n    async function p(m) {\n      await le(), !(m != null && m.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));\n    }\n    async function f(m) {\n      var S;\n      await le(), !m.defaultPrevented && (e.value ? (S = l.onItemLeave) == null || S.call(l) : m.currentTarget.focus({ preventScroll: !0 }));\n    }\n    async function v(m) {\n      var S;\n      await le(), !m.defaultPrevented && m.currentTarget === document.activeElement && ((S = l.onItemLeave) == null || S.call(l));\n    }\n    async function g(m) {\n      var x;\n      await le(), !(m.defaultPrevented || ((x = l.searchRef) == null ? void 0 : x.value) !== \"\" && m.key === \" \") && (Bp.includes(m.key) && p(), m.key === \" \" && m.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return se(() => {\n      r.value && l.itemRefCallback(\n        r.value,\n        t.value,\n        t.disabled\n      );\n    }), Vp({\n      value: t.value,\n      disabled: e,\n      textId: c,\n      isSelected: i,\n      onItemTextChange: (m) => {\n        d.value = ((d.value || (m == null ? void 0 : m.textContent)) ?? \"\").trim();\n      }\n    }), (m, S) => (b(), _(o(O), {\n      ref: o(s),\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": o(c),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": i.value,\n      \"data-state\": i.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": o(e) || void 0,\n      \"data-disabled\": o(e) ? \"\" : void 0,\n      tabindex: o(e) ? void 0 : -1,\n      as: m.as,\n      \"as-child\": m.asChild,\n      onFocus: S[0] || (S[0] = (x) => u.value = !0),\n      onBlur: S[1] || (S[1] = (x) => u.value = !1),\n      onPointerup: p,\n      onPointerdown: S[2] || (S[2] = (x) => {\n        x.currentTarget.focus({ preventScroll: !0 });\n      }),\n      onTouchend: S[3] || (S[3] = ie(() => {\n      }, [\"prevent\", \"stop\"])),\n      onPointermove: f,\n      onPointerleave: v,\n      onKeydown: g\n    }, {\n      default: y(() => [\n        C(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), ky = /* @__PURE__ */ w({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Ps();\n    return (n, l) => o(e).isSelected.value ? (b(), _(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : pe(\"\", !0);\n  }\n}), [Fp, Lp] = Q(\"SelectGroup\"), My = /* @__PURE__ */ w({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = me(void 0, \"radix-vue-select-group\");\n    return Lp({ id: e }), (n, l) => (b(), _(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Vy = /* @__PURE__ */ w({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Fp({ id: \"\" });\n    return (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Fy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = Ct(ta), l = Pp(), s = Ps(), { forwardRef: r, currentElement: i } = T(), u = B(() => {\n      var d;\n      return pt(\"option\", {\n        key: s.value,\n        value: s.value,\n        disabled: s.disabled.value,\n        innerHTML: (d = i.value) == null ? void 0 : d.textContent\n      });\n    });\n    return se(() => {\n      i.value && (s.onItemTextChange(i.value), n.itemTextRefCallback(\n        i.value,\n        s.value,\n        s.disabled.value\n      ), l.onNativeOptionAdd(u.value));\n    }), Vn(() => {\n      l.onNativeOptionRemove(u.value);\n    }), (d, c) => (b(), ce(_e, null, [\n      Y(o(O), k({\n        id: o(s).textId,\n        ref: o(r)\n      }, { ...t, ...d.$attrs }), {\n        default: y(() => [\n          C(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      o(s).isSelected.value && o(e).valueElement.value && !o(e).valueElementHasChildren.value ? (b(), _(Wt, {\n        key: 0,\n        to: o(e).valueElement.value\n      }, [\n        C(d.$slots, \"default\")\n      ], 8, [\"to\"])) : pe(\"\", !0)\n    ], 64));\n  }\n}), Ly = /* @__PURE__ */ w({\n  __name: \"SelectViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { nonce: e } = ne(t), n = Xa(e), l = Ct(ta), s = l.position === \"item-aligned\" ? $o() : void 0, { forwardRef: r, currentElement: i } = T();\n    se(() => {\n      l == null || l.onViewportChange(i.value);\n    });\n    const u = I(0);\n    function d(c) {\n      const p = c.currentTarget, { shouldExpandOnScrollRef: f, contentWrapper: v } = s ?? {};\n      if (f != null && f.value && (v != null && v.value)) {\n        const g = Math.abs(u.value - p.scrollTop);\n        if (g > 0) {\n          const m = window.innerHeight - at * 2, S = Number.parseFloat(\n            v.value.style.minHeight\n          ), x = Number.parseFloat(v.value.style.height), D = Math.max(S, x);\n          if (D < m) {\n            const h = D + g, E = Math.min(m, h), P = h - E;\n            v.value.style.height = `${E}px`, v.value.style.bottom === \"0px\" && (p.scrollTop = P > 0 ? P : 0, v.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      u.value = p.scrollTop;\n    }\n    return (c, p) => (b(), ce(_e, null, [\n      Y(o(O), k({\n        ref: o(r),\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...c.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        },\n        onScroll: d\n      }), {\n        default: y(() => [\n          C(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      Y(o(O), {\n        as: \"style\",\n        nonce: o(n)\n      }, {\n        default: y(() => [\n          ve(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), Ds = /* @__PURE__ */ w({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(a, { emit: t }) {\n    const e = t, { injectCollection: n } = Me(), l = n(), s = Ct(ta), r = I(null);\n    function i() {\n      r.value !== null && (window.clearInterval(r.value), r.value = null);\n    }\n    ye(() => {\n      const c = l.value.find(\n        (p) => p === document.activeElement\n      );\n      c == null || c.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var c;\n      (c = s.onItemLeave) == null || c.call(s), r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return Vn(() => i()), (c, p) => {\n      var f;\n      return b(), _(o(O), k({\n        \"aria-hidden\": \"\",\n        style: {\n          flexShrink: 0\n        }\n      }, (f = c.$parent) == null ? void 0 : f.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: p[0] || (p[0] = () => {\n          i();\n        })\n      }), {\n        default: y(() => [\n          C(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), Ny = /* @__PURE__ */ w({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = Ct(ta), e = t.position === \"item-aligned\" ? $o() : void 0, { forwardRef: n, currentElement: l } = T(), s = I(!1);\n    return ye((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          s.value = c.scrollTop > 0;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), te(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), _(Ds, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : pe(\"\", !0);\n  }\n}), zy = /* @__PURE__ */ w({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = Ct(ta), e = t.position === \"item-aligned\" ? $o() : void 0, { forwardRef: n, currentElement: l } = T(), s = I(!1);\n    return ye((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const p = c.scrollHeight - c.clientHeight;\n          s.value = Math.ceil(c.scrollTop) < p;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), te(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), _(Ds, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : pe(\"\", !0);\n  }\n}), Ky = /* @__PURE__ */ w({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = T(), n = bt(), l = Wa();\n    return pl(() => {\n      var r;\n      const s = !!Ua((r = l == null ? void 0 : l.default) == null ? void 0 : r.call(l)).length;\n      n.onValueElementHasChildrenChange(s);\n    }), se(() => {\n      n.valueElement = e;\n    }), (s, r) => (b(), _(o(O), {\n      ref: o(t),\n      as: s.as,\n      \"as-child\": s.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: y(() => {\n        var i;\n        return [\n          o(Es)((i = o(n).modelValue) == null ? void 0 : i.value) ? (b(), ce(_e, { key: 0 }, [\n            ve($e(s.placeholder), 1)\n          ], 64)) : C(s.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Hy = /* @__PURE__ */ w({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return (t, e) => (b(), _(o(O), {\n      \"aria-hidden\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: y(() => [\n        C(t.$slots, \"default\", {}, () => [\n          ve(\"▼\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), $s = /* @__PURE__ */ w({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = [\"horizontal\", \"vertical\"];\n    function n(i) {\n      return e.includes(i);\n    }\n    const l = B(\n      () => n(t.orientation) ? t.orientation : \"horizontal\"\n    ), s = B(\n      () => l.value === \"vertical\" ? t.orientation : void 0\n    ), r = B(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": s.value, role: \"separator\" }\n    );\n    return (i, u) => (b(), _(o(O), k({\n      as: i.as,\n      \"as-child\": i.asChild,\n      \"data-orientation\": l.value\n    }, r.value), {\n      default: y(() => [\n        C(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), Np = /* @__PURE__ */ w({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _($s, K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction zp(a = [], t, e) {\n  const n = [...a];\n  return n[e] = t, n.sort((l, s) => l - s);\n}\nfunction Bs(a, t, e) {\n  const s = 100 / (e - t) * (a - t);\n  return Kt(s, 0, 100);\n}\nfunction Kp(a, t) {\n  return t > 2 ? `Value ${a + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][a] : void 0;\n}\nfunction Hp(a, t) {\n  if (a.length === 1)\n    return 0;\n  const e = a.map((l) => Math.abs(l - t)), n = Math.min(...e);\n  return e.indexOf(n);\n}\nfunction Wp(a, t, e) {\n  const n = a / 2, s = Bo([0, 50], [0, n]);\n  return (n - s(t) * e) * e;\n}\nfunction jp(a) {\n  return a.slice(0, -1).map((t, e) => a[e + 1] - t);\n}\nfunction Up(a, t) {\n  if (t > 0) {\n    const e = jp(a);\n    return Math.min(...e) >= t;\n  }\n  return !0;\n}\nfunction Bo(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction Gp(a) {\n  return (String(a).split(\".\")[1] || \"\").length;\n}\nfunction qp(a, t) {\n  const e = 10 ** t;\n  return Math.round(a * e) / e;\n}\nconst Is = [\"PageUp\", \"PageDown\"], Ts = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], Rs = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [As, Os] = Q([\"SliderVertical\", \"SliderHorizontal\"]), ks = /* @__PURE__ */ w({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = sn();\n    return (s, r) => (b(), _(o(O), k({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: r[0] || (r[0] = (i) => {\n        i.key === \"Home\" ? (n(\"homeKeyDown\", i), i.preventDefault()) : i.key === \"End\" ? (n(\"endKeyDown\", i), i.preventDefault()) : o(Is).concat(o(Ts)).includes(i.key) && (n(\"stepKeyDown\", i), i.preventDefault());\n      }),\n      onPointerdown: r[1] || (r[1] = (i) => {\n        const u = i.target;\n        u.setPointerCapture(i.pointerId), i.preventDefault(), o(l).thumbElements.value.includes(u) ? u.focus() : n(\"slideStart\", i);\n      }),\n      onPointermove: r[2] || (r[2] = (i) => {\n        i.target.hasPointerCapture(i.pointerId) && n(\"slideMove\", i);\n      }),\n      onPointerup: r[3] || (r[3] = (i) => {\n        const u = i.target;\n        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), n(\"slideEnd\", i));\n      })\n    }), {\n      default: y(() => [\n        C(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Yp = /* @__PURE__ */ w({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, dir: r, inverted: i } = ne(e), { forwardRef: u, currentElement: d } = T(), c = I(), p = B(() => (r == null ? void 0 : r.value) === \"ltr\" && !i.value || (r == null ? void 0 : r.value) !== \"ltr\" && i.value);\n    function f(v) {\n      const g = c.value || d.value.getBoundingClientRect(), m = [0, g.width], S = p.value ? [s.value, l.value] : [l.value, s.value], x = Bo(m, S);\n      return c.value = g, x(v - g.left);\n    }\n    return Os({\n      startEdge: p.value ? \"left\" : \"right\",\n      endEdge: p.value ? \"right\" : \"left\",\n      direction: p.value ? 1 : -1,\n      size: \"width\"\n    }), (v, g) => (b(), _(ks, {\n      ref: o(u),\n      dir: o(r),\n      \"data-orientation\": \"horizontal\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      },\n      onSlideStart: g[0] || (g[0] = (m) => {\n        const S = f(m.clientX);\n        n(\"slideStart\", S);\n      }),\n      onSlideMove: g[1] || (g[1] = (m) => {\n        const S = f(m.clientX);\n        n(\"slideMove\", S);\n      }),\n      onSlideEnd: g[2] || (g[2] = () => {\n        c.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: g[3] || (g[3] = (m) => {\n        const S = p.value ? \"from-left\" : \"from-right\", x = o(Rs)[S].includes(m.key);\n        n(\"stepKeyDown\", m, x ? -1 : 1);\n      }),\n      onEndKeyDown: g[4] || (g[4] = (m) => n(\"endKeyDown\", m)),\n      onHomeKeyDown: g[5] || (g[5] = (m) => n(\"homeKeyDown\", m))\n    }, {\n      default: y(() => [\n        C(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), Xp = /* @__PURE__ */ w({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, inverted: r } = ne(e), { forwardRef: i, currentElement: u } = T(), d = I(), c = B(() => !r.value);\n    function p(f) {\n      const v = d.value || u.value.getBoundingClientRect(), g = [0, v.height], m = c.value ? [l.value, s.value] : [s.value, l.value], S = Bo(g, m);\n      return d.value = v, S(f - v.top);\n    }\n    return Os({\n      startEdge: c.value ? \"bottom\" : \"top\",\n      endEdge: c.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: c.value ? 1 : -1\n    }), (f, v) => (b(), _(ks, {\n      ref: o(i),\n      \"data-orientation\": \"vertical\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      },\n      onSlideStart: v[0] || (v[0] = (g) => {\n        const m = p(g.clientY);\n        n(\"slideStart\", m);\n      }),\n      onSlideMove: v[1] || (v[1] = (g) => {\n        const m = p(g.clientY);\n        n(\"slideMove\", m);\n      }),\n      onSlideEnd: v[2] || (v[2] = () => {\n        d.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: v[3] || (v[3] = (g) => {\n        const m = c.value ? \"from-bottom\" : \"from-top\", S = o(Rs)[m].includes(g.key);\n        n(\"stepKeyDown\", g, S ? -1 : 1);\n      }),\n      onEndKeyDown: v[4] || (v[4] = (g) => n(\"endKeyDown\", g)),\n      onHomeKeyDown: v[5] || (v[5] = (g) => n(\"homeKeyDown\", g))\n    }, {\n      default: y(() => [\n        C(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512));\n  }\n}), Zp = [\"value\", \"name\", \"disabled\", \"step\"], [sn, Jp] = Q(\"SliderRoot\"), Wy = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: !1 },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { min: l, max: s, step: r, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: c } = ne(e), p = be(c), { forwardRef: f, currentElement: v } = T(), g = Qe(v);\n    ba();\n    const m = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), S = I(0), x = I(m.value);\n    function D(R) {\n      const M = Hp(m.value, R);\n      P(R, M);\n    }\n    function h(R) {\n      P(R, S.value);\n    }\n    function E() {\n      const R = x.value[S.value];\n      m.value[S.value] !== R && n(\"valueCommit\", yr(m.value));\n    }\n    function P(R, M, { commit: V } = { commit: !1 }) {\n      var J;\n      const A = Gp(r.value), L = qp(Math.round((R - l.value) / r.value) * r.value + l.value, A), U = Kt(L, l.value, s.value), H = zp(m.value, U, M);\n      if (Up(H, i.value * r.value)) {\n        S.value = H.indexOf(U);\n        const N = String(H) !== String(m.value);\n        N && V && n(\"valueCommit\", H), N && ((J = $.value[S.value]) == null || J.focus(), m.value = H);\n      }\n    }\n    const $ = I([]);\n    return Jp({\n      modelValue: m,\n      valueIndexToChangeRef: S,\n      thumbElements: $,\n      orientation: u,\n      min: l,\n      max: s,\n      disabled: d\n    }), (R, M) => (b(), ce(_e, null, [\n      Y(o(Ca), null, {\n        default: y(() => [\n          (b(), _(Ge(o(u) === \"horizontal\" ? Yp : Xp), k(R.$attrs, {\n            ref: o(f),\n            \"as-child\": R.asChild,\n            as: R.as,\n            min: o(l),\n            max: o(s),\n            dir: o(p),\n            inverted: R.inverted,\n            \"aria-disabled\": o(d),\n            \"data-disabled\": o(d) ? \"\" : void 0,\n            onPointerdown: M[0] || (M[0] = () => {\n              o(d) || (x.value = o(m));\n            }),\n            onSlideStart: M[1] || (M[1] = (V) => !o(d) && D(V)),\n            onSlideMove: M[2] || (M[2] = (V) => !o(d) && h(V)),\n            onSlideEnd: M[3] || (M[3] = (V) => !o(d) && E()),\n            onHomeKeyDown: M[4] || (M[4] = (V) => !o(d) && P(o(l), 0, { commit: !0 })),\n            onEndKeyDown: M[5] || (M[5] = (V) => !o(d) && P(o(s), o(m).length - 1, { commit: !0 })),\n            onStepKeyDown: M[6] || (M[6] = (V, A) => {\n              if (!o(d)) {\n                const H = o(Is).includes(V.key) || V.shiftKey && o(Ts).includes(V.key) ? 10 : 1, J = S.value, N = o(m)[J], F = o(r) * H * A;\n                P(N + F, J, { commit: !0 });\n              }\n            })\n          }), {\n            default: y(() => [\n              C(R.$slots, \"default\", { modelValue: o(m) })\n            ]),\n            _: 3\n          }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"]))\n        ]),\n        _: 3\n      }),\n      o(g) ? (b(!0), ce(_e, { key: 0 }, va(o(m), (V, A) => (b(), ce(\"input\", {\n        key: A,\n        value: V,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: R.name ? R.name + (o(m).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: o(d),\n        step: o(r)\n      }, null, 8, Zp))), 128)) : pe(\"\", !0)\n    ], 64));\n  }\n}), Qp = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = sn(), n = As(), { forwardRef: l, currentElement: s } = T(), r = B(() => {\n      var v, g;\n      return (g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g[t.index];\n    }), i = B(() => r.value === void 0 ? 0 : Bs(r.value, e.min.value ?? 0, e.max.value ?? 100)), u = B(() => {\n      var v, g;\n      return Kp(t.index, ((g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g.length) ?? 0);\n    }), d = Rl(s), c = B(() => d[n.size].value), p = B(() => c.value ? Wp(c.value, i.value, n.direction) : 0), f = ja();\n    return se(() => {\n      e.thumbElements.value.push(s.value);\n    }), Ie(() => {\n      const v = e.thumbElements.value.findIndex((g) => g === s.value) ?? -1;\n      e.thumbElements.value.splice(v, 1);\n    }), (v, g) => (b(), _(o(Xt), null, {\n      default: y(() => [\n        Y(o(O), k(v.$attrs, {\n          ref: o(l),\n          role: \"slider\",\n          \"data-radix-vue-collection-item\": \"\",\n          tabindex: o(e).disabled.value ? void 0 : 0,\n          \"aria-label\": v.$attrs[\"aria-label\"] || u.value,\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"data-orientation\": o(e).orientation.value,\n          \"aria-valuenow\": r.value,\n          \"aria-valuemin\": o(e).min.value,\n          \"aria-valuemax\": o(e).max.value,\n          \"aria-orientation\": o(e).orientation.value,\n          \"as-child\": v.asChild,\n          as: v.as,\n          style: {\n            transform: \"var(--radix-slider-thumb-transform)\",\n            position: \"absolute\",\n            [o(n).startEdge]: `calc(${i.value}% + ${p.value}px)`,\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            display: !o(f) && r.value === void 0 ? \"none\" : void 0\n          },\n          onFocus: g[0] || (g[0] = () => {\n            o(e).valueIndexToChangeRef.value = v.index;\n          })\n        }), {\n          default: y(() => [\n            C(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), jy = /* @__PURE__ */ w({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { getItems: e } = Zt(), { forwardRef: n, currentElement: l } = T(), s = B(() => l.value ? e().findIndex((r) => r.ref === l.value) : -1);\n    return (r, i) => (b(), _(Qp, k({ ref: o(n) }, t, { index: s.value }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), Uy = /* @__PURE__ */ w({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = sn();\n    return T(), (e, n) => (b(), _(o(O), {\n      \"as-child\": e.asChild,\n      as: e.as,\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value\n    }, {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Gy = /* @__PURE__ */ w({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = sn(), e = As();\n    T();\n    const n = B(() => {\n      var r, i;\n      return (i = (r = t.modelValue) == null ? void 0 : r.value) == null ? void 0 : i.map(\n        (u) => Bs(u, t.min.value, t.max.value)\n      );\n    }), l = B(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), s = B(() => 100 - Math.max(...n.value));\n    return (r, i) => (b(), _(o(O), {\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      \"as-child\": r.asChild,\n      as: r.as,\n      style: Oe({\n        [o(e).startEdge]: `${l.value}%`,\n        [o(e).endEdge]: `${s.value}%`\n      })\n    }, {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n});\nlet An = null, xt = null;\nfunction ef(a, t) {\n  if (t) {\n    const e = (t & zs) !== 0, n = (t & Ks) !== 0, l = (t & Hs) !== 0, s = (t & Ws) !== 0;\n    if (e)\n      return l ? \"se-resize\" : s ? \"ne-resize\" : \"e-resize\";\n    if (n)\n      return l ? \"sw-resize\" : s ? \"nw-resize\" : \"w-resize\";\n    if (l)\n      return \"s-resize\";\n    if (s)\n      return \"n-resize\";\n  }\n  switch (a) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction tf() {\n  xt !== null && (document.head.removeChild(xt), An = null, xt = null);\n}\nfunction Sn(a, t) {\n  const e = ef(a, t);\n  An !== e && (An = e, xt === null && (xt = document.createElement(\"style\"), document.head.appendChild(xt)), xt.innerHTML = `*{cursor: ${e}!important;}`);\n}\nfunction af({\n  defaultSize: a,\n  dragState: t,\n  layout: e,\n  panelData: n,\n  panelIndex: l,\n  precision: s = 3\n}) {\n  const r = e[l];\n  let i;\n  return r == null ? i = a !== void 0 ? a.toPrecision(s) : \"1\" : n.length === 1 ? i = \"1\" : i = r.toPrecision(s), {\n    flexBasis: 0,\n    flexGrow: i,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: t !== null ? \"none\" : void 0\n  };\n}\nfunction Ms(a) {\n  return a.type === \"keydown\";\n}\nfunction Vs(a) {\n  return a.type.startsWith(\"mouse\");\n}\nfunction Fs(a) {\n  return a.type.startsWith(\"touch\");\n}\nfunction rn(a) {\n  if (Vs(a))\n    return {\n      x: a.clientX,\n      y: a.clientY\n    };\n  if (Fs(a)) {\n    const t = a.touches[0];\n    if (t && t.clientX && t.clientY)\n      return {\n        x: t.clientX,\n        y: t.clientY\n      };\n  }\n  return {\n    x: Number.POSITIVE_INFINITY,\n    y: Number.POSITIVE_INFINITY\n  };\n}\nfunction Ls(a, t) {\n  const e = a === \"horizontal\", { x: n, y: l } = rn(t);\n  return e ? n : l;\n}\nfunction nf(a, t, e) {\n  return a.x < t.x + t.width && a.x + a.width > t.x && a.y < t.y + t.height && a.y + a.height > t.y;\n}\nfunction de(a, t = \"Assertion failed!\") {\n  if (!a)\n    throw console.error(t), new Error(t);\n}\nfunction of(a, t) {\n  if (a === t)\n    throw new Error(\"Cannot compare node with itself\");\n  const e = {\n    a: el(a),\n    b: el(t)\n  };\n  let n;\n  for (; e.a.at(-1) === e.b.at(-1); )\n    a = e.a.pop(), t = e.b.pop(), n = a;\n  de(n);\n  const l = {\n    a: Qo(Jo(e.a)),\n    b: Qo(Jo(e.b))\n  };\n  if (l.a === l.b) {\n    const s = n.childNodes, r = {\n      a: e.a.at(-1),\n      b: e.b.at(-1)\n    };\n    let i = s.length;\n    for (; i--; ) {\n      const u = s[i];\n      if (u === r.a)\n        return 1;\n      if (u === r.b)\n        return -1;\n    }\n  }\n  return Math.sign(l.a - l.b);\n}\nconst lf = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\nfunction sf(a) {\n  const t = getComputedStyle(Ns(a)).display;\n  return t === \"flex\" || t === \"inline-flex\";\n}\nfunction rf(a) {\n  const t = getComputedStyle(a);\n  return !!(t.position === \"fixed\" || t.zIndex !== \"auto\" && (t.position !== \"static\" || sf(a)) || +t.opacity < 1 || \"transform\" in t && t.transform !== \"none\" || \"webkitTransform\" in t && t.webkitTransform !== \"none\" || \"mixBlendMode\" in t && t.mixBlendMode !== \"normal\" || \"filter\" in t && t.filter !== \"none\" || \"webkitFilter\" in t && t.webkitFilter !== \"none\" || \"isolation\" in t && t.isolation === \"isolate\" || lf.test(t.willChange) || t.webkitOverflowScrolling === \"touch\");\n}\nfunction Jo(a) {\n  let t = a.length;\n  for (; t--; ) {\n    const e = a[t];\n    if (de(e), rf(e))\n      return e;\n  }\n  return null;\n}\nfunction Qo(a) {\n  return a && Number(getComputedStyle(a).zIndex) || 0;\n}\nfunction el(a) {\n  const t = [];\n  for (; a; )\n    t.push(a), a = Ns(a);\n  return t;\n}\nfunction Ns(a) {\n  var t;\n  return ((t = a.parentNode) == null ? void 0 : t.host) || a.parentNode;\n}\nconst zs = 1, Ks = 2, Hs = 4, Ws = 8;\nfunction uf() {\n  if (typeof matchMedia == \"function\")\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n}\nconst df = uf() === \"coarse\", ft = [];\nlet un = !1;\nconst ct = /* @__PURE__ */ new Map(), dn = /* @__PURE__ */ new Map(), ca = /* @__PURE__ */ new Set();\nfunction cf(a, t, e, n, l) {\n  const { ownerDocument: s } = t, r = {\n    direction: e,\n    element: t,\n    hitAreaMargins: n,\n    setResizeHandlerState: l\n  }, i = ct.get(s) ?? 0;\n  return ct.set(s, i + 1), ca.add(r), za(), function() {\n    dn.delete(a), ca.delete(r);\n    const d = ct.get(s) ?? 1;\n    ct.set(s, d - 1), za(), d === 1 && ct.delete(s);\n  };\n}\nfunction Ta(a) {\n  const { target: t } = a, { x: e, y: n } = rn(a);\n  un = !0, Io({ target: t, x: e, y: n }), za(), ft.length > 0 && (To(\"down\", a), a.preventDefault());\n}\nfunction it(a) {\n  const { x: t, y: e } = rn(a);\n  if (!un) {\n    const { target: n } = a;\n    Io({ target: n, x: t, y: e });\n  }\n  To(\"move\", a), js(), ft.length > 0 && a.preventDefault();\n}\nfunction ut(a) {\n  const { target: t } = a, { x: e, y: n } = rn(a);\n  dn.clear(), un = !1, ft.length > 0 && a.preventDefault(), To(\"up\", a), Io({ target: t, x: e, y: n }), js(), za();\n}\nfunction Io({\n  target: a,\n  x: t,\n  y: e\n}) {\n  ft.splice(0);\n  let n = null;\n  a instanceof HTMLElement && (n = a), ca.forEach((l) => {\n    const { element: s, hitAreaMargins: r } = l, i = s.getBoundingClientRect(), { bottom: u, left: d, right: c, top: p } = i, f = df ? r.coarse : r.fine;\n    if (t >= d - f && t <= c + f && e >= p - f && e <= u + f) {\n      if (n !== null && s !== n && !s.contains(n) && !n.contains(s) && of(n, s) > 0) {\n        let g = n, m = !1;\n        for (; g && !g.contains(s); ) {\n          if (nf(\n            g.getBoundingClientRect(),\n            i\n          )) {\n            m = !0;\n            break;\n          }\n          g = g.parentElement;\n        }\n        if (m)\n          return;\n      }\n      ft.push(l);\n    }\n  });\n}\nfunction En(a, t) {\n  dn.set(a, t);\n}\nfunction js() {\n  let a = !1, t = !1;\n  ft.forEach((n) => {\n    const { direction: l } = n;\n    l === \"horizontal\" ? a = !0 : t = !0;\n  });\n  let e = 0;\n  dn.forEach((n) => {\n    e |= n;\n  }), a && t ? Sn(\"intersection\", e) : a ? Sn(\"horizontal\", e) : t ? Sn(\"vertical\", e) : tf();\n}\nfunction za() {\n  ct.forEach((a, t) => {\n    const { body: e } = t;\n    e.removeEventListener(\"contextmenu\", ut), e.removeEventListener(\"mousedown\", Ta), e.removeEventListener(\"mouseleave\", it), e.removeEventListener(\"mousemove\", it), e.removeEventListener(\"touchmove\", it), e.removeEventListener(\"touchstart\", Ta);\n  }), window.removeEventListener(\"mouseup\", ut), window.removeEventListener(\"touchcancel\", ut), window.removeEventListener(\"touchend\", ut), ca.size > 0 && (un ? (ft.length > 0 && ct.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"contextmenu\", ut), e.addEventListener(\"mouseleave\", it), e.addEventListener(\"mousemove\", it), e.addEventListener(\"touchmove\", it, {\n      passive: !1\n    }));\n  }), window.addEventListener(\"mouseup\", ut), window.addEventListener(\"touchcancel\", ut), window.addEventListener(\"touchend\", ut)) : ct.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"mousedown\", Ta), e.addEventListener(\"mousemove\", it), e.addEventListener(\"touchmove\", it, {\n      passive: !1\n    }), e.addEventListener(\"touchstart\", Ta));\n  }));\n}\nfunction To(a, t) {\n  ca.forEach((e) => {\n    const { setResizeHandlerState: n } = e, l = ft.includes(e);\n    n(a, l, t);\n  });\n}\nconst Ro = 10;\nfunction pa(a, t, e = Ro) {\n  a = Number.parseFloat(a.toFixed(e)), t = Number.parseFloat(t.toFixed(e));\n  const n = a - t;\n  return n === 0 ? 0 : n > 0 ? 1 : -1;\n}\nfunction Fe(a, t, e) {\n  return pa(a, t, e) === 0;\n}\nfunction Lt({\n  panelConstraints: a,\n  panelIndex: t,\n  size: e\n}) {\n  const n = a[t];\n  de(n != null);\n  const { collapsedSize: l = 0, collapsible: s, maxSize: r = 100, minSize: i = 0 } = n;\n  if (pa(e, i) < 0)\n    if (s) {\n      const u = (l + i) / 2;\n      pa(e, u) < 0 ? e = l : e = i;\n    } else\n      e = i;\n  return e = Math.min(r, e), e = Number.parseFloat(e.toFixed(Ro)), e;\n}\nfunction Ra(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction la({\n  delta: a,\n  layout: t,\n  panelConstraints: e,\n  pivotIndices: n,\n  trigger: l\n}) {\n  if (Fe(a, 0))\n    return t;\n  const s = [...t], [r, i] = n;\n  de(r != null), de(i != null);\n  let u = 0;\n  if (l === \"keyboard\") {\n    {\n      const c = a < 0 ? i : r, p = e[c];\n      if (de(p), p.collapsible) {\n        const f = t[c];\n        de(f != null);\n        const v = e[c];\n        de(v);\n        const { collapsedSize: g = 0, minSize: m = 0 } = v;\n        if (Fe(f, g)) {\n          const S = m - f;\n          pa(S, Math.abs(a)) > 0 && (a = a < 0 ? 0 - S : S);\n        }\n      }\n    }\n    {\n      const c = a < 0 ? r : i, p = e[c];\n      de(p);\n      const { collapsible: f } = p;\n      if (f) {\n        const v = t[c];\n        de(v != null);\n        const g = e[c];\n        de(g);\n        const { collapsedSize: m = 0, minSize: S = 0 } = g;\n        if (Fe(v, S)) {\n          const x = v - m;\n          pa(x, Math.abs(a)) > 0 && (a = a < 0 ? 0 - x : x);\n        }\n      }\n    }\n  }\n  {\n    const c = a < 0 ? 1 : -1;\n    let p = a < 0 ? i : r, f = 0;\n    for (; ; ) {\n      const g = t[p];\n      de(g != null);\n      const S = Lt({\n        panelConstraints: e,\n        panelIndex: p,\n        size: 100\n      }) - g;\n      if (f += S, p += c, p < 0 || p >= e.length)\n        break;\n    }\n    const v = Math.min(Math.abs(a), Math.abs(f));\n    a = a < 0 ? 0 - v : v;\n  }\n  {\n    let p = a < 0 ? r : i;\n    for (; p >= 0 && p < e.length; ) {\n      const f = Math.abs(a) - Math.abs(u), v = t[p];\n      de(v != null);\n      const g = v - f, m = Lt({\n        panelConstraints: e,\n        panelIndex: p,\n        size: g\n      });\n      if (!Fe(v, m) && (u += v - m, s[p] = m, u.toPrecision(3).localeCompare(Math.abs(a).toPrecision(3), void 0, {\n        numeric: !0\n      }) >= 0))\n        break;\n      a < 0 ? p-- : p++;\n    }\n  }\n  if (Fe(u, 0))\n    return t;\n  {\n    const c = a < 0 ? i : r, p = t[c];\n    de(p != null);\n    const f = p + u, v = Lt({\n      panelConstraints: e,\n      panelIndex: c,\n      size: f\n    });\n    if (s[c] = v, !Fe(v, f)) {\n      let g = f - v, S = a < 0 ? i : r;\n      for (; S >= 0 && S < e.length; ) {\n        const x = s[S];\n        de(x != null);\n        const D = x + g, h = Lt({\n          panelConstraints: e,\n          panelIndex: S,\n          size: D\n        });\n        if (Fe(x, h) || (g -= h - x, s[S] = h), Fe(g, 0))\n          break;\n        a > 0 ? S-- : S++;\n      }\n    }\n  }\n  const d = s.reduce((c, p) => p + c, 0);\n  return Fe(d, 100) ? s : t;\n}\nfunction Us(a, t = document) {\n  var n;\n  if (!ma)\n    return null;\n  if (t instanceof HTMLElement && ((n = t == null ? void 0 : t.dataset) == null ? void 0 : n.panelGroupId) === a)\n    return t;\n  const e = t.querySelector(\n    `[data-panel-group][data-panel-group-id=\"${a}\"]`\n  );\n  return e || null;\n}\nfunction cn(a, t = document) {\n  if (!ma)\n    return null;\n  const e = t.querySelector(`[data-panel-resize-handle-id=\"${a}\"]`);\n  return e || null;\n}\nfunction Gs(a, t, e = document) {\n  return ma ? fa(a, e).findIndex(\n    (s) => s.getAttribute(\"data-panel-resize-handle-id\") === t\n  ) ?? null : null;\n}\nfunction fa(a, t = document) {\n  return ma ? Array.from(\n    t.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${a}\"]`\n    )\n  ) : [];\n}\nfunction pf(a, t, e, n = document) {\n  var d, c;\n  const l = cn(t, n), s = fa(a, n), r = l ? s.indexOf(l) : -1, i = ((d = e[r]) == null ? void 0 : d.id) ?? null, u = ((c = e[r + 1]) == null ? void 0 : c.id) ?? null;\n  return [i, u];\n}\nfunction ff(a, t, e, n, l) {\n  const s = e === \"horizontal\", r = cn(t, l);\n  de(r);\n  const i = r.getAttribute(\"data-panel-group-id\");\n  de(i);\n  const { initialCursorPosition: u } = n, d = Ls(e, a), c = Us(i, l);\n  de(c);\n  const p = c.getBoundingClientRect(), f = s ? p.width : p.height;\n  return (d - u) / f * 100;\n}\nfunction vf(a, t, e, n, l, s) {\n  if (Ms(a)) {\n    const r = e === \"horizontal\";\n    let i = 0;\n    a.shiftKey ? i = 100 : i = l ?? 10;\n    let u = 0;\n    switch (a.key) {\n      case \"ArrowDown\":\n        u = r ? 0 : i;\n        break;\n      case \"ArrowLeft\":\n        u = r ? -i : 0;\n        break;\n      case \"ArrowRight\":\n        u = r ? i : 0;\n        break;\n      case \"ArrowUp\":\n        u = r ? 0 : -i;\n        break;\n      case \"End\":\n        u = 100;\n        break;\n      case \"Home\":\n        u = -100;\n        break;\n    }\n    return u;\n  } else\n    return n == null ? 0 : ff(\n      a,\n      t,\n      e,\n      n,\n      s\n    );\n}\nfunction mf({\n  layout: a,\n  panelsArray: t,\n  pivotIndices: e\n}) {\n  let n = 0, l = 100, s = 0, r = 0;\n  const i = e[0];\n  de(i != null), t.forEach((p, f) => {\n    const { constraints: v } = p, { maxSize: g = 100, minSize: m = 0 } = v;\n    f === i ? (n = m, l = g) : (s += m, r += g);\n  });\n  const u = Math.min(l, 100 - s), d = Math.max(n, 100 - r), c = a[i];\n  return {\n    valueMax: u,\n    valueMin: d,\n    valueNow: c\n  };\n}\nfunction hf({\n  panelDataArray: a\n}) {\n  const t = Array(a.length), e = a.map(\n    (s) => s.constraints\n  );\n  let n = 0, l = 100;\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    de(r);\n    const { defaultSize: i } = r;\n    i != null && (n++, t[s] = i, l -= i);\n  }\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    de(r);\n    const { defaultSize: i } = r;\n    if (i != null)\n      continue;\n    const u = a.length - n, d = l / u;\n    n++, t[s] = d, l -= d;\n  }\n  return t;\n}\nfunction oa(a, t, e) {\n  t.forEach((n, l) => {\n    const s = a[l];\n    de(s);\n    const { callbacks: r, constraints: i, id: u } = s, { collapsedSize: d = 0, collapsible: c } = i, p = e[u];\n    if (p == null || n !== p) {\n      e[u] = n;\n      const { onCollapse: f, onExpand: v, onResize: g } = r;\n      g && g(n, p), c && (f || v) && (v && (p == null || p === d) && n !== d && v(), f && (p == null || p !== d) && n === d && f());\n    }\n  });\n}\nfunction yf(a, t = 10) {\n  let e = null;\n  return (...l) => {\n    e !== null && clearTimeout(e), e = setTimeout(() => {\n      a(...l);\n    }, t);\n  };\n}\nfunction qs(a, t, e) {\n  const n = Gs(\n    a,\n    t,\n    e\n  );\n  return n != null ? [n, n + 1] : [-1, -1];\n}\nfunction gf({\n  layout: a,\n  panelConstraints: t\n}) {\n  const e = [...a], n = e.reduce(\n    (s, r) => s + r,\n    0\n  );\n  if (e.length !== t.length)\n    throw new Error(\n      `Invalid ${t.length} panel layout: ${e.map((s) => `${s}%`).join(\", \")}`\n    );\n  if (!Fe(n, 100)) {\n    console.warn(\n      `WARNING: Invalid layout total size: ${e.map((s) => `${s}%`).join(\", \")}. Layout normalization will be applied.`\n    );\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      de(r != null);\n      const i = 100 / n * r;\n      e[s] = i;\n    }\n  }\n  let l = 0;\n  for (let s = 0; s < t.length; s++) {\n    const r = e[s];\n    de(r != null);\n    const i = Lt({\n      panelConstraints: t,\n      panelIndex: s,\n      size: r\n    });\n    r !== i && (l += r - i, e[s] = i);\n  }\n  if (!Fe(l, 0))\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      de(r != null);\n      const i = r + l, u = Lt({\n        panelConstraints: t,\n        panelIndex: s,\n        size: i\n      });\n      if (r !== u && (l -= u - r, e[s] = u, Fe(l, 0)))\n        break;\n    }\n  return e;\n}\nfunction tl(a) {\n  try {\n    if (typeof localStorage < \"u\")\n      a.getItem = (t) => localStorage.getItem(t), a.setItem = (t, e) => {\n        localStorage.setItem(t, e);\n      };\n    else\n      throw new TypeError(\"localStorage not supported in this environment\");\n  } catch (t) {\n    console.error(t), a.getItem = () => null, a.setItem = () => {\n    };\n  }\n}\nfunction Ys(a) {\n  return `radix-vue:${a}`;\n}\nfunction Xs(a) {\n  return a.map((t) => {\n    const { constraints: e, id: n, idIsFromProps: l, order: s } = t;\n    return l ? n : s ? `${s}:${JSON.stringify(e)}` : JSON.stringify(e);\n  }).sort((t, e) => t.localeCompare(e)).join(\",\");\n}\nfunction Zs(a, t) {\n  try {\n    const e = Ys(a), n = t.getItem(e);\n    if (n) {\n      const l = JSON.parse(n);\n      if (typeof l == \"object\" && l != null)\n        return l;\n    }\n  } catch {\n  }\n  return null;\n}\nfunction bf(a, t, e) {\n  const n = Zs(a, e) ?? {}, l = Xs(t);\n  return n[l] ?? null;\n}\nfunction Cf(a, t, e, n, l) {\n  const s = Ys(a), r = Xs(t), i = Zs(a, l) ?? {};\n  i[r] = {\n    expandToSizes: Object.fromEntries(e.entries()),\n    layout: n\n  };\n  try {\n    l.setItem(s, JSON.stringify(i));\n  } catch (u) {\n    console.error(u);\n  }\n}\nfunction wf({\n  eagerValuesRef: a,\n  groupId: t,\n  layout: e,\n  panelDataArray: n,\n  panelGroupElement: l,\n  setLayout: s\n}) {\n  ye((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = fa(\n      t,\n      i\n    );\n    for (let d = 0; d < n.length - 1; d++) {\n      const { valueMax: c, valueMin: p, valueNow: f } = mf({\n        layout: e.value,\n        panelsArray: n,\n        pivotIndices: [d, d + 1]\n      }), v = u[d];\n      if (v != null) {\n        const g = n[d];\n        de(g), v.setAttribute(\"aria-controls\", g.id), v.setAttribute(\n          \"aria-valuemax\",\n          `${Math.round(c)}`\n        ), v.setAttribute(\n          \"aria-valuemin\",\n          `${Math.round(p)}`\n        ), v.setAttribute(\n          \"aria-valuenow\",\n          f != null ? `${Math.round(f)}` : \"\"\n        );\n      }\n    }\n    r(() => {\n      u.forEach((d) => {\n        d.removeAttribute(\"aria-controls\"), d.removeAttribute(\"aria-valuemax\"), d.removeAttribute(\"aria-valuemin\"), d.removeAttribute(\"aria-valuenow\");\n      });\n    });\n  }), ye((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = a.value;\n    de(u);\n    const { panelDataArray: d } = u, c = Us(t, i);\n    de(c != null, `No group found for id \"${t}\"`);\n    const p = fa(t, i);\n    de(p);\n    const f = p.map((v) => {\n      const g = v.getAttribute(\"data-panel-resize-handle-id\");\n      de(g);\n      const [m, S] = pf(\n        t,\n        g,\n        d,\n        i\n      );\n      if (m == null || S == null)\n        return () => {\n        };\n      const x = (D) => {\n        if (!D.defaultPrevented)\n          switch (D.key) {\n            case \"Enter\": {\n              D.preventDefault();\n              const h = d.findIndex(\n                (E) => E.id === m\n              );\n              if (h >= 0) {\n                const E = d[h];\n                de(E);\n                const P = e.value[h], {\n                  collapsedSize: $ = 0,\n                  collapsible: R,\n                  minSize: M = 0\n                } = E.constraints;\n                if (P != null && R) {\n                  const V = la({\n                    delta: Fe(P, $) ? M - $ : $ - P,\n                    layout: e.value,\n                    panelConstraints: d.map(\n                      (A) => A.constraints\n                    ),\n                    pivotIndices: qs(\n                      t,\n                      g,\n                      i\n                    ),\n                    trigger: \"keyboard\"\n                  });\n                  e.value !== V && s(V);\n                }\n              }\n              break;\n            }\n          }\n      };\n      return v.addEventListener(\"keydown\", x), () => {\n        v.removeEventListener(\"keydown\", x);\n      };\n    });\n    r(() => {\n      f.forEach((v) => v());\n    });\n  });\n}\nconst _f = 100, sa = {\n  getItem: (a) => (tl(sa), sa.getItem(a)),\n  setItem: (a, t) => {\n    tl(sa), sa.setItem(a, t);\n  }\n}, [Js, xf] = Q(\"PanelGroup\"), qy = /* @__PURE__ */ w({\n  __name: \"SplitterGroup\",\n  props: {\n    id: {},\n    autoSaveId: { default: null },\n    direction: {},\n    keyboardResizeBy: { default: 10 },\n    storage: { default: () => sa },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"layout\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = {}, s = me(e.id, \"radix-vue-splitter-group\"), r = be(), { forwardRef: i, currentElement: u } = T(), d = I(null), c = I([]), p = I({}), f = I(/* @__PURE__ */ new Map()), v = I(0), g = B(() => ({\n      autoSaveId: e.autoSaveId,\n      direction: e.direction,\n      dragState: d.value,\n      id: s,\n      keyboardResizeBy: e.keyboardResizeBy,\n      storage: e.storage\n    })), m = I({\n      layout: c.value,\n      panelDataArray: [],\n      panelDataArrayChanged: !1\n    }), S = (F) => c.value = F;\n    wf({\n      eagerValuesRef: m,\n      groupId: s,\n      layout: c,\n      panelDataArray: m.value.panelDataArray,\n      setLayout: S,\n      panelGroupElement: u\n    }), ye(() => {\n      const { panelDataArray: F } = m.value, { autoSaveId: W } = e;\n      if (W) {\n        if (c.value.length === 0 || c.value.length !== F.length)\n          return;\n        let z = l[W];\n        z || (z = yf(\n          Cf,\n          _f\n        ), l[W] = z);\n        const X = [...F], G = new Map(\n          f.value\n        );\n        z(\n          W,\n          X,\n          G,\n          c.value,\n          e.storage\n        );\n      }\n    });\n    function x(F, W) {\n      const { panelDataArray: z } = m.value, X = J(z, F);\n      return af({\n        defaultSize: W,\n        dragState: d.value,\n        layout: c.value,\n        panelData: z,\n        panelIndex: X\n      });\n    }\n    function D(F) {\n      const { panelDataArray: W } = m.value;\n      W.push(F), W.sort((z, X) => {\n        const G = z.order, Z = X.order;\n        return G == null && Z == null ? 0 : G == null ? -1 : Z == null ? 1 : G - Z;\n      }), m.value.panelDataArrayChanged = !0;\n    }\n    te(() => m.value.panelDataArrayChanged, () => {\n      if (m.value.panelDataArrayChanged) {\n        m.value.panelDataArrayChanged = !1;\n        const { autoSaveId: F, storage: W } = g.value, { layout: z, panelDataArray: X } = m.value;\n        let G = null;\n        if (F) {\n          const ee = bf(F, X, W);\n          ee && (f.value = new Map(\n            Object.entries(ee.expandToSizes)\n          ), G = ee.layout);\n        }\n        G === null && (G = hf({\n          panelDataArray: X\n        }));\n        const Z = gf({\n          layout: G,\n          panelConstraints: X.map(\n            (ee) => ee.constraints\n          )\n        });\n        Mr(z, Z) || (S(Z), m.value.layout = Z, n(\"layout\", Z), oa(\n          X,\n          Z,\n          p.value\n        ));\n      }\n    });\n    function h(F) {\n      return function(z) {\n        z.preventDefault();\n        const X = u.value;\n        if (!X)\n          return () => null;\n        const { direction: G, dragState: Z, id: ee, keyboardResizeBy: fe } = g.value, { layout: q, panelDataArray: oe } = m.value, { initialLayout: he } = Z ?? {}, Ce = qs(\n          ee,\n          F,\n          X\n        );\n        let ge = vf(\n          z,\n          F,\n          G,\n          Z,\n          fe,\n          X\n        );\n        if (ge === 0)\n          return;\n        const De = G === \"horizontal\";\n        r.value === \"rtl\" && De && (ge = -ge);\n        const ue = oe.map((Ke) => Ke.constraints), Se = la({\n          delta: ge,\n          layout: he ?? q,\n          panelConstraints: ue,\n          pivotIndices: Ce,\n          trigger: Ms(z) ? \"keyboard\" : \"mouse-or-touch\"\n        }), Ve = !Ra(q, Se);\n        (Vs(z) || Fs(z)) && v.value !== ge && (v.value = ge, Ve ? En(F, 0) : De ? En(\n          F,\n          ge < 0 ? zs : Ks\n        ) : En(\n          F,\n          ge < 0 ? Hs : Ws\n        )), Ve && (S(Se), m.value.layout = Se, n(\"layout\", Se), oa(\n          oe,\n          Se,\n          p.value\n        ));\n      };\n    }\n    function E(F, W) {\n      const { layout: z, panelDataArray: X } = m.value, G = X.map((he) => he.constraints), { panelSize: Z, pivotIndices: ee } = N(\n        X,\n        F,\n        z\n      );\n      de(Z != null);\n      const q = J(X, F) === X.length - 1 ? Z - W : W - Z, oe = la({\n        delta: q,\n        layout: z,\n        panelConstraints: G,\n        pivotIndices: ee,\n        trigger: \"imperative-api\"\n      });\n      Ra(z, oe) || (S(oe), m.value.layout = oe, n(\"layout\", oe), oa(\n        X,\n        oe,\n        p.value\n      ));\n    }\n    function P(F, W) {\n      const { layout: z, panelDataArray: X } = m.value, G = J(X, F);\n      X[G] = F, m.value.panelDataArrayChanged = !0;\n      const {\n        collapsedSize: Z = 0,\n        collapsible: ee\n      } = W, {\n        collapsedSize: fe = 0,\n        collapsible: q,\n        maxSize: oe = 100,\n        minSize: he = 0\n      } = F.constraints, { panelSize: Ce } = N(\n        X,\n        F,\n        z\n      );\n      Ce !== null && (ee && q && Ce === Z ? Z !== fe && E(F, fe) : Ce < he ? E(F, he) : Ce > oe && E(F, oe));\n    }\n    function $(F, W) {\n      const { direction: z } = g.value, { layout: X } = m.value;\n      if (!u.value)\n        return;\n      const G = cn(\n        F,\n        u.value\n      );\n      de(G);\n      const Z = Ls(\n        z,\n        W\n      );\n      d.value = {\n        dragHandleId: F,\n        dragHandleRect: G.getBoundingClientRect(),\n        initialCursorPosition: Z,\n        initialLayout: X\n      };\n    }\n    function R() {\n      d.value = null;\n    }\n    function M(F) {\n      const { panelDataArray: W } = m.value, z = J(W, F);\n      z >= 0 && (W.splice(z, 1), delete p.value[F.id], m.value.panelDataArrayChanged = !0);\n    }\n    function V(F) {\n      const { layout: W, panelDataArray: z } = m.value;\n      if (F.constraints.collapsible) {\n        const X = z.map(\n          (fe) => fe.constraints\n        ), {\n          collapsedSize: G = 0,\n          panelSize: Z,\n          pivotIndices: ee\n        } = N(z, F, W);\n        if (de(\n          Z != null,\n          `Panel size not found for panel \"${F.id}\"`\n        ), Z !== G) {\n          f.value.set(F.id, Z);\n          const q = J(z, F) === z.length - 1 ? Z - G : G - Z, oe = la({\n            delta: q,\n            layout: W,\n            panelConstraints: X,\n            pivotIndices: ee,\n            trigger: \"imperative-api\"\n          });\n          Ra(W, oe) || (S(oe), m.value.layout = oe, n(\"layout\", oe), oa(\n            z,\n            oe,\n            p.value\n          ));\n        }\n      }\n    }\n    function A(F) {\n      const { layout: W, panelDataArray: z } = m.value;\n      if (F.constraints.collapsible) {\n        const X = z.map(\n          (q) => q.constraints\n        ), {\n          collapsedSize: G = 0,\n          panelSize: Z,\n          minSize: ee = 0,\n          pivotIndices: fe\n        } = N(z, F, W);\n        if (Z === G) {\n          const q = f.value.get(\n            F.id\n          ), oe = q != null && q >= ee ? q : ee, Ce = J(z, F) === z.length - 1 ? Z - oe : oe - Z, ge = la({\n            delta: Ce,\n            layout: W,\n            panelConstraints: X,\n            pivotIndices: fe,\n            trigger: \"imperative-api\"\n          });\n          Ra(W, ge) || (S(ge), m.value.layout = ge, n(\"layout\", ge), oa(\n            z,\n            ge,\n            p.value\n          ));\n        }\n      }\n    }\n    function L(F) {\n      const { layout: W, panelDataArray: z } = m.value, { panelSize: X } = N(z, F, W);\n      return de(\n        X != null,\n        `Panel size not found for panel \"${F.id}\"`\n      ), X;\n    }\n    function U(F) {\n      const { layout: W, panelDataArray: z } = m.value, {\n        collapsedSize: X = 0,\n        collapsible: G,\n        panelSize: Z\n      } = N(z, F, W);\n      return G === !0 && Z === X;\n    }\n    function H(F) {\n      const { layout: W, panelDataArray: z } = m.value, {\n        collapsedSize: X = 0,\n        collapsible: G,\n        panelSize: Z\n      } = N(z, F, W);\n      return de(\n        Z != null,\n        `Panel size not found for panel \"${F.id}\"`\n      ), !G || Z > X;\n    }\n    xf({\n      direction: e.direction,\n      dragState: d.value,\n      groupId: s,\n      reevaluatePanelConstraints: P,\n      registerPanel: D,\n      registerResizeHandle: h,\n      resizePanel: E,\n      startDragging: $,\n      stopDragging: R,\n      unregisterPanel: M,\n      panelGroupElement: u,\n      collapsePanel: V,\n      expandPanel: A,\n      isPanelCollapsed: U,\n      isPanelExpanded: H,\n      getPanelSize: L,\n      getPanelStyle: x\n    });\n    function J(F, W) {\n      return F.findIndex(\n        (z) => z === W || z.id === W.id\n      );\n    }\n    function N(F, W, z) {\n      const X = J(F, W), Z = X === F.length - 1 ? [X - 1, X] : [X, X + 1], ee = z[X];\n      return {\n        ...W.constraints,\n        panelSize: ee,\n        pivotIndices: Z\n      };\n    }\n    return (F, W) => (b(), _(o(O), {\n      ref: o(i),\n      as: F.as,\n      \"as-child\": F.asChild,\n      style: Oe({\n        display: \"flex\",\n        flexDirection: F.direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n      }),\n      \"data-panel-group\": \"\",\n      \"data-orientation\": F.direction,\n      \"data-panel-group-id\": o(s)\n    }, {\n      default: y(() => [\n        C(F.$slots, \"default\", { layout: c.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\", \"data-orientation\", \"data-panel-group-id\"]));\n  }\n}), Yy = /* @__PURE__ */ w({\n  __name: \"SplitterPanel\",\n  props: {\n    collapsedSize: {},\n    collapsible: { type: Boolean },\n    defaultSize: {},\n    id: {},\n    maxSize: {},\n    minSize: {},\n    order: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"collapse\", \"expand\", \"resize\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = Js();\n    if (s === null)\n      throw new Error(\n        \"SplitterPanel components must be rendered within a SplitterGroup container\"\n      );\n    const { collapsePanel: r, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: p, groupId: f, reevaluatePanelConstraints: v, registerPanel: g, unregisterPanel: m } = s, S = me(n.id, \"radix-vue-splitter-panel\"), x = B(() => ({\n      callbacks: {\n        onCollapse: () => l(\"collapse\"),\n        onExpand: () => l(\"expand\"),\n        onResize: (...P) => l(\"resize\", ...P)\n      },\n      constraints: {\n        collapsedSize: n.collapsedSize && Number.parseFloat(n.collapsedSize.toFixed(Ro)),\n        collapsible: n.collapsible,\n        defaultSize: n.defaultSize,\n        /** Panel id (unique within group); falls back to useId when not provided */\n        /** Panel id (unique within group); falls back to useId when not provided */\n        maxSize: n.maxSize,\n        minSize: n.minSize\n      },\n      id: S,\n      idIsFromProps: n.id !== void 0,\n      order: n.order\n    }));\n    te(() => x.value.constraints, (P, $) => {\n      ($.collapsedSize !== P.collapsedSize || $.collapsible !== P.collapsible || $.maxSize !== P.maxSize || $.minSize !== P.minSize) && v(x.value, $);\n    }, { deep: !0 }), se(() => {\n      const P = x.value;\n      g(P), Ie(() => {\n        m(P);\n      });\n    });\n    const D = B(() => d(x.value, n.defaultSize)), h = B(() => c(x.value)), E = B(() => !h.value);\n    return t({\n      /** If panel is `collapsible`, collapse it fully. */\n      collapse: () => {\n        r(x.value);\n      },\n      /** If panel is currently collapsed, expand it to its most recent size. */\n      expand: () => {\n        i(x.value);\n      },\n      /** Gets the current size of the panel as a percentage (1 - 100). */\n      getSize() {\n        return u(x.value);\n      },\n      /** Resize panel to the specified percentage (1 - 100). */\n      resize: (P) => {\n        p(x.value, P);\n      },\n      /** Returns `true` if the panel is currently collapsed */\n      isCollapsed: h,\n      /** Returns `true` if the panel is currently not collapsed */\n      isExpanded: E\n    }), (P, $) => (b(), _(o(O), {\n      id: o(S),\n      style: Oe(D.value),\n      as: P.as,\n      \"as-child\": P.asChild,\n      \"data-panel\": \"\",\n      \"data-panel-collapsible\": P.collapsible || void 0,\n      \"data-panel-group-id\": o(f),\n      \"data-panel-id\": o(S),\n      \"data-panel-size\": Number.parseFloat(`${D.value.flexGrow}`).toFixed(1),\n      \"data-state\": P.collapsible ? h.value ? \"collapsed\" : \"expanded\" : void 0\n    }, {\n      default: y(() => [\n        C(P.$slots, \"default\", {\n          isCollapsed: h.value,\n          isExpanded: E.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"id\", \"style\", \"as\", \"as-child\", \"data-panel-collapsible\", \"data-panel-group-id\", \"data-panel-id\", \"data-panel-size\", \"data-state\"]));\n  }\n});\nfunction Sf({\n  disabled: a,\n  handleId: t,\n  resizeHandler: e,\n  panelGroupElement: n\n}) {\n  ye((l) => {\n    const s = n.value;\n    if (a.value || e.value === null || s === null)\n      return;\n    const r = cn(t, s);\n    if (r == null)\n      return;\n    const i = (u) => {\n      var d;\n      if (!u.defaultPrevented)\n        switch (u.key) {\n          case \"ArrowDown\":\n          case \"ArrowLeft\":\n          case \"ArrowRight\":\n          case \"ArrowUp\":\n          case \"End\":\n          case \"Home\": {\n            u.preventDefault(), (d = e.value) == null || d.call(e, u);\n            break;\n          }\n          case \"F6\": {\n            u.preventDefault();\n            const c = r.getAttribute(\"data-panel-group-id\");\n            de(c);\n            const p = fa(\n              c,\n              s\n            ), f = Gs(\n              c,\n              t,\n              s\n            );\n            de(f !== null);\n            const v = u.shiftKey ? f > 0 ? f - 1 : p.length - 1 : f + 1 < p.length ? f + 1 : 0;\n            p[v].focus();\n            break;\n          }\n        }\n    };\n    r.addEventListener(\"keydown\", i), l(() => {\n      r.removeEventListener(\"keydown\", i);\n    });\n  });\n}\nconst Xy = /* @__PURE__ */ w({\n  __name: \"SplitterResizeHandle\",\n  props: {\n    id: {},\n    hitAreaMargins: {},\n    tabindex: { default: 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"dragging\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), { disabled: r } = ne(e), i = Js();\n    if (i === null)\n      throw new Error(\n        \"PanelResizeHandle components must be rendered within a PanelGroup container\"\n      );\n    const {\n      direction: u,\n      groupId: d,\n      registerResizeHandle: c,\n      startDragging: p,\n      stopDragging: f,\n      panelGroupElement: v\n    } = i, g = me(e.id, \"radix-vue-splitter-resize-handle\"), m = I(\"inactive\"), S = I(!1), x = I(null);\n    return te(r, () => {\n      ma && (r.value ? x.value = null : x.value = c(g));\n    }, { immediate: !0 }), ye((D) => {\n      var P, $;\n      if (r.value || x.value === null)\n        return;\n      const h = s.value;\n      if (!h)\n        return;\n      de(h);\n      const E = (R, M, V) => {\n        var A;\n        if (M)\n          switch (R) {\n            case \"down\": {\n              m.value = \"drag\", p(g, V), n(\"dragging\", !0);\n              break;\n            }\n            case \"move\": {\n              m.value !== \"drag\" && (m.value = \"hover\"), (A = x.value) == null || A.call(x, V);\n              break;\n            }\n            case \"up\": {\n              m.value = \"hover\", f(), n(\"dragging\", !1);\n              break;\n            }\n          }\n        else\n          m.value = \"inactive\";\n      };\n      D(cf(\n        g,\n        h,\n        u,\n        {\n          // Coarse inputs (e.g. finger/touch)\n          coarse: ((P = e.hitAreaMargins) == null ? void 0 : P.coarse) ?? 15,\n          // Fine inputs (e.g. mouse)\n          fine: (($ = e.hitAreaMargins) == null ? void 0 : $.fine) ?? 5\n        },\n        E\n      ));\n    }), Sf({\n      disabled: r,\n      resizeHandler: x,\n      handleId: g,\n      panelGroupElement: v\n    }), (D, h) => (b(), _(o(O), {\n      id: o(g),\n      ref: o(l),\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      },\n      as: D.as,\n      \"as-child\": D.asChild,\n      role: \"separator\",\n      \"data-resize-handle\": \"\",\n      tabindex: D.tabindex,\n      \"data-state\": m.value,\n      \"data-disabled\": o(r) ? \"\" : void 0,\n      \"data-orientation\": o(u),\n      \"data-panel-group-id\": o(d),\n      \"data-resize-handle-active\": m.value === \"drag\" ? \"pointer\" : S.value ? \"keyboard\" : void 0,\n      \"data-resize-handle-state\": m.value,\n      \"data-panel-resize-handle-enabled\": !o(r),\n      \"data-panel-resize-handle-id\": o(g),\n      onBlur: h[0] || (h[0] = (E) => S.value = !1),\n      onFocus: h[1] || (h[1] = (E) => S.value = !1)\n    }, {\n      default: y(() => [\n        C(D.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"tabindex\", \"data-state\", \"data-disabled\", \"data-orientation\", \"data-panel-group-id\", \"data-resize-handle-active\", \"data-resize-handle-state\", \"data-panel-resize-handle-enabled\", \"data-panel-resize-handle-id\"]));\n  }\n}), Ef = {\n  \"aria-live\": \"polite\",\n  \"aria-atomic\": \"true\",\n  role: \"status\",\n  style: {\n    transform: \"translateX(-100%)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    opacity: 0,\n    margin: 0\n  }\n}, [Ao, Pf] = Q(\"StepperRoot\"), Zy = /* @__PURE__ */ w({\n  __name: \"StepperRoot\",\n  props: {\n    defaultValue: { default: 1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    modelValue: {},\n    linear: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, orientation: s, linear: r } = ne(e), i = be(l);\n    T();\n    const u = I(/* @__PURE__ */ new Set()), d = I(/* @__PURE__ */ new Set()), c = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    });\n    return Pf({\n      modelValue: c,\n      changeModelValue: (p) => {\n        c.value = p;\n      },\n      orientation: s,\n      dir: i,\n      linear: r,\n      stepperItems: u,\n      totalStepperItems: d\n    }), (p, f) => (b(), _(o(O), {\n      role: \"group\",\n      \"aria-label\": \"progress\",\n      as: p.as,\n      \"as-child\": p.asChild,\n      \"data-linear\": o(r) ? \"\" : void 0,\n      \"data-orientation\": p.orientation\n    }, {\n      default: y(() => [\n        C(p.$slots, \"default\", { modelValue: o(c) }),\n        Ue(\"div\", Ef, \" Step \" + $e(o(c)) + \" of \" + $e(d.value.size), 1)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-linear\", \"data-orientation\"]));\n  }\n}), [xa, Df] = Q(\"StepperItem\"), Jy = /* @__PURE__ */ w({\n  __name: \"StepperItem\",\n  props: {\n    step: {},\n    disabled: { type: Boolean, default: !1 },\n    completed: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e, step: n, completed: l } = ne(t), { forwardRef: s } = T(), r = Ao(), i = me(void 0, \"radix-vue-stepper-item-title\"), u = me(void 0, \"radix-vue-stepper-item-description\"), d = B(() => l.value ? \"completed\" : r.modelValue.value === n.value ? \"active\" : r.modelValue.value > n.value ? \"completed\" : \"inactive\"), c = B(() => e.value ? !1 : r.linear.value ? n.value <= r.modelValue.value || n.value === r.modelValue.value + 1 : !0);\n    return Df({\n      titleId: i,\n      descriptionId: u,\n      state: d,\n      disabled: e,\n      step: n,\n      isFocusable: c\n    }), (p, f) => (b(), _(o(O), {\n      ref: o(s),\n      as: p.as,\n      \"as-child\": p.asChild,\n      \"aria-current\": d.value === \"active\" ? \"true\" : void 0,\n      \"data-state\": d.value,\n      disabled: o(e) || !c.value ? \"\" : void 0,\n      \"data-disabled\": o(e) || !c.value ? \"\" : void 0,\n      \"data-orientation\": o(r).orientation.value\n    }, {\n      default: y(() => [\n        C(p.$slots, \"default\", { state: d.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-current\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Qy = /* @__PURE__ */ w({\n  __name: \"StepperTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = Ao(), e = xa(), n = et(), l = B(() => Array.from(t.stepperItems.value));\n    function s(d) {\n      if (!e.disabled.value) {\n        if (t.linear.value) {\n          if ((e.step.value <= t.modelValue.value || e.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {\n            t.changeModelValue(e.step.value);\n            return;\n          }\n        } else if (d.ctrlKey === !1) {\n          t.changeModelValue(e.step.value);\n          return;\n        }\n        d.preventDefault();\n      }\n    }\n    function r(d) {\n      d.preventDefault(), !e.disabled.value && ((d.key === n.ENTER || d.key === n.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(e.step.value), [n.ARROW_LEFT, n.ARROW_RIGHT, n.ARROW_UP, n.ARROW_DOWN].includes(d.key) && $t(d, document.activeElement, void 0, {\n        itemsArray: l.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: t.orientation.value,\n        dir: t.dir.value\n      }));\n    }\n    const { forwardRef: i, currentElement: u } = T();\n    return se(() => {\n      e.isFocusable.value && t.stepperItems.value.add(u.value), t.totalStepperItems.value.add(u.value);\n    }), Ie(() => {\n      t.stepperItems.value.delete(u.value), t.totalStepperItems.value.delete(u.value);\n    }), te(e.isFocusable, (d) => {\n      d ? t.stepperItems.value.add(u.value) : t.stepperItems.value.delete(u.value);\n    }), (d, c) => (b(), _(o(O), {\n      ref: o(i),\n      type: d.as === \"button\" ? \"button\" : void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      \"data-state\": o(e).state.value,\n      disabled: o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      tabindex: o(e).isFocusable.value ? 0 : -1,\n      \"aria-describedby\": o(e).descriptionId,\n      \"aria-labelledby\": o(e).titleId,\n      onMousedown: ie(s, [\"left\"]),\n      onKeydown: re(r, [\"enter\", \"space\", \"left\", \"right\", \"up\", \"down\"])\n    }, {\n      default: y(() => [\n        C(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\", \"tabindex\", \"aria-describedby\", \"aria-labelledby\"]));\n  }\n}), eg = /* @__PURE__ */ w({\n  __name: \"StepperDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = xa();\n    return (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), tg = /* @__PURE__ */ w({\n  __name: \"StepperTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h4\" }\n  },\n  setup(a) {\n    const t = a, e = xa();\n    return T(), (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), ag = /* @__PURE__ */ w({\n  __name: \"StepperIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = xa();\n    return T(), (n, l) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve(\" Step \" + $e(o(e).step.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ng = /* @__PURE__ */ w({\n  __name: \"StepperSeparator\",\n  props: {\n    orientation: {},\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Ao(), n = xa();\n    return T(), (l, s) => (b(), _(o(Np), k(t, {\n      decorative: \"\",\n      orientation: o(e).orientation.value,\n      \"data-state\": o(n).state.value\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"orientation\", \"data-state\"]));\n  }\n}), $f = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [Bf, If] = Q(\"SwitchRoot\"), og = /* @__PURE__ */ w({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ne(e), s = ae(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function r() {\n      l.value || (s.value = !s.value);\n    }\n    const { forwardRef: i, currentElement: u } = T(), d = Qe(u), c = B(() => {\n      var p;\n      return e.id && u.value ? (p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText : void 0;\n    });\n    return If({\n      checked: s,\n      toggleCheck: r,\n      disabled: l\n    }), (p, f) => (b(), ce(_e, null, [\n      Y(o(O), k(p.$attrs, {\n        id: p.id,\n        ref: o(i),\n        role: \"switch\",\n        type: p.as === \"button\" ? \"button\" : void 0,\n        value: p.value,\n        \"aria-label\": p.$attrs[\"aria-label\"] || c.value,\n        \"aria-checked\": o(s),\n        \"aria-required\": p.required,\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        \"as-child\": p.asChild,\n        as: p.as,\n        disabled: o(l),\n        onClick: r,\n        onKeydown: re(ie(r, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: y(() => [\n          C(p.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      o(d) ? (b(), ce(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: p.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        disabled: o(l),\n        required: p.required,\n        value: p.value,\n        checked: !!o(s),\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, $f)) : pe(\"\", !0)\n    ], 64));\n  }\n}), lg = /* @__PURE__ */ w({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = Bf();\n    return T(), (e, n) => {\n      var l;\n      return b(), _(o(O), {\n        \"data-state\": (l = o(t).checked) != null && l.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: y(() => [\n          C(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [pn, Tf] = Q(\"TabsRoot\"), sg = /* @__PURE__ */ w({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { orientation: l, dir: s } = ne(e), r = be(s);\n    T();\n    const i = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = I();\n    return Tf({\n      modelValue: i,\n      changeModelValue: (d) => {\n        i.value = d;\n      },\n      orientation: l,\n      dir: r,\n      activationMode: e.activationMode,\n      baseId: me(void 0, \"radix-vue-tabs\"),\n      tabsList: u\n    }), (d, c) => (b(), _(o(O), {\n      dir: o(r),\n      \"data-orientation\": o(l),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: y(() => [\n        C(d.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), rg = /* @__PURE__ */ w({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { loop: e } = ne(t), { forwardRef: n, currentElement: l } = T(), s = pn();\n    return s.tabsList = l, (r, i) => (b(), _(o(At), {\n      \"as-child\": \"\",\n      orientation: o(s).orientation.value,\n      dir: o(s).dir.value,\n      loop: o(e)\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(n),\n          role: \"tablist\",\n          \"as-child\": r.asChild,\n          as: r.as,\n          \"aria-orientation\": o(s).orientation.value\n        }, {\n          default: y(() => [\n            C(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction Qs(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction er(a, t) {\n  return `${a}-content-${t}`;\n}\nconst ig = /* @__PURE__ */ w({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), n = pn(), l = B(() => Qs(n.baseId, t.value)), s = B(() => er(n.baseId, t.value)), r = B(() => t.value === n.modelValue.value), i = I(r.value);\n    return se(() => {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }), (u, d) => (b(), _(o(Pe), {\n      present: r.value,\n      \"force-mount\": \"\"\n    }, {\n      default: y(({ present: c }) => [\n        Y(o(O), {\n          id: s.value,\n          ref: o(e),\n          \"as-child\": u.asChild,\n          as: u.as,\n          role: \"tabpanel\",\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          \"data-orientation\": o(n).orientation.value,\n          \"aria-labelledby\": l.value,\n          hidden: !c.value,\n          tabindex: \"0\",\n          style: Oe({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: y(() => [\n            u.forceMount || r.value ? C(u.$slots, \"default\", { key: 0 }) : pe(\"\", !0)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ug = /* @__PURE__ */ w({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), n = pn(), l = B(() => Qs(n.baseId, t.value)), s = B(() => er(n.baseId, t.value)), r = B(() => t.value === n.modelValue.value);\n    return (i, u) => (b(), _(o(Ot), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: r.value\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          id: l.value,\n          ref: o(e),\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": r.value ? \"true\" : \"false\",\n          \"aria-controls\": s.value,\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": o(n).orientation.value,\n          onMousedown: u[0] || (u[0] = ie((d) => {\n            !i.disabled && d.ctrlKey === !1 ? o(n).changeModelValue(i.value) : d.preventDefault();\n          }, [\"left\"])),\n          onKeydown: u[1] || (u[1] = re((d) => o(n).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: u[2] || (u[2] = () => {\n            const d = o(n).activationMode !== \"manual\";\n            !r.value && !i.disabled && d && o(n).changeModelValue(i.value);\n          })\n        }, {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), dg = /* @__PURE__ */ w({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = pn();\n    T();\n    const n = I(), l = I({\n      size: null,\n      position: null\n    });\n    te(() => e.modelValue.value, async (r) => {\n      await le(), s();\n    }, { immediate: !0 }), Ze([e.tabsList, n], s);\n    function s() {\n      var r;\n      n.value = (r = e.tabsList.value) == null ? void 0 : r.querySelector('[role=\"tab\"][data-state=\"active\"]'), n.value && (e.orientation.value === \"horizontal\" ? l.value = {\n        size: n.value.offsetWidth,\n        position: n.value.offsetLeft\n      } : l.value = {\n        size: n.value.offsetHeight,\n        position: n.value.offsetTop\n      });\n    }\n    return (r, i) => typeof l.value.size == \"number\" ? (b(), _(o(O), k({ key: 0 }, t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${l.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${l.value.position}px`\n      }\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"])) : pe(\"\", !0);\n  }\n}), [fn, Rf] = Q(\"TagsInputRoot\"), cg = /* @__PURE__ */ w({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    addOnTab: { type: Boolean },\n    addOnBlur: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    convertValue: {},\n    displayValue: { type: Function, default: (a) => a.toString() },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { addOnPaste: l, disabled: s, delimiter: r, max: i, id: u, dir: d, addOnBlur: c, addOnTab: p } = ne(e), f = be(d), v = ae(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: !0,\n      deep: !0\n    }), { forwardRef: g, currentElement: m } = T(), { focused: S } = vi(m), x = Qe(m), { getItems: D } = ba(), h = I(), E = I(!1);\n    return Rf({\n      modelValue: v,\n      onAddValue: (P) => {\n        const $ = v.value.length > 0 && typeof v.value[0] == \"object\", R = v.value.length > 0 && typeof e.defaultValue[0] == \"object\";\n        if (($ || R) && typeof e.convertValue != \"function\")\n          throw new Error(\"You must provide a `convertValue` function when using objects as values.\");\n        const M = e.convertValue ? e.convertValue(P) : P;\n        if (v.value.length >= i.value && i.value)\n          return n(\"invalid\", M), !1;\n        if (e.duplicate)\n          return v.value.push(M), !0;\n        if (v.value.includes(M))\n          E.value = !0;\n        else\n          return v.value.push(M), !0;\n        return n(\"invalid\", M), !1;\n      },\n      onRemoveValue: (P) => {\n        P !== -1 && v.value.splice(P, 1);\n      },\n      onInputKeydown: (P) => {\n        const $ = P.target, R = D().map((V) => V.ref).filter((V) => V.dataset.disabled !== \"\");\n        if (!R.length)\n          return;\n        const M = R.at(-1);\n        switch (P.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if ($.selectionStart !== 0 || $.selectionEnd !== 0)\n              break;\n            if (h.value) {\n              const V = R.findIndex((A) => A === h.value);\n              v.value.splice(V, 1), h.value = h.value === M ? R.at(V - 1) : R.at(V + 1), P.preventDefault();\n            } else P.key === \"Backspace\" && (h.value = M, P.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const V = P.key === \"ArrowRight\" && f.value === \"ltr\" || P.key === \"ArrowLeft\" && f.value === \"rtl\", A = !V;\n            if ($.selectionStart !== 0 || $.selectionEnd !== 0)\n              break;\n            if (A && !h.value)\n              h.value = M, P.preventDefault();\n            else if (V && M && h.value === M)\n              h.value = void 0, P.preventDefault();\n            else if (h.value) {\n              const L = $t(P, h.value, void 0, {\n                itemsArray: R,\n                loop: !1,\n                dir: f.value\n              });\n              L && (h.value = L), P.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            h.value && P.preventDefault();\n            break;\n          }\n          default:\n            h.value = void 0;\n        }\n      },\n      selectedElement: h,\n      isInvalidInput: E,\n      addOnPaste: l,\n      addOnBlur: c,\n      addOnTab: p,\n      dir: f,\n      disabled: s,\n      delimiter: r,\n      max: i,\n      id: u,\n      displayValue: e.displayValue\n    }), (P, $) => (b(), _(o(Ca), null, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(g),\n          dir: o(f),\n          as: P.as,\n          \"as-child\": P.asChild,\n          \"data-invalid\": E.value ? \"\" : void 0,\n          \"data-disabled\": o(s) ? \"\" : void 0,\n          \"data-focused\": o(S) ? \"\" : void 0\n        }, {\n          default: y(() => [\n            C(P.$slots, \"default\", { modelValue: o(v) }),\n            o(x) && P.name ? (b(), _(o(to), {\n              key: 0,\n              name: P.name,\n              value: o(v),\n              required: P.required,\n              disabled: o(s)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : pe(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), pg = /* @__PURE__ */ w({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = fn(), { forwardRef: n, currentElement: l } = T();\n    function s(c) {\n      if (!e.addOnBlur.value)\n        return;\n      const p = c.target;\n      if (!p.value)\n        return;\n      e.onAddValue(p.value) && (p.value = \"\");\n    }\n    function r(c) {\n      e.addOnTab.value && i(c);\n    }\n    async function i(c) {\n      if (await le(), c.defaultPrevented)\n        return;\n      const p = c.target;\n      if (!p.value)\n        return;\n      e.onAddValue(p.value) && (p.value = \"\"), c.preventDefault();\n    }\n    function u(c) {\n      e.isInvalidInput.value = !1;\n      const p = e.delimiter.value;\n      if (p === c.data) {\n        const f = c.target;\n        f.value = f.value.replaceAll(p, \"\"), e.onAddValue(f.value) && (f.value = \"\");\n      }\n    }\n    function d(c) {\n      if (e.addOnPaste.value) {\n        c.preventDefault();\n        const p = c.clipboardData;\n        if (!p)\n          return;\n        const f = p.getData(\"text\");\n        e.delimiter.value ? f.split(e.delimiter.value).forEach((g) => {\n          e.onAddValue(g);\n        }) : e.onAddValue(f);\n      }\n    }\n    return se(() => {\n      const c = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      c && setTimeout(() => {\n        t.autoFocus && (c == null || c.focus());\n      }, 1);\n    }), (c, p) => {\n      var f;\n      return b(), _(o(O), {\n        id: (f = o(e).id) == null ? void 0 : f.value,\n        ref: o(n),\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        as: c.as,\n        \"as-child\": c.asChild,\n        maxlength: c.maxLength,\n        placeholder: c.placeholder,\n        disabled: o(e).disabled.value,\n        \"data-invalid\": o(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: u,\n        onKeydown: [\n          re(i, [\"enter\"]),\n          re(r, [\"tab\"]),\n          o(e).onInputKeydown\n        ],\n        onBlur: s,\n        onPaste: d\n      }, {\n        default: y(() => [\n          C(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"id\", \"as\", \"as-child\", \"maxlength\", \"placeholder\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [tr, Af] = Q(\"TagsInputItem\"), fg = /* @__PURE__ */ w({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ne(t), n = fn(), { forwardRef: l, currentElement: s } = T(), r = B(() => n.selectedElement.value === s.value), i = B(() => t.disabled || n.disabled.value), u = Af({\n      value: e,\n      isSelected: r,\n      disabled: i,\n      textId: \"\",\n      displayValue: B(() => n.displayValue(e.value))\n    });\n    return (d, c) => (b(), _(o(Xt), null, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(l),\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": o(u).textId,\n          \"aria-current\": r.value,\n          \"data-disabled\": i.value ? \"\" : void 0,\n          \"data-state\": r.value ? \"active\" : \"inactive\"\n        }, {\n          default: y(() => [\n            C(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), vg = /* @__PURE__ */ w({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = tr();\n    return T(), e.textId || (e.textId = me(void 0, \"radix-vue-tags-input-item-text\")), (n, l) => (b(), _(o(O), k(t, {\n      id: o(e).textId\n    }), {\n      default: y(() => [\n        C(n.$slots, \"default\", {}, () => [\n          ve($e(o(e).displayValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), mg = /* @__PURE__ */ w({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = fn(), n = tr(), l = B(() => {\n      var r;\n      return ((r = n.disabled) == null ? void 0 : r.value) || e.disabled.value;\n    });\n    function s() {\n      if (l.value)\n        return;\n      const r = e.modelValue.value.findIndex((i) => i === n.value.value);\n      e.onRemoveValue(r);\n    }\n    return (r, i) => (b(), _(o(O), k({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": o(n).textId,\n      \"aria-current\": o(n).isSelected.value,\n      \"data-state\": o(n).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": l.value ? \"\" : void 0,\n      type: r.as === \"button\" ? \"button\" : void 0,\n      onClick: s\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), hg = /* @__PURE__ */ w({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    T();\n    const e = fn();\n    function n() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (l, s) => (b(), _(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      onClick: n\n    }), {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [vn, Of] = Q(\"ToastProvider\"), yg = /* @__PURE__ */ w({\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(a) {\n    const t = a, { label: e, duration: n, swipeDirection: l, swipeThreshold: s } = ne(t), r = I(), i = I(0), u = I(!1), d = I(!1);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const c = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(c);\n    }\n    return Of({\n      label: e,\n      duration: n,\n      swipeDirection: l,\n      swipeThreshold: s,\n      toastCount: i,\n      viewport: r,\n      onViewportChange(c) {\n        r.value = c;\n      },\n      onToastAdd() {\n        i.value++;\n      },\n      onToastRemove() {\n        i.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (c, p) => C(c.$slots, \"default\");\n  }\n}), kf = \"toast.swipeStart\", Mf = \"toast.swipeMove\", Vf = \"toast.swipeCancel\", Ff = \"toast.swipeEnd\", On = \"toast.viewportPause\", kn = \"toast.viewportResume\";\nfunction Aa(a, t, e) {\n  const n = e.originalEvent.currentTarget, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction al(a, t, e = 0) {\n  const n = Math.abs(a.x), l = Math.abs(a.y), s = n > l;\n  return t === \"left\" || t === \"right\" ? s && n > e : !s && l > e;\n}\nfunction Lf(a) {\n  return a.nodeType === a.ELEMENT_NODE;\n}\nfunction ar(a) {\n  const t = [];\n  return Array.from(a.childNodes).forEach((n) => {\n    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), Lf(n)) {\n      const l = n.ariaHidden || n.hidden || n.style.display === \"none\", s = n.dataset.radixToastAnnounceExclude === \"\";\n      if (!l)\n        if (s) {\n          const r = n.dataset.radixToastAnnounceAlt;\n          r && t.push(r);\n        } else\n          t.push(...ar(n));\n    }\n  }), t;\n}\nconst Nf = /* @__PURE__ */ w({\n  __name: \"ToastAnnounce\",\n  setup(a) {\n    const t = vn(), e = ii(1e3), n = I(!1);\n    return Dl(() => {\n      n.value = !0;\n    }), (l, s) => o(e) || n.value ? (b(), _(o(Yt), { key: 0 }, {\n      default: y(() => [\n        ve($e(o(t).label.value) + \" \", 1),\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    })) : pe(\"\", !0);\n  }\n}), [zf, Kf] = Q(\"ToastRoot\"), Hf = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: !1 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = T(), r = vn(), i = I(null), u = I(null), d = B(() => e.duration || r.duration.value), c = I(0), p = I(d.value), f = I(0), v = I(d.value), g = Dl(() => {\n      const D = (/* @__PURE__ */ new Date()).getTime() - c.value;\n      v.value = Math.max(p.value - D, 0);\n    }, { fpsLimit: 60 });\n    function m(D) {\n      !D || D === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), c.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(S, D));\n    }\n    function S() {\n      var h, E;\n      ((h = s.value) == null ? void 0 : h.contains(document.activeElement)) && ((E = r.viewport.value) == null || E.focus()), r.isClosePausedRef.value = !1, n(\"close\");\n    }\n    const x = B(() => s.value ? ar(s.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const D = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error(D);\n    }\n    return ye((D) => {\n      const h = r.viewport.value;\n      if (h) {\n        const E = () => {\n          m(p.value), g.resume(), n(\"resume\");\n        }, P = () => {\n          const $ = (/* @__PURE__ */ new Date()).getTime() - c.value;\n          p.value = p.value - $, window.clearTimeout(f.value), g.pause(), n(\"pause\");\n        };\n        return h.addEventListener(On, P), h.addEventListener(kn, E), () => {\n          h.removeEventListener(On, P), h.removeEventListener(kn, E);\n        };\n      }\n    }), te(() => [e.open, d.value], () => {\n      p.value = d.value, e.open && !r.isClosePausedRef.value && m(d.value);\n    }, { immediate: !0 }), jn(\"Escape\", (D) => {\n      n(\"escapeKeyDown\", D), D.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, S());\n    }), se(() => {\n      r.onToastAdd();\n    }), Ie(() => {\n      r.onToastRemove();\n    }), Kf({ onClose: S }), (D, h) => (b(), ce(_e, null, [\n      x.value ? (b(), _(Nf, {\n        key: 0,\n        role: \"status\",\n        \"aria-live\": D.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"\"\n      }, {\n        default: y(() => [\n          ve($e(x.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : pe(\"\", !0),\n      (b(), _(Wt, {\n        to: o(r).viewport.value\n      }, [\n        Y(o(O), k({\n          ref: o(l),\n          role: \"status\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, D.$attrs, {\n          as: D.as,\n          \"as-child\": D.asChild,\n          \"data-state\": D.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": o(r).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: h[0] || (h[0] = ie((E) => {\n            i.value = { x: E.clientX, y: E.clientY };\n          }, [\"left\"])),\n          onPointermove: h[1] || (h[1] = (E) => {\n            if (!i.value) return;\n            const P = E.clientX - i.value.x, $ = E.clientY - i.value.y, R = !!u.value, M = [\"left\", \"right\"].includes(o(r).swipeDirection.value), V = [\"left\", \"up\"].includes(o(r).swipeDirection.value) ? Math.min : Math.max, A = M ? V(0, P) : 0, L = M ? 0 : V(0, $), U = E.pointerType === \"touch\" ? 10 : 2, H = { x: A, y: L }, J = { originalEvent: E, delta: H };\n            R ? (u.value = H, o(Aa)(o(Mf), (N) => n(\"swipeMove\", N), J)) : o(al)(H, o(r).swipeDirection.value, U) ? (u.value = H, o(Aa)(o(kf), (N) => n(\"swipeStart\", N), J), E.target.setPointerCapture(E.pointerId)) : (Math.abs(P) > U || Math.abs($) > U) && (i.value = null);\n          }),\n          onPointerup: h[2] || (h[2] = (E) => {\n            const P = u.value, $ = E.target;\n            if ($.hasPointerCapture(E.pointerId) && $.releasePointerCapture(E.pointerId), u.value = null, i.value = null, P) {\n              const R = E.currentTarget, M = { originalEvent: E, delta: P };\n              o(al)(P, o(r).swipeDirection.value, o(r).swipeThreshold.value) ? o(Aa)(o(Ff), (V) => n(\"swipeEnd\", V), M) : o(Aa)(o(Vf), (V) => n(\"swipeCancel\", V), M), R == null || R.addEventListener(\"click\", (V) => V.preventDefault(), {\n                once: !0\n              });\n            }\n          })\n        }), {\n          default: y(() => [\n            C(D.$slots, \"default\", {\n              remaining: v.value,\n              duration: d.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"]))\n    ], 64));\n  }\n}), gg = /* @__PURE__ */ w({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !0 },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = T(), s = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (r, i) => (b(), _(o(Pe), {\n      present: r.forceMount || o(s)\n    }, {\n      default: y(() => [\n        Y(Hf, k({\n          ref: o(l),\n          open: o(s),\n          type: r.type,\n          as: r.as,\n          \"as-child\": r.asChild,\n          duration: r.duration\n        }, r.$attrs, {\n          onClose: i[0] || (i[0] = (u) => s.value = !1),\n          onPause: i[1] || (i[1] = (u) => n(\"pause\")),\n          onResume: i[2] || (i[2] = (u) => n(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (u) => n(\"escapeKeyDown\", u)),\n          onSwipeStart: i[4] || (i[4] = (u) => {\n            n(\"swipeStart\", u), u.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (u) => {\n            const { x: d, y: c } = u.detail.delta, p = u.currentTarget;\n            p.setAttribute(\"data-swipe\", \"move\"), p.style.setProperty(\"--radix-toast-swipe-move-x\", `${d}px`), p.style.setProperty(\"--radix-toast-swipe-move-y\", `${c}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (u) => {\n            const d = u.currentTarget;\n            d.setAttribute(\"data-swipe\", \"cancel\"), d.style.removeProperty(\"--radix-toast-swipe-move-x\"), d.style.removeProperty(\"--radix-toast-swipe-move-y\"), d.style.removeProperty(\"--radix-toast-swipe-end-x\"), d.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (u) => {\n            const { x: d, y: c } = u.detail.delta, p = u.currentTarget;\n            p.setAttribute(\"data-swipe\", \"end\"), p.style.removeProperty(\"--radix-toast-swipe-move-x\"), p.style.removeProperty(\"--radix-toast-swipe-move-y\"), p.style.setProperty(\"--radix-toast-swipe-end-x\", `${d}px`), p.style.setProperty(\"--radix-toast-swipe-end-y\", `${c}px`), s.value = !1;\n          })\n        }), {\n          default: y(({ remaining: u, duration: d }) => [\n            C(r.$slots, \"default\", {\n              remaining: u,\n              duration: d,\n              open: o(s)\n            })\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), nr = /* @__PURE__ */ w({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    return (t, e) => (b(), _(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: y(() => [\n        C(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), Wf = /* @__PURE__ */ w({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = zf(), { forwardRef: n } = T();\n    return (l, s) => (b(), _(nr, { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), k(t, {\n          ref: o(n),\n          type: l.as === \"button\" ? \"button\" : void 0,\n          onClick: s[0] || (s[0] = (r) => o(e).onClose())\n        }), {\n          default: y(() => [\n            C(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), bg = /* @__PURE__ */ w({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    if (!a.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    const { forwardRef: e } = T();\n    return (n, l) => n.altText ? (b(), _(nr, {\n      key: 0,\n      \"alt-text\": n.altText,\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        Y(Wf, {\n          ref: o(e),\n          as: n.as,\n          \"as-child\": n.asChild\n        }, {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : pe(\"\", !0);\n  }\n}), nl = /* @__PURE__ */ w({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(a, { emit: t }) {\n    const e = t, n = vn();\n    return (l, s) => (b(), _(o(Yt), {\n      \"aria-hidden\": \"\",\n      tabindex: \"0\",\n      style: { position: \"fixed\" },\n      onFocus: s[0] || (s[0] = (r) => {\n        var d;\n        const i = r.relatedTarget;\n        !((d = o(n).viewport.value) != null && d.contains(i)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: y(() => [\n        C(l.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Cg = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => [\"F8\"] },\n    label: { type: [String, Function], default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(a) {\n    const t = a, { hotkey: e, label: n } = ne(t), { forwardRef: l, currentElement: s } = T(), { createCollection: r } = Me(), i = r(s), u = vn(), d = B(() => u.toastCount.value > 0), c = I(), p = I(), f = B(() => e.value.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\"));\n    jn(e.value, () => {\n      s.value.focus();\n    }), se(() => {\n      u.onViewportChange(s.value);\n    }), ye((g) => {\n      const m = s.value;\n      if (d.value && m) {\n        const S = () => {\n          if (!u.isClosePausedRef.value) {\n            const P = new CustomEvent(On);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !0;\n          }\n        }, x = () => {\n          if (u.isClosePausedRef.value) {\n            const P = new CustomEvent(kn);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !1;\n          }\n        }, D = (P) => {\n          !m.contains(P.relatedTarget) && x();\n        }, h = () => {\n          m.contains(document.activeElement) || x();\n        }, E = (P) => {\n          var M, V, A;\n          const $ = P.altKey || P.ctrlKey || P.metaKey;\n          if (P.key === \"Tab\" && !$) {\n            const L = document.activeElement, U = P.shiftKey;\n            if (P.target === m && U) {\n              (M = c.value) == null || M.focus();\n              return;\n            }\n            const N = v({ tabbingDirection: U ? \"backwards\" : \"forwards\" }), F = N.findIndex((W) => W === L);\n            Oa(N.slice(F + 1)) ? P.preventDefault() : U ? (V = c.value) == null || V.focus() : (A = p.value) == null || A.focus();\n          }\n        };\n        m.addEventListener(\"focusin\", S), m.addEventListener(\"focusout\", D), m.addEventListener(\"pointermove\", S), m.addEventListener(\"pointerleave\", h), m.addEventListener(\"keydown\", E), window.addEventListener(\"blur\", S), window.addEventListener(\"focus\", x), g(() => {\n          m.removeEventListener(\"focusin\", S), m.removeEventListener(\"focusout\", D), m.removeEventListener(\"pointermove\", S), m.removeEventListener(\"pointerleave\", h), m.removeEventListener(\"keydown\", E), window.removeEventListener(\"blur\", S), window.removeEventListener(\"focus\", x);\n        });\n      }\n    });\n    function v({ tabbingDirection: g }) {\n      const S = i.value.map((x) => {\n        const D = [x, ...Jn(x)];\n        return g === \"forwards\" ? D : D.reverse();\n      });\n      return (g === \"forwards\" ? S.reverse() : S).flat();\n    }\n    return (g, m) => (b(), _(o(Yi), {\n      role: \"region\",\n      \"aria-label\": typeof o(n) == \"string\" ? o(n).replace(\"{hotkey}\", f.value) : o(n)(f.value),\n      tabindex: \"-1\",\n      style: Oe({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: y(() => [\n        d.value ? (b(), _(nl, {\n          key: 0,\n          ref: (S) => {\n            c.value = o(Be)(S);\n          },\n          onFocusFromOutsideViewport: m[0] || (m[0] = () => {\n            const S = v({\n              tabbingDirection: \"forwards\"\n            });\n            o(Oa)(S);\n          })\n        }, null, 512)) : pe(\"\", !0),\n        Y(o(O), k({\n          ref: o(l),\n          tabindex: \"-1\",\n          as: g.as,\n          \"as-child\": g.asChild\n        }, g.$attrs), {\n          default: y(() => [\n            C(g.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (b(), _(nl, {\n          key: 1,\n          ref: (S) => {\n            p.value = o(Be)(S);\n          },\n          onFocusFromOutsideViewport: m[1] || (m[1] = () => {\n            const S = v({\n              tabbingDirection: \"backwards\"\n            });\n            o(Oa)(S);\n          })\n        }, null, 512)) : pe(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), wg = /* @__PURE__ */ w({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _g = /* @__PURE__ */ w({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(O), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jf = /* @__PURE__ */ w({\n  __name: \"Toggle\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = ae(e, \"pressed\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function s() {\n      l.value = !l.value;\n    }\n    const r = B(() => l.value ? \"on\" : \"off\");\n    return (i, u) => (b(), _(o(O), {\n      type: i.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: i.as,\n      \"aria-pressed\": o(l),\n      \"data-state\": r.value,\n      \"data-disabled\": i.disabled ? \"\" : void 0,\n      disabled: i.disabled,\n      onClick: s\n    }, {\n      default: y(() => [\n        C(i.$slots, \"default\", { pressed: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\"]));\n  }\n}), [Uf, Gf] = Q(\"ToggleGroupRoot\"), qf = /* @__PURE__ */ w({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    rovingFocus: { type: Boolean, default: !0 },\n    disabled: { type: Boolean, default: !1 },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { loop: l, rovingFocus: s, disabled: r, dir: i } = ne(e), u = be(i), { forwardRef: d } = T(), { modelValue: c, changeModelValue: p, isSingle: f } = Ml(e, n);\n    return Gf({\n      isSingle: f,\n      modelValue: c,\n      changeModelValue: p,\n      dir: u,\n      orientation: e.orientation,\n      loop: l,\n      rovingFocus: s,\n      disabled: r\n    }), (v, g) => (b(), _(Ge(o(s) ? o(At) : o(O)), {\n      \"as-child\": \"\",\n      orientation: o(s) ? v.orientation : void 0,\n      dir: o(u),\n      loop: o(s) ? o(l) : void 0\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(d),\n          role: \"group\",\n          \"as-child\": v.asChild,\n          as: v.as\n        }, {\n          default: y(() => [\n            C(v.$slots, \"default\", { modelValue: o(c) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Yf = /* @__PURE__ */ w({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Uf(), n = B(() => {\n      var i;\n      return ((i = e.disabled) == null ? void 0 : i.value) || t.disabled;\n    }), l = B(() => {\n      var i;\n      return (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), s = B(() => {\n      var i;\n      return e.isSingle.value ? e.modelValue.value === t.value : (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), { forwardRef: r } = T();\n    return (i, u) => (b(), _(Ge(o(e).rovingFocus.value ? o(Ot) : o(O)), {\n      \"as-child\": \"\",\n      focusable: !n.value,\n      active: l.value\n    }, {\n      default: y(() => [\n        Y(o(jf), k(t, {\n          ref: o(r),\n          disabled: n.value,\n          pressed: s.value,\n          \"onUpdate:pressed\": u[0] || (u[0] = (d) => o(e).changeModelValue(i.value))\n        }), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"disabled\", \"pressed\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [or, Xf] = Q(\"ToolbarRoot\"), xg = /* @__PURE__ */ w({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { orientation: e, dir: n } = ne(t), l = be(n), { forwardRef: s } = T();\n    return Xf({ orientation: e, dir: l }), (r, i) => (b(), _(o(At), {\n      \"as-child\": \"\",\n      orientation: o(e),\n      dir: o(l),\n      loop: r.loop\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          ref: o(s),\n          role: \"toolbar\",\n          \"aria-orientation\": o(e),\n          \"as-child\": r.asChild,\n          as: r.as\n        }, {\n          default: y(() => [\n            C(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Zf = /* @__PURE__ */ w({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T();\n    return (n, l) => (b(), _(o(Ot), {\n      \"as-child\": \"\",\n      focusable: !n.disabled\n    }, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(e),\n          type: n.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), Sg = /* @__PURE__ */ w({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T();\n    return (n, l) => (b(), _(o(Ot), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: y(() => [\n        Y(o(O), k(t, {\n          ref: o(e),\n          onKeydown: l[0] || (l[0] = (s) => {\n            var r;\n            s.key === \" \" && ((r = s.currentTarget) == null || r.click());\n          })\n        }), {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Eg = /* @__PURE__ */ w({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = or(), s = Re(n);\n    return T(), (r, i) => (b(), _(o(qf), k({ ...e, ...o(s) }, {\n      \"data-orientation\": o(l).orientation.value,\n      dir: o(l).dir.value,\n      \"roving-focus\": !1\n    }), {\n      default: y(() => [\n        C(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), Pg = /* @__PURE__ */ w({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T();\n    return (n, l) => (b(), _(Zf, { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(Yf), k(t, { ref: o(e) }), {\n          default: y(() => [\n            C(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Dg = /* @__PURE__ */ w({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = or();\n    return T(), (n, l) => (b(), _($s, {\n      orientation: o(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: n.as\n    }, {\n      default: y(() => [\n        C(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), lr = \"tooltip.open\", [Oo, Jf] = Q(\"TooltipProvider\"), $g = /* @__PURE__ */ w({\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: !1 },\n    disableClosingTrigger: { type: Boolean },\n    disabled: { type: Boolean },\n    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }\n  },\n  setup(a) {\n    const t = a, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: l, disableClosingTrigger: s, ignoreNonKeyboardFocus: r, disabled: i } = ne(t);\n    T();\n    const u = I(!0), d = I(!1), { start: c, stop: p } = Wn(() => {\n      u.value = !0;\n    }, n, { immediate: !1 });\n    return Jf({\n      isOpenDelayed: u,\n      delayDuration: e,\n      onOpen() {\n        p(), u.value = !1;\n      },\n      onClose() {\n        c();\n      },\n      isPointerInTransitRef: d,\n      disableHoverableContent: l,\n      disableClosingTrigger: s,\n      disabled: i,\n      ignoreNonKeyboardFocus: r\n    }), (f, v) => C(f.$slots, \"default\");\n  }\n}), [mn, Qf] = Q(\"TooltipRoot\"), Bg = /* @__PURE__ */ w({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: void 0 },\n    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    T();\n    const l = Oo(), s = B(() => e.disableHoverableContent ?? l.disableHoverableContent.value), r = B(() => e.disableClosingTrigger ?? l.disableClosingTrigger.value), i = B(() => e.disabled ?? l.disabled.value), u = B(() => e.delayDuration ?? l.delayDuration.value), d = B(() => e.ignoreNonKeyboardFocus ?? l.ignoreNonKeyboardFocus.value), c = ae(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    te(c, (h) => {\n      l.onClose && (h ? (l.onOpen(), document.dispatchEvent(new CustomEvent(lr))) : l.onClose());\n    });\n    const p = I(!1), f = I(), v = B(() => c.value ? p.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: g, stop: m } = Wn(() => {\n      p.value = !0, c.value = !0;\n    }, u, { immediate: !1 });\n    function S() {\n      m(), p.value = !1, c.value = !0;\n    }\n    function x() {\n      m(), c.value = !1;\n    }\n    function D() {\n      g();\n    }\n    return Qf({\n      contentId: \"\",\n      open: c,\n      stateAttribute: v,\n      trigger: f,\n      onTriggerChange(h) {\n        f.value = h;\n      },\n      onTriggerEnter() {\n        l.isOpenDelayed.value ? D() : S();\n      },\n      onTriggerLeave() {\n        s.value ? x() : m();\n      },\n      onOpen: S,\n      onClose: x,\n      disableHoverableContent: s,\n      disableClosingTrigger: r,\n      disabled: i,\n      ignoreNonKeyboardFocus: d\n    }), (h, E) => (b(), _(o(It), null, {\n      default: y(() => [\n        C(h.$slots, \"default\", { open: o(c) })\n      ]),\n      _: 3\n    }));\n  }\n}), Ig = /* @__PURE__ */ w({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = mn(), n = Oo();\n    e.contentId || (e.contentId = me(void 0, \"radix-vue-tooltip-content\"));\n    const { forwardRef: l, currentElement: s } = T(), r = I(!1), i = I(!1), u = B(() => e.disabled.value ? {} : {\n      click: m,\n      focus: v,\n      pointermove: p,\n      pointerleave: f,\n      pointerdown: c,\n      blur: g\n    });\n    se(() => {\n      e.onTriggerChange(s.value);\n    });\n    function d() {\n      r.value = !1;\n    }\n    function c() {\n      r.value = !0, document.addEventListener(\"pointerup\", d, { once: !0 });\n    }\n    function p(S) {\n      S.pointerType !== \"touch\" && !i.value && !n.isPointerInTransitRef.value && (e.onTriggerEnter(), i.value = !0);\n    }\n    function f() {\n      e.onTriggerLeave(), i.value = !1;\n    }\n    function v(S) {\n      var x, D;\n      r.value || e.ignoreNonKeyboardFocus.value && !((D = (x = S.target).matches) != null && D.call(x, \":focus-visible\")) || e.onOpen();\n    }\n    function g() {\n      e.onClose();\n    }\n    function m() {\n      e.disableClosingTrigger.value || e.onClose();\n    }\n    return (S, x) => (b(), _(o(Tt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Y(o(O), k({\n          ref: o(l),\n          \"aria-describedby\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-state\": o(e).stateAttribute.value,\n          as: S.as,\n          \"as-child\": t.asChild,\n          \"data-grace-area-trigger\": \"\"\n        }, Nn(u.value)), {\n          default: y(() => [\n            C(S.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), sr = /* @__PURE__ */ w({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = mn(), { forwardRef: s } = T(), r = Wa(), i = B(() => {\n      var c;\n      return (c = r.default) == null ? void 0 : c.call(r);\n    }), u = B(() => {\n      var f;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      let c = \"\";\n      function p(v) {\n        typeof v.children == \"string\" ? c += v.children : Array.isArray(v.children) && v.children.forEach((g) => p(g));\n      }\n      return (f = i.value) == null || f.forEach((v) => p(v)), c;\n    }), d = B(() => {\n      const { ariaLabel: c, ...p } = e;\n      return p;\n    });\n    return se(() => {\n      je(window, \"scroll\", (c) => {\n        const p = c.target;\n        p != null && p.contains(l.trigger.value) && l.onClose();\n      }), je(window, lr, l.onClose);\n    }), (c, p) => (b(), _(o(yt), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: p[0] || (p[0] = (f) => n(\"escapeKeyDown\", f)),\n      onPointerDownOutside: p[1] || (p[1] = (f) => {\n        var v;\n        o(l).disableClosingTrigger.value && ((v = o(l).trigger.value) != null && v.contains(f.target)) && f.preventDefault(), n(\"pointerDownOutside\", f);\n      }),\n      onFocusOutside: p[2] || (p[2] = ie(() => {\n      }, [\"prevent\"])),\n      onDismiss: p[3] || (p[3] = (f) => o(l).onClose())\n    }, {\n      default: y(() => [\n        Y(o(Pt), k({\n          ref: o(s),\n          \"data-state\": o(l).stateAttribute.value\n        }, { ...c.$attrs, ...d.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: y(() => [\n            C(c.$slots, \"default\"),\n            Y(o(Yt), {\n              id: o(l).contentId,\n              role: \"tooltip\"\n            }, {\n              default: y(() => [\n                ve($e(u.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), ev = /* @__PURE__ */ w({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(a) {\n    const e = Bt(a), { forwardRef: n, currentElement: l } = T(), { trigger: s, onClose: r } = mn(), i = Oo(), { isPointerInTransit: u, onPointerExit: d } = Il(s, l);\n    return i.isPointerInTransitRef = u, d(() => {\n      r();\n    }), (c, p) => (b(), _(sr, k({ ref: o(n) }, o(e)), {\n      default: y(() => [\n        C(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tg = /* @__PURE__ */ w({\n  __name: \"TooltipContent\",\n  props: {\n    forceMount: { type: Boolean },\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = mn(), s = xe(e, n), { forwardRef: r } = T();\n    return (i, u) => (b(), _(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        (b(), _(Ge(o(l).disableHoverableContent.value ? sr : ev), k({ ref: o(r) }, o(s)), {\n          default: y(() => [\n            C(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Rg = /* @__PURE__ */ w({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return T(), (e, n) => (b(), _(o(qt), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ag = /* @__PURE__ */ w({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), _(o(ht), K(j(t)), {\n      default: y(() => [\n        C(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction ko(a) {\n  return a.reduce((t, e) => (t.push(e), e.children && t.push(...ko(e.children)), t), []);\n}\nconst [rr, tv] = Q(\"TreeRoot\"), Og = /* @__PURE__ */ w({\n  __name: \"TreeRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    items: {},\n    expanded: {},\n    defaultExpanded: {},\n    getKey: {},\n    selectionBehavior: { default: \"toggle\" },\n    multiple: { type: Boolean },\n    dir: {},\n    disabled: { type: Boolean },\n    propagateSelect: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  emits: [\"update:modelValue\", \"update:expanded\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { items: l, multiple: s, disabled: r, propagateSelect: i, dir: u } = ne(e), { handleTypeaheadSearch: d } = ga(), c = be(u), p = I(), f = I(!1), v = ia(), g = ae(e, \"modelValue\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultValue ?? (s.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), m = ae(e, \"expanded\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultExpanded ?? [],\n      passive: e.expanded === void 0,\n      deep: !0\n    }), { onSelectItem: S, handleMultipleReplace: x } = Oi(g, e), D = B(() => s.value && Array.isArray(g.value) ? g.value.map((R) => e.getKey(R)) : [e.getKey(g.value ?? {})]);\n    function h(R, M = 1, V) {\n      return R.reduce((A, L, U) => {\n        const H = e.getKey(L), J = m.value.includes(H), N = {\n          _id: H,\n          value: L,\n          index: U,\n          level: M,\n          parentItem: V,\n          hasChildren: !!L.children,\n          bind: {\n            value: L,\n            level: M,\n            \"aria-setsize\": R.length,\n            \"aria-posinset\": U + 1\n          }\n        };\n        return A.push(N), L.children && J && A.push(...h(L.children, M + 1, L)), A;\n      }, []);\n    }\n    const E = B(() => {\n      const R = e.items;\n      return m.value.map((M) => M), h(R ?? []);\n    });\n    function P(R) {\n      var M;\n      if (f.value)\n        v.trigger(R);\n      else {\n        const V = (M = p.value) == null ? void 0 : M.getItems().map((A) => A.ref);\n        d(R.key, V);\n      }\n    }\n    function $(R) {\n      if (f.value)\n        return;\n      const M = Ja[R.key];\n      le(() => {\n        var V;\n        x(\n          M,\n          document.activeElement,\n          (V = p.value) == null ? void 0 : V.getItems,\n          E.value.map((A) => A.value)\n        );\n      });\n    }\n    return tv({\n      modelValue: g,\n      selectedKeys: D,\n      onSelect: (R) => {\n        var A;\n        const M = (L) => e.getKey(L ?? {}) === e.getKey(R), V = e.multiple && Array.isArray(g.value) ? ((A = g.value) == null ? void 0 : A.findIndex(M)) !== -1 : void 0;\n        if (S(R, M), e.propagateSelect && e.multiple && Array.isArray(g.value)) {\n          const L = ko(R.children ?? []);\n          V ? g.value = [...g.value].filter((U) => !L.some((H) => e.getKey(U ?? {}) === e.getKey(H))) : g.value = [...g.value, ...L];\n        }\n      },\n      expanded: m,\n      onToggle(R) {\n        if (!(R != null && R.children))\n          return;\n        const M = e.getKey(R) ?? R;\n        m.value.includes(M) ? m.value = m.value.filter((V) => V !== M) : m.value.push(M);\n      },\n      getKey: e.getKey,\n      items: l,\n      expandedItems: E,\n      disabled: r,\n      multiple: s,\n      dir: c,\n      propagateSelect: i,\n      isVirtual: f,\n      virtualKeydownHook: v,\n      handleMultipleReplace: x\n    }), (R, M) => (b(), _(o(At), {\n      ref_key: \"rovingFocusGroupRef\",\n      ref: p,\n      \"as-child\": \"\",\n      orientation: \"vertical\",\n      dir: o(c)\n    }, {\n      default: y(() => [\n        Y(o(O), {\n          role: \"tree\",\n          as: R.as,\n          \"as-child\": R.asChild,\n          \"aria-multiselectable\": o(s) ? !0 : void 0,\n          onKeydown: [\n            P,\n            re(ie($, [\"shift\"]), [\"up\", \"down\"])\n          ]\n        }, {\n          default: y(() => [\n            C(R.$slots, \"default\", {\n              flattenItems: E.value,\n              modelValue: o(g),\n              expanded: o(m)\n            })\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-multiselectable\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), av = \"tree.select\", nv = \"tree.toggle\", kg = /* @__PURE__ */ w({\n  inheritAttrs: !1,\n  __name: \"TreeItem\",\n  props: {\n    value: {},\n    level: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"select\", \"toggle\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = rr(), { getItems: r } = Zt(), i = B(() => !!n.value.children), u = B(() => {\n      const x = s.getKey(n.value);\n      return s.expanded.value.includes(x);\n    }), d = B(() => {\n      const x = s.getKey(n.value);\n      return s.selectedKeys.value.includes(x);\n    }), c = B(() => {\n      if (s.propagateSelect.value && d.value && i.value && Array.isArray(s.modelValue.value))\n        return !ko(n.value.children).every((D) => s.modelValue.value.find((h) => s.getKey(h) === s.getKey(D)));\n    });\n    function p(x) {\n      if (i.value)\n        if (u.value) {\n          const D = r().map((R) => R.ref), h = document.activeElement, E = D.indexOf(h), $ = [...D].slice(E).find((R) => Number(R.getAttribute(\"data-indent\")) === n.level + 1);\n          $ && $.focus();\n        } else\n          S(x);\n    }\n    function f(x) {\n      if (u.value)\n        S(x);\n      else {\n        const D = r().map((R) => R.ref), h = document.activeElement, E = D.indexOf(h), $ = [...D].slice(0, E).reverse().find((R) => Number(R.getAttribute(\"data-indent\")) === n.level - 1);\n        $ && $.focus();\n      }\n    }\n    async function v(x) {\n      l(\"select\", x), !(x != null && x.defaultPrevented) && s.onSelect(n.value);\n    }\n    async function g(x) {\n      l(\"toggle\", x), !(x != null && x.defaultPrevented) && s.onToggle(n.value);\n    }\n    async function m(x) {\n      if (!x)\n        return;\n      const D = { originalEvent: x, value: n.value, isExpanded: u.value, isSelected: d.value };\n      zt(av, v, D);\n    }\n    async function S(x) {\n      if (!x)\n        return;\n      const D = { originalEvent: x, value: n.value, isExpanded: u.value, isSelected: d.value };\n      zt(nv, g, D);\n    }\n    return t({\n      isExpanded: u,\n      isSelected: d,\n      isIndeterminate: c,\n      handleToggle: () => s.onToggle(n.value),\n      handleSelect: () => s.onSelect(n.value)\n    }), (x, D) => (b(), _(o(Ot), {\n      \"as-child\": \"\",\n      value: x.value,\n      \"allow-shift-key\": \"\"\n    }, {\n      default: y(() => [\n        Y(o(O), k(x.$attrs, {\n          role: \"treeitem\",\n          as: x.as,\n          \"as-child\": x.asChild,\n          \"aria-selected\": d.value,\n          \"aria-expanded\": i.value ? u.value : void 0,\n          \"aria-level\": x.level,\n          \"data-indent\": x.level,\n          \"data-selected\": d.value ? \"\" : void 0,\n          \"data-expanded\": u.value ? \"\" : void 0,\n          onKeydown: [\n            re(ie(m, [\"self\", \"prevent\"]), [\"enter\", \"space\"]),\n            D[0] || (D[0] = re(ie((h) => o(s).dir.value === \"ltr\" ? p(h) : f(h), [\"prevent\"]), [\"right\"])),\n            D[1] || (D[1] = re(ie((h) => o(s).dir.value === \"ltr\" ? f(h) : p(h), [\"prevent\"]), [\"left\"]))\n          ],\n          onClick: D[2] || (D[2] = ie((h) => {\n            m(h), S(h);\n          }, [\"stop\"]))\n        }), {\n          default: y(() => [\n            C(x.$slots, \"default\", {\n              isExpanded: u.value,\n              isSelected: d.value,\n              isIndeterminate: c.value,\n              handleSelect: () => o(s).onSelect(x.value),\n              handleToggle: () => o(s).onToggle(x.value)\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-selected\", \"aria-expanded\", \"aria-level\", \"data-indent\", \"data-selected\", \"data-expanded\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), Mg = /* @__PURE__ */ w({\n  __name: \"TreeVirtualizer\",\n  props: {\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Wa(), n = rr(), l = $l(), { getItems: s } = Zt(), r = Dt(\"\", 1e3), i = B(() => {\n      const f = (v) => t.textContent ? t.textContent(v) : v.toString().toLowerCase();\n      return n.expandedItems.value.map((v, g) => ({\n        index: g,\n        textContent: f(v.value)\n      }));\n    });\n    n.isVirtual.value = !0;\n    const u = B(() => {\n      const f = l.value;\n      if (f) {\n        const v = window.getComputedStyle(f);\n        return {\n          start: Number.parseFloat(v.paddingBlockStart || v.paddingTop),\n          end: Number.parseFloat(v.paddingBlockEnd || v.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), d = ss(\n      {\n        get scrollPaddingStart() {\n          return u.value.start;\n        },\n        get scrollPaddingEnd() {\n          return u.value.end;\n        },\n        get count() {\n          return n.expandedItems.value.length ?? 0;\n        },\n        get horizontal() {\n          return !1;\n        },\n        getItemKey(f) {\n          return f + n.getKey(n.expandedItems.value[f].value);\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), c = B(() => d.value.getVirtualItems().map((f) => ({\n      item: f,\n      is: Fn(e.default({\n        item: n.expandedItems.value[f.index]\n      })[0], {\n        \"data-index\": f.index,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${f.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    function p(f) {\n      d.value.scrollToIndex(f, { align: \"start\" }), requestAnimationFrame(() => {\n        const v = l.value.querySelector(`[data-index=\"${f}\"]`);\n        v instanceof HTMLElement && v.focus();\n      });\n    }\n    return n.virtualKeydownHook.on((f) => {\n      var S;\n      const v = f.altKey || f.ctrlKey || f.metaKey;\n      if (f.key === \"Tab\" && !v)\n        return;\n      const m = Ja[f.key];\n      if ([\"first\", \"last\"].includes(m)) {\n        f.preventDefault();\n        const x = m === \"first\" ? 0 : n.expandedItems.value.length - 1;\n        d.value.scrollToIndex(x), requestAnimationFrame(() => {\n          const D = s();\n          (m === \"first\" ? D[0] : D[D.length - 1]).ref.focus();\n        });\n      } else if (m === \"prev\" && f.key !== \"ArrowUp\") {\n        const x = document.activeElement, D = Number(x.getAttribute(\"data-index\")), h = Number(x.getAttribute(\"data-indent\")), P = n.expandedItems.value.slice(0, D).map(($, R) => ({ ...$, index: R })).reverse().find(($) => $.level === h - 1);\n        P && p(P.index);\n      } else if (!m && !v) {\n        r.value += f.key;\n        const x = Number((S = document.activeElement) == null ? void 0 : S.getAttribute(\"data-index\")), D = i.value[x].textContent, h = i.value.map(($) => $.textContent), E = Yn(h, r.value, D), P = i.value.find(($) => $.textContent === E);\n        P && p(P.index);\n      }\n      le(() => {\n        f.shiftKey && m && n.handleMultipleReplace(m, document.activeElement, s, n.expandedItems.value.map((x) => x.value));\n      });\n    }), (f, v) => (b(), ce(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: Oe({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(d).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ce(_e, null, va(c.value, ({ is: g, item: m }) => (b(), _(Ge(g), {\n        key: m.key\n      }))), 128))\n    ], 4));\n  }\n}), Vg = /* @__PURE__ */ w({\n  __name: \"Viewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = T(), { nonce: n } = ne(t), l = Xa(n);\n    return (s, r) => (b(), ce(_e, null, [\n      Y(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          C(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      Y(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ve(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nexport {\n  fv as AccordionContent,\n  vv as AccordionHeader,\n  pv as AccordionItem,\n  cv as AccordionRoot,\n  mv as AccordionTrigger,\n  Ev as AlertDialogAction,\n  _v as AlertDialogCancel,\n  Cv as AlertDialogContent,\n  Sv as AlertDialogDescription,\n  wv as AlertDialogOverlay,\n  bv as AlertDialogPortal,\n  yv as AlertDialogRoot,\n  xv as AlertDialogTitle,\n  gv as AlertDialogTrigger,\n  Pv as AspectRatio,\n  Bv as AvatarFallback,\n  $v as AvatarImage,\n  Dv as AvatarRoot,\n  ku as CalendarCell,\n  Ku as CalendarCellTrigger,\n  Ou as CalendarGrid,\n  Nu as CalendarGridBody,\n  Lu as CalendarGridHead,\n  zu as CalendarGridRow,\n  Mu as CalendarHeadCell,\n  Ru as CalendarHeader,\n  Au as CalendarHeading,\n  Vu as CalendarNext,\n  Fu as CalendarPrev,\n  Tu as CalendarRoot,\n  Tv as CheckboxIndicator,\n  Iv as CheckboxRoot,\n  Li as CollapsibleContent,\n  Mi as CollapsibleRoot,\n  Vi as CollapsibleTrigger,\n  Ov as ComboboxAnchor,\n  jv as ComboboxArrow,\n  Mv as ComboboxCancel,\n  Lv as ComboboxContent,\n  Nv as ComboboxEmpty,\n  Vv as ComboboxGroup,\n  Av as ComboboxInput,\n  Kv as ComboboxItem,\n  Hv as ComboboxItemIndicator,\n  Fv as ComboboxLabel,\n  Uv as ComboboxPortal,\n  Rv as ComboboxRoot,\n  Wv as ComboboxSeparator,\n  kv as ComboboxTrigger,\n  zv as ComboboxViewport,\n  uv as ConfigProvider,\n  Zv as ContextMenuArrow,\n  tm as ContextMenuCheckboxItem,\n  Xv as ContextMenuContent,\n  Qv as ContextMenuGroup,\n  Jv as ContextMenuItem,\n  am as ContextMenuItemIndicator,\n  nm as ContextMenuLabel,\n  Yv as ContextMenuPortal,\n  om as ContextMenuRadioGroup,\n  lm as ContextMenuRadioItem,\n  Gv as ContextMenuRoot,\n  em as ContextMenuSeparator,\n  sm as ContextMenuSub,\n  rm as ContextMenuSubContent,\n  im as ContextMenuSubTrigger,\n  qv as ContextMenuTrigger,\n  Kd as DateFieldInput,\n  Td as DateFieldRoot,\n  Sm as DatePickerAnchor,\n  Em as DatePickerArrow,\n  _m as DatePickerCalendar,\n  pm as DatePickerCell,\n  bm as DatePickerCellTrigger,\n  Pm as DatePickerClose,\n  $m as DatePickerContent,\n  xm as DatePickerField,\n  cm as DatePickerGrid,\n  ym as DatePickerGridBody,\n  hm as DatePickerGridHead,\n  gm as DatePickerGridRow,\n  fm as DatePickerHeadCell,\n  um as DatePickerHeader,\n  dm as DatePickerHeading,\n  Cm as DatePickerInput,\n  vm as DatePickerNext,\n  mm as DatePickerPrev,\n  wm as DatePickerRoot,\n  Dm as DatePickerTrigger,\n  Yd as DateRangeFieldInput,\n  qd as DateRangeFieldRoot,\n  Wm as DateRangePickerAnchor,\n  jm as DateRangePickerArrow,\n  Km as DateRangePickerCalendar,\n  Rm as DateRangePickerCell,\n  Lm as DateRangePickerCellTrigger,\n  Um as DateRangePickerClose,\n  qm as DateRangePickerContent,\n  Hm as DateRangePickerField,\n  Tm as DateRangePickerGrid,\n  Vm as DateRangePickerGridBody,\n  Mm as DateRangePickerGridHead,\n  Fm as DateRangePickerGridRow,\n  Am as DateRangePickerHeadCell,\n  Bm as DateRangePickerHeader,\n  Im as DateRangePickerHeading,\n  Nm as DateRangePickerInput,\n  Om as DateRangePickerNext,\n  km as DateRangePickerPrev,\n  zm as DateRangePickerRoot,\n  Gm as DateRangePickerTrigger,\n  Kl as DialogClose,\n  vu as DialogContent,\n  gu as DialogDescription,\n  hu as DialogOverlay,\n  hv as DialogPortal,\n  ji as DialogRoot,\n  yu as DialogTitle,\n  Ui as DialogTrigger,\n  Qm as DropdownMenuArrow,\n  nh as DropdownMenuCheckboxItem,\n  Jm as DropdownMenuContent,\n  th as DropdownMenuGroup,\n  eh as DropdownMenuItem,\n  oh as DropdownMenuItemIndicator,\n  lh as DropdownMenuLabel,\n  Zm as DropdownMenuPortal,\n  sh as DropdownMenuRadioGroup,\n  rh as DropdownMenuRadioItem,\n  Ym as DropdownMenuRoot,\n  ah as DropdownMenuSeparator,\n  ih as DropdownMenuSub,\n  uh as DropdownMenuSubContent,\n  dh as DropdownMenuSubTrigger,\n  Xm as DropdownMenuTrigger,\n  ph as EditableArea,\n  hh as EditableCancelTrigger,\n  yh as EditableEditTrigger,\n  fh as EditableInput,\n  vh as EditablePreview,\n  ch as EditableRoot,\n  mh as EditableSubmitTrigger,\n  _h as HoverCardArrow,\n  wh as HoverCardContent,\n  Ch as HoverCardPortal,\n  gh as HoverCardRoot,\n  bh as HoverCardTrigger,\n  xh as Label,\n  Eh as ListboxContent,\n  Ph as ListboxFilter,\n  Ih as ListboxGroup,\n  Th as ListboxGroupLabel,\n  Dh as ListboxItem,\n  $h as ListboxItemIndicator,\n  Sh as ListboxRoot,\n  Bh as ListboxVirtualizer,\n  Vh as MenubarArrow,\n  zh as MenubarCheckboxItem,\n  Mh as MenubarContent,\n  Lh as MenubarGroup,\n  Fh as MenubarItem,\n  Kh as MenubarItemIndicator,\n  Hh as MenubarLabel,\n  Ah as MenubarMenu,\n  kh as MenubarPortal,\n  Wh as MenubarRadioGroup,\n  jh as MenubarRadioItem,\n  Rh as MenubarRoot,\n  Nh as MenubarSeparator,\n  Uh as MenubarSub,\n  Gh as MenubarSubContent,\n  qh as MenubarSubTrigger,\n  Oh as MenubarTrigger,\n  Zh as NavigationMenuContent,\n  Jh as NavigationMenuIndicator,\n  Xh as NavigationMenuItem,\n  Qh as NavigationMenuLink,\n  ey as NavigationMenuList,\n  Yh as NavigationMenuRoot,\n  ty as NavigationMenuSub,\n  ay as NavigationMenuTrigger,\n  ny as NavigationMenuViewport,\n  ry as NumberFieldDecrement,\n  sy as NumberFieldIncrement,\n  ly as NumberFieldInput,\n  oy as NumberFieldRoot,\n  uy as PaginationEllipsis,\n  dy as PaginationFirst,\n  cy as PaginationLast,\n  py as PaginationList,\n  fy as PaginationListItem,\n  vy as PaginationNext,\n  my as PaginationPrev,\n  iy as PaginationRoot,\n  yy as PinInputInput,\n  hy as PinInputRoot,\n  bs as PopoverAnchor,\n  ys as PopoverArrow,\n  gs as PopoverClose,\n  hs as PopoverContent,\n  vs as PopoverPortal,\n  ps as PopoverRoot,\n  fs as PopoverTrigger,\n  O as Primitive,\n  by as ProgressIndicator,\n  gy as ProgressRoot,\n  _y as RadioGroupIndicator,\n  wy as RadioGroupItem,\n  Cy as RadioGroupRoot,\n  lp as RangeCalendarCell,\n  pp as RangeCalendarCellTrigger,\n  op as RangeCalendarGrid,\n  dp as RangeCalendarGridBody,\n  up as RangeCalendarGridHead,\n  cp as RangeCalendarGridRow,\n  sp as RangeCalendarHeadCell,\n  ap as RangeCalendarHeader,\n  np as RangeCalendarHeading,\n  rp as RangeCalendarNext,\n  ip as RangeCalendarPrev,\n  tp as RangeCalendarRoot,\n  Dy as ScrollAreaCorner,\n  xy as ScrollAreaRoot,\n  Ey as ScrollAreaScrollbar,\n  Py as ScrollAreaThumb,\n  Sy as ScrollAreaViewport,\n  Ry as SelectArrow,\n  Ty as SelectContent,\n  My as SelectGroup,\n  Hy as SelectIcon,\n  Oy as SelectItem,\n  ky as SelectItemIndicator,\n  Fy as SelectItemText,\n  Vy as SelectLabel,\n  Iy as SelectPortal,\n  $y as SelectRoot,\n  zy as SelectScrollDownButton,\n  Ny as SelectScrollUpButton,\n  Ay as SelectSeparator,\n  By as SelectTrigger,\n  Ky as SelectValue,\n  Ly as SelectViewport,\n  Np as Separator,\n  Gy as SliderRange,\n  Wy as SliderRoot,\n  jy as SliderThumb,\n  Uy as SliderTrack,\n  Xn as Slot,\n  qy as SplitterGroup,\n  Yy as SplitterPanel,\n  Xy as SplitterResizeHandle,\n  eg as StepperDescription,\n  ag as StepperIndicator,\n  Jy as StepperItem,\n  Zy as StepperRoot,\n  ng as StepperSeparator,\n  tg as StepperTitle,\n  Qy as StepperTrigger,\n  og as SwitchRoot,\n  lg as SwitchThumb,\n  ig as TabsContent,\n  dg as TabsIndicator,\n  rg as TabsList,\n  sg as TabsRoot,\n  ug as TabsTrigger,\n  hg as TagsInputClear,\n  pg as TagsInputInput,\n  fg as TagsInputItem,\n  mg as TagsInputItemDelete,\n  vg as TagsInputItemText,\n  cg as TagsInputRoot,\n  bg as ToastAction,\n  Wf as ToastClose,\n  _g as ToastDescription,\n  yg as ToastProvider,\n  gg as ToastRoot,\n  wg as ToastTitle,\n  Cg as ToastViewport,\n  jf as Toggle,\n  Yf as ToggleGroupItem,\n  qf as ToggleGroupRoot,\n  Zf as ToolbarButton,\n  Sg as ToolbarLink,\n  xg as ToolbarRoot,\n  Dg as ToolbarSeparator,\n  Eg as ToolbarToggleGroup,\n  Pg as ToolbarToggleItem,\n  Rg as TooltipArrow,\n  Tg as TooltipContent,\n  Ag as TooltipPortal,\n  $g as TooltipProvider,\n  Bg as TooltipRoot,\n  Ig as TooltipTrigger,\n  kg as TreeItem,\n  Og as TreeRoot,\n  Mg as TreeVirtualizer,\n  Vg as Viewport,\n  Yt as VisuallyHidden,\n  Q as createContext,\n  ha as useBodyScrollLock,\n  Un as useDateFormatter,\n  Re as useEmitAsProps,\n  T as useForwardExpose,\n  Bt as useForwardProps,\n  xe as useForwardPropsEmits,\n  me as useId,\n  Al as useStateMachine,\n  dv as withDefault\n};\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","const CLASS_PART_SEPARATOR = '-';\nfunction createClassGroupUtils(config) {\n  const classMap = createClassMap(config);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  function getClassGroupId(className) {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  }\n  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  }\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n}\nfunction getGroupRecursive(classParts, classPartObject) {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))?.classGroupId;\n}\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nfunction getGroupIdForArbitraryProperty(className) {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n}\n/**\n * Exported for testing only\n */\nfunction createClassMap(config) {\n  const {\n    theme,\n    prefix\n  } = config;\n  const classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n}\nfunction processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === 'string') {\n      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup]) => {\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n}\nfunction getPart(classPartObject, path) {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n}\nfunction isThemeGetter(func) {\n  return func.isThemeGetter;\n}\nfunction getPrefixedClassGroupEntries(classGroupEntries, prefix) {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n  return classGroupEntries.map(([classGroupId, classGroup]) => {\n    const prefixedClassGroup = classGroup.map(classDefinition => {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));\n      }\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n}\n\n// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance\nfunction createLruCache(maxCacheSize) {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => undefined,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = new Map();\n  let previousCache = new Map();\n  function update(key, value) {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = new Map();\n    }\n  }\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== undefined) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== undefined) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n}\nconst IMPORTANT_MODIFIER = '!';\nfunction createParseClassName(config) {\n  const {\n    separator,\n    experimentalParseClassName\n  } = config;\n  const isSeparatorSingleCharacter = separator.length === 1;\n  const firstSeparatorCharacter = separator[0];\n  const separatorLength = separator.length;\n  // parseClassName inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n  function parseClassName(className) {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0) {\n        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separatorLength;\n          continue;\n        }\n        if (currentCharacter === '/') {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === '[') {\n        bracketDepth++;\n      } else if (currentCharacter === ']') {\n        bracketDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  }\n  if (experimentalParseClassName) {\n    return function parseClassNameExperimental(className) {\n      return experimentalParseClassName({\n        className,\n        parseClassName\n      });\n    };\n  }\n  return parseClassName;\n}\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  const sortedModifiers = [];\n  let unsortedModifiers = [];\n  modifiers.forEach(modifier => {\n    const isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push(...unsortedModifiers.sort());\n  return sortedModifiers;\n}\nfunction createConfigUtils(config) {\n  return {\n    cache: createLruCache(config.cacheSize),\n    parseClassName: createParseClassName(config),\n    ...createClassGroupUtils(config)\n  };\n}\nconst SPLIT_CLASSES_REGEX = /\\s+/;\nfunction mergeClassList(classList, configUtils) {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds\n  } = configUtils;\n  /**\n   * Set of classGroupIds in following format:\n   * `{importantModifier}{variantModifiers}{classGroupId}`\n   * @example 'float'\n   * @example 'hover:focus:bg-color'\n   * @example 'md:!pr'\n   */\n  const classGroupsInConflict = new Set();\n  return classList.trim().split(SPLIT_CLASSES_REGEX).map(originalClassName => {\n    const {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);\n    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        return {\n          isTailwindClass: false,\n          originalClassName\n        };\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        return {\n          isTailwindClass: false,\n          originalClassName\n        };\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(':');\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    return {\n      isTailwindClass: true,\n      modifierId,\n      classGroupId,\n      originalClassName,\n      hasPostfixModifier\n    };\n  }).reverse()\n  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n  .filter(parsed => {\n    if (!parsed.isTailwindClass) {\n      return true;\n    }\n    const {\n      modifierId,\n      classGroupId,\n      hasPostfixModifier\n    } = parsed;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.has(classId)) {\n      return false;\n    }\n    classGroupsInConflict.add(classId);\n    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(group => classGroupsInConflict.add(modifierId + group));\n    return true;\n  }).reverse().map(parsed => parsed.originalClassName).join(' ');\n}\n\n/**\n * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.\n *\n * Specifically:\n * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js\n * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts\n *\n * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n */\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string = '';\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nfunction toValue(mix) {\n  if (typeof mix === 'string') {\n    return mix;\n  }\n  let resolvedValue;\n  let string = '';\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nfunction fromTheme(key) {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n}\nconst arbitraryValueRegex = /^\\[(?:([a-z-]+):)?(.+)\\]$/i;\nconst fractionRegex = /^\\d+\\/\\d+$/;\nconst stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);\nconst tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nconst lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nconst colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/;\n// Shadow always begins with x and y offset separated by underscore optionally prepended by inset\nconst shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nconst imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nfunction isLength(value) {\n  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);\n}\nfunction isArbitraryLength(value) {\n  return getIsArbitraryValue(value, 'length', isLengthOnly);\n}\nfunction isNumber(value) {\n  return Boolean(value) && !Number.isNaN(Number(value));\n}\nfunction isArbitraryNumber(value) {\n  return getIsArbitraryValue(value, 'number', isNumber);\n}\nfunction isInteger(value) {\n  return Boolean(value) && Number.isInteger(Number(value));\n}\nfunction isPercent(value) {\n  return value.endsWith('%') && isNumber(value.slice(0, -1));\n}\nfunction isArbitraryValue(value) {\n  return arbitraryValueRegex.test(value);\n}\nfunction isTshirtSize(value) {\n  return tshirtUnitRegex.test(value);\n}\nconst sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);\nfunction isArbitrarySize(value) {\n  return getIsArbitraryValue(value, sizeLabels, isNever);\n}\nfunction isArbitraryPosition(value) {\n  return getIsArbitraryValue(value, 'position', isNever);\n}\nconst imageLabels = /*#__PURE__*/new Set(['image', 'url']);\nfunction isArbitraryImage(value) {\n  return getIsArbitraryValue(value, imageLabels, isImage);\n}\nfunction isArbitraryShadow(value) {\n  return getIsArbitraryValue(value, '', isShadow);\n}\nfunction isAny() {\n  return true;\n}\nfunction getIsArbitraryValue(value, label, testValue) {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return typeof label === 'string' ? result[1] === label : label.has(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n}\nfunction isLengthOnly(value) {\n  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\n  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\n}\nfunction isNever() {\n  return false;\n}\nfunction isShadow(value) {\n  return shadowRegex.test(value);\n}\nfunction isImage(value) {\n  return imageRegex.test(value);\n}\nconst validators = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  isAny,\n  isArbitraryImage,\n  isArbitraryLength,\n  isArbitraryNumber,\n  isArbitraryPosition,\n  isArbitraryShadow,\n  isArbitrarySize,\n  isArbitraryValue,\n  isInteger,\n  isLength,\n  isNumber,\n  isPercent,\n  isTshirtSize\n}, Symbol.toStringTag, {\n  value: 'Module'\n});\nfunction getDefaultConfig() {\n  const colors = fromTheme('colors');\n  const spacing = fromTheme('spacing');\n  const blur = fromTheme('blur');\n  const brightness = fromTheme('brightness');\n  const borderColor = fromTheme('borderColor');\n  const borderRadius = fromTheme('borderRadius');\n  const borderSpacing = fromTheme('borderSpacing');\n  const borderWidth = fromTheme('borderWidth');\n  const contrast = fromTheme('contrast');\n  const grayscale = fromTheme('grayscale');\n  const hueRotate = fromTheme('hueRotate');\n  const invert = fromTheme('invert');\n  const gap = fromTheme('gap');\n  const gradientColorStops = fromTheme('gradientColorStops');\n  const gradientColorStopPositions = fromTheme('gradientColorStopPositions');\n  const inset = fromTheme('inset');\n  const margin = fromTheme('margin');\n  const opacity = fromTheme('opacity');\n  const padding = fromTheme('padding');\n  const saturate = fromTheme('saturate');\n  const scale = fromTheme('scale');\n  const sepia = fromTheme('sepia');\n  const skew = fromTheme('skew');\n  const space = fromTheme('space');\n  const translate = fromTheme('translate');\n  const getOverscroll = () => ['auto', 'contain', 'none'];\n  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];\n  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue, spacing];\n  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];\n  const getLengthWithEmptyAndArbitrary = () => ['', isLength, isArbitraryLength];\n  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber, isArbitraryValue];\n  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];\n  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];\n  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];\n  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];\n  const getZeroAndEmpty = () => ['', '0', isArbitraryValue];\n  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];\n  const getNumber = () => [isNumber, isArbitraryNumber];\n  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];\n  return {\n    cacheSize: 500,\n    separator: ':',\n    theme: {\n      colors: [isAny],\n      spacing: [isLength, isArbitraryLength],\n      blur: ['none', '', isTshirtSize, isArbitraryValue],\n      brightness: getNumber(),\n      borderColor: [colors],\n      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],\n      borderSpacing: getSpacingWithArbitrary(),\n      borderWidth: getLengthWithEmptyAndArbitrary(),\n      contrast: getNumber(),\n      grayscale: getZeroAndEmpty(),\n      hueRotate: getNumberAndArbitrary(),\n      invert: getZeroAndEmpty(),\n      gap: getSpacingWithArbitrary(),\n      gradientColorStops: [colors],\n      gradientColorStopPositions: [isPercent, isArbitraryLength],\n      inset: getSpacingWithAutoAndArbitrary(),\n      margin: getSpacingWithAutoAndArbitrary(),\n      opacity: getNumber(),\n      padding: getSpacingWithArbitrary(),\n      saturate: getNumber(),\n      scale: getNumber(),\n      sepia: getZeroAndEmpty(),\n      skew: getNumberAndArbitrary(),\n      space: getSpacingWithArbitrary(),\n      translate: getSpacingWithArbitrary()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: ['auto', 'square', 'video', isArbitraryValue]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: ['container'],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isTshirtSize]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      'break-after': [{\n        'break-after': getBreaks()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      'break-before': [{\n        'break-before': getBreaks()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      'break-inside': [{\n        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      'box-decoration': [{\n        'box-decoration': ['slice', 'clone']\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: ['border', 'content']\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: ['right', 'left', 'none', 'start', 'end']\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: ['left', 'right', 'both', 'none', 'start', 'end']\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: ['isolate', 'isolation-auto'],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      'object-fit': [{\n        object: ['contain', 'cover', 'fill', 'none', 'scale-down']\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      'object-position': [{\n        object: [...getPositions(), isArbitraryValue]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: getOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-x': [{\n        'overflow-x': getOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-y': [{\n        'overflow-y': getOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-x': [{\n        'overscroll-x': getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-y': [{\n        'overscroll-y': getOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [inset]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-x': [{\n        'inset-x': [inset]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-y': [{\n        'inset-y': [inset]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [inset]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [inset]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [inset]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [inset]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [inset]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [inset]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: ['visible', 'invisible', 'collapse'],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: ['auto', isInteger, isArbitraryValue]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: getSpacingWithAutoAndArbitrary()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      'flex-direction': [{\n        flex: ['row', 'row-reverse', 'col', 'col-reverse']\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      'flex-wrap': [{\n        flex: ['wrap', 'wrap-reverse', 'nowrap']\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: getZeroAndEmpty()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: getZeroAndEmpty()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: ['first', 'last', 'none', isInteger, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      'grid-cols': [{\n        'grid-cols': [isAny]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start-end': [{\n        col: ['auto', {\n          span: ['full', isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start': [{\n        'col-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-end': [{\n        'col-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      'grid-rows': [{\n        'grid-rows': [isAny]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start-end': [{\n        row: ['auto', {\n          span: [isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start': [{\n        'row-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-end': [{\n        'row-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      'grid-flow': [{\n        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      'auto-cols': [{\n        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      'auto-rows': [{\n        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [gap]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-x': [{\n        'gap-x': [gap]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-y': [{\n        'gap-y': [gap]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      'justify-content': [{\n        justify: ['normal', ...getAlign()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      'justify-items': [{\n        'justify-items': ['start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      'justify-self': [{\n        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      'align-content': [{\n        content: ['normal', ...getAlign(), 'baseline']\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      'align-items': [{\n        items: ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      'align-self': [{\n        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      'place-content': [{\n        'place-content': [...getAlign(), 'baseline']\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      'place-items': [{\n        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      'place-self': [{\n        'place-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [padding]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [padding]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [padding]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [padding]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [padding]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [padding]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [padding]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [padding]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [padding]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [margin]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [margin]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [margin]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [margin]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [margin]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [margin]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [margin]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [margin]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [margin]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x': [{\n        'space-x': [space]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x-reverse': ['space-x-reverse'],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y': [{\n        'space-y': [space]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y-reverse': ['space-y-reverse'],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue, spacing]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      'min-w': [{\n        'min-w': [isArbitraryValue, spacing, 'min', 'max', 'fit']\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      'max-w': [{\n        'max-w': [isArbitraryValue, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {\n          screen: [isTshirtSize]\n        }, isTshirtSize]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      'min-h': [{\n        'min-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      'max-h': [{\n        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      'font-size': [{\n        text: ['base', isTshirtSize, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      'font-smoothing': ['antialiased', 'subpixel-antialiased'],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      'font-style': ['italic', 'not-italic'],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      'font-weight': [{\n        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      'font-family': [{\n        font: [isAny]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-normal': ['normal-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-ordinal': ['ordinal'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-slashed-zero': ['slashed-zero'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-figure': ['lining-nums', 'oldstyle-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-spacing': ['proportional-nums', 'tabular-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      'line-clamp': [{\n        'line-clamp': ['none', isNumber, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength, isArbitraryValue]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      'list-image': [{\n        'list-image': ['none', isArbitraryValue]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      'list-style-type': [{\n        list: ['none', 'disc', 'decimal', isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      'list-style-position': [{\n        list: ['inside', 'outside']\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      'placeholder-color': [{\n        placeholder: [colors]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      'placeholder-opacity': [{\n        'placeholder-opacity': [opacity]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      'text-alignment': [{\n        text: ['left', 'center', 'right', 'justify', 'start', 'end']\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      'text-color': [{\n        text: [colors]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      'text-opacity': [{\n        'text-opacity': [opacity]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      'text-decoration-style': [{\n        decoration: [...getLineStyles(), 'wavy']\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      'text-decoration-thickness': [{\n        decoration: ['auto', 'from-font', isLength, isArbitraryLength]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      'underline-offset': [{\n        'underline-offset': ['auto', isLength, isArbitraryValue]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      'text-decoration-color': [{\n        decoration: [colors]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      'text-wrap': [{\n        text: ['wrap', 'nowrap', 'balance', 'pretty']\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: getSpacingWithArbitrary()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      'vertical-align': [{\n        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: ['normal', 'words', 'all', 'keep']\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: ['none', 'manual', 'auto']\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: ['none', isArbitraryValue]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      'bg-attachment': [{\n        bg: ['fixed', 'local', 'scroll']\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      'bg-clip': [{\n        'bg-clip': ['border', 'padding', 'content', 'text']\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      'bg-opacity': [{\n        'bg-opacity': [opacity]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      'bg-origin': [{\n        'bg-origin': ['border', 'padding', 'content']\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      'bg-position': [{\n        bg: [...getPositions(), isArbitraryPosition]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      'bg-repeat': [{\n        bg: ['no-repeat', {\n          repeat: ['', 'x', 'y', 'round', 'space']\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      'bg-size': [{\n        bg: ['auto', 'cover', 'contain', isArbitrarySize]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      'bg-image': [{\n        bg: ['none', {\n          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']\n        }, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      'bg-color': [{\n        bg: [colors]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from-pos': [{\n        from: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via-pos': [{\n        via: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to-pos': [{\n        to: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from': [{\n        from: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via': [{\n        via: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to': [{\n        to: [gradientColorStops]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [borderRadius]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-s': [{\n        'rounded-s': [borderRadius]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-e': [{\n        'rounded-e': [borderRadius]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-t': [{\n        'rounded-t': [borderRadius]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-r': [{\n        'rounded-r': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-b': [{\n        'rounded-b': [borderRadius]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-l': [{\n        'rounded-l': [borderRadius]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ss': [{\n        'rounded-ss': [borderRadius]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-se': [{\n        'rounded-se': [borderRadius]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ee': [{\n        'rounded-ee': [borderRadius]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-es': [{\n        'rounded-es': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tl': [{\n        'rounded-tl': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tr': [{\n        'rounded-tr': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-br': [{\n        'rounded-br': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-bl': [{\n        'rounded-bl': [borderRadius]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w': [{\n        border: [borderWidth]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-x': [{\n        'border-x': [borderWidth]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-y': [{\n        'border-y': [borderWidth]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-s': [{\n        'border-s': [borderWidth]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-e': [{\n        'border-e': [borderWidth]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-t': [{\n        'border-t': [borderWidth]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-r': [{\n        'border-r': [borderWidth]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-b': [{\n        'border-b': [borderWidth]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-l': [{\n        'border-l': [borderWidth]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      'border-opacity': [{\n        'border-opacity': [opacity]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      'border-style': [{\n        border: [...getLineStyles(), 'hidden']\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x': [{\n        'divide-x': [borderWidth]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x-reverse': ['divide-x-reverse'],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y': [{\n        'divide-y': [borderWidth]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y-reverse': ['divide-y-reverse'],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      'divide-opacity': [{\n        'divide-opacity': [opacity]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      'divide-style': [{\n        divide: getLineStyles()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color': [{\n        border: [borderColor]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-x': [{\n        'border-x': [borderColor]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-y': [{\n        'border-y': [borderColor]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-t': [{\n        'border-t': [borderColor]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-r': [{\n        'border-r': [borderColor]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-b': [{\n        'border-b': [borderColor]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-l': [{\n        'border-l': [borderColor]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      'divide-color': [{\n        divide: [borderColor]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      'outline-style': [{\n        outline: ['', ...getLineStyles()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      'outline-offset': [{\n        'outline-offset': [isLength, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      'outline-w': [{\n        outline: [isLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      'outline-color': [{\n        outline: [colors]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w': [{\n        ring: getLengthWithEmptyAndArbitrary()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w-inset': ['ring-inset'],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      'ring-color': [{\n        ring: [colors]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      'ring-opacity': [{\n        'ring-opacity': [opacity]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      'ring-offset-w': [{\n        'ring-offset': [isLength, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      'ring-offset-color': [{\n        'ring-offset': [colors]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      'shadow-color': [{\n        shadow: [isAny]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [opacity]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      'mix-blend': [{\n        'mix-blend': [...getBlendModes(), 'plus-lighter', 'plus-darker']\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      'bg-blend': [{\n        'bg-blend': getBlendModes()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: ['', 'none']\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [blur]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [brightness]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [contrast]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      'drop-shadow': [{\n        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [grayscale]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      'hue-rotate': [{\n        'hue-rotate': [hueRotate]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [invert]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [saturate]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [sepia]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      'backdrop-filter': [{\n        'backdrop-filter': ['', 'none']\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      'backdrop-blur': [{\n        'backdrop-blur': [blur]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      'backdrop-brightness': [{\n        'backdrop-brightness': [brightness]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      'backdrop-contrast': [{\n        'backdrop-contrast': [contrast]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      'backdrop-grayscale': [{\n        'backdrop-grayscale': [grayscale]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      'backdrop-hue-rotate': [{\n        'backdrop-hue-rotate': [hueRotate]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      'backdrop-invert': [{\n        'backdrop-invert': [invert]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      'backdrop-opacity': [{\n        'backdrop-opacity': [opacity]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      'backdrop-saturate': [{\n        'backdrop-saturate': [saturate]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      'backdrop-sepia': [{\n        'backdrop-sepia': [sepia]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      'border-collapse': [{\n        border: ['collapse', 'separate']\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing': [{\n        'border-spacing': [borderSpacing]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-x': [{\n        'border-spacing-x': [borderSpacing]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-y': [{\n        'border-spacing-y': [borderSpacing]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      'table-layout': [{\n        table: ['auto', 'fixed']\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: ['top', 'bottom']\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: getNumberAndArbitrary()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: getNumberAndArbitrary()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: ['', 'gpu', 'none']\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [scale]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-x': [{\n        'scale-x': [scale]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-y': [{\n        'scale-y': [scale]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [isInteger, isArbitraryValue]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-x': [{\n        'translate-x': [translate]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-y': [{\n        'translate-y': [translate]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-x': [{\n        'skew-x': [skew]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-y': [{\n        'skew-y': [skew]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      'transform-origin': [{\n        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: ['auto', colors]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: ['none', 'auto']\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      'caret-color': [{\n        caret: [colors]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      'pointer-events': [{\n        'pointer-events': ['none', 'auto']\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: ['none', 'y', 'x', '']\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      'scroll-behavior': [{\n        scroll: ['auto', 'smooth']\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-m': [{\n        'scroll-m': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mx': [{\n        'scroll-mx': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-my': [{\n        'scroll-my': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ms': [{\n        'scroll-ms': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-me': [{\n        'scroll-me': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mt': [{\n        'scroll-mt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mr': [{\n        'scroll-mr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mb': [{\n        'scroll-mb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ml': [{\n        'scroll-ml': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-p': [{\n        'scroll-p': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-px': [{\n        'scroll-px': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-py': [{\n        'scroll-py': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-ps': [{\n        'scroll-ps': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pe': [{\n        'scroll-pe': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pt': [{\n        'scroll-pt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pr': [{\n        'scroll-pr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pb': [{\n        'scroll-pb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pl': [{\n        'scroll-pl': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      'snap-align': [{\n        snap: ['start', 'end', 'center', 'align-none']\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      'snap-stop': [{\n        snap: ['normal', 'always']\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-type': [{\n        snap: ['none', 'x', 'y', 'both']\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-strictness': [{\n        snap: ['mandatory', 'proximity']\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: ['auto', 'none', 'manipulation']\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-x': [{\n        'touch-pan': ['x', 'left', 'right']\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-y': [{\n        'touch-pan': ['y', 'up', 'down']\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-pz': ['touch-pinch-zoom'],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: ['none', 'text', 'all', 'auto']\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      'will-change': [{\n        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [colors, 'none']\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      'stroke-w': [{\n        stroke: [isLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [colors, 'none']\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: ['sr-only', 'not-sr-only'],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      'forced-color-adjust': [{\n        'forced-color-adjust': ['auto', 'none']\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: ['overflow-x', 'overflow-y'],\n      overscroll: ['overscroll-x', 'overscroll-y'],\n      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],\n      'inset-x': ['right', 'left'],\n      'inset-y': ['top', 'bottom'],\n      flex: ['basis', 'grow', 'shrink'],\n      gap: ['gap-x', 'gap-y'],\n      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],\n      px: ['pr', 'pl'],\n      py: ['pt', 'pb'],\n      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],\n      mx: ['mr', 'ml'],\n      my: ['mt', 'mb'],\n      size: ['w', 'h'],\n      'font-size': ['leading'],\n      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],\n      'fvn-ordinal': ['fvn-normal'],\n      'fvn-slashed-zero': ['fvn-normal'],\n      'fvn-figure': ['fvn-normal'],\n      'fvn-spacing': ['fvn-normal'],\n      'fvn-fraction': ['fvn-normal'],\n      'line-clamp': ['display', 'overflow'],\n      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],\n      'rounded-s': ['rounded-ss', 'rounded-es'],\n      'rounded-e': ['rounded-se', 'rounded-ee'],\n      'rounded-t': ['rounded-tl', 'rounded-tr'],\n      'rounded-r': ['rounded-tr', 'rounded-br'],\n      'rounded-b': ['rounded-br', 'rounded-bl'],\n      'rounded-l': ['rounded-tl', 'rounded-bl'],\n      'border-spacing': ['border-spacing-x', 'border-spacing-y'],\n      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],\n      'border-w-x': ['border-w-r', 'border-w-l'],\n      'border-w-y': ['border-w-t', 'border-w-b'],\n      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],\n      'border-color-x': ['border-color-r', 'border-color-l'],\n      'border-color-y': ['border-color-t', 'border-color-b'],\n      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],\n      'scroll-mx': ['scroll-mr', 'scroll-ml'],\n      'scroll-my': ['scroll-mt', 'scroll-mb'],\n      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],\n      'scroll-px': ['scroll-pr', 'scroll-pl'],\n      'scroll-py': ['scroll-pt', 'scroll-pb'],\n      touch: ['touch-x', 'touch-y', 'touch-pz'],\n      'touch-x': ['touch'],\n      'touch-y': ['touch'],\n      'touch-pz': ['touch']\n    },\n    conflictingClassGroupModifiers: {\n      'font-size': ['leading']\n    }\n  };\n}\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nfunction mergeConfigs(baseConfig, {\n  cacheSize,\n  prefix,\n  separator,\n  experimentalParseClassName,\n  extend = {},\n  override = {}\n}) {\n  overrideProperty(baseConfig, 'cacheSize', cacheSize);\n  overrideProperty(baseConfig, 'prefix', prefix);\n  overrideProperty(baseConfig, 'separator', separator);\n  overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);\n  for (const configKey in override) {\n    overrideConfigProperties(baseConfig[configKey], override[configKey]);\n  }\n  for (const key in extend) {\n    mergeConfigProperties(baseConfig[key], extend[key]);\n  }\n  return baseConfig;\n}\nfunction overrideProperty(baseObject, overrideKey, overrideValue) {\n  if (overrideValue !== undefined) {\n    baseObject[overrideKey] = overrideValue;\n  }\n}\nfunction overrideConfigProperties(baseObject, overrideObject) {\n  if (overrideObject) {\n    for (const key in overrideObject) {\n      overrideProperty(baseObject, key, overrideObject[key]);\n    }\n  }\n}\nfunction mergeConfigProperties(baseObject, mergeObject) {\n  if (mergeObject) {\n    for (const key in mergeObject) {\n      const mergeValue = mergeObject[key];\n      if (mergeValue !== undefined) {\n        baseObject[key] = (baseObject[key] || []).concat(mergeValue);\n      }\n    }\n  }\n}\nfunction extendTailwindMerge(configExtension, ...createConfig) {\n  return typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\n}\nconst twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);\nexport { createTailwindMerge, extendTailwindMerge, fromTheme, getDefaultConfig, mergeConfigs, twJoin, twMerge, validators };\n//# sourceMappingURL=bundle-mjs.mjs.map\n","import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n}\n"],"names":["sides","min","Math","max","round","floor","createCoords","v","x","y","oppositeSideMap","left","right","bottom","top","oppositeAlignmentMap","start","end","clamp","value","evaluate","param","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","includes","getAlignmentAxis","getOppositeAlignmentPlacement","replace","alignment","getOppositePlacement","side","getPaddingObject","padding","expandPaddingObject","rectToClientRect","rect","width","height","computeCoordsFromPlacement","_ref","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","async","detectOverflow","state","options","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","getSideOffsets","overflow","isAnySideFullyClipped","some","getNodeName","node","isNode","nodeName","toLowerCase","getWindow","_node$ownerDocument","ownerDocument","defaultView","window","document","documentElement","Node","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","test","isTableElement","isTopLayer","selector","matches","e","isContainingBlock","webkit","isWebKit","css","transform","perspective","containerType","backdropFilter","filter","willChange","contain","CSS","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","scrollX","scrollY","getParentNode","result","assignedSlot","parentNode","host","getNearestOverflowAncestor","body","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","concat","visualViewport","frameElement","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","direction","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","position","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","isStaticPositioned","getTrueOffsetParent","polyfill","svgOffsetParent","currentNode","getContainingBlock","topLayer","clippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","getClippingElementAncestors","this","_c","firstClippingAncestor","clippingRect","reduce","accRect","getElementRects","data","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","getClientRects","Array","from","isRTL","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","onMove","timeoutId","io","root","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","observe","observeMove","frameId","reobserveFrame","resizeObserver","firstEntry","target","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","removeEventListener","offset","name","fn","_middlewareData$offse","_middlewareData$arrow","middlewareData","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","convertValueToCoords","arrow","alignmentOffset","shift","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","flip","_middlewareData$flip","initialPlacement","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","initialSideAxis","isBasePlacement","oppositePlacement","getExpandedPlacements","hasFallbackAxisSideDirection","push","isStart","lr","rl","tb","bt","getSideList","map","getOppositeAxisPlacements","placements","overflows","overflowsData","length","mainAlignmentSide","getAlignmentSides","every","_middlewareData$flip2","_overflowsData$filter","nextIndex","index","nextPlacement","reset","resetPlacement","d","sort","a","b","_overflowsData$filter2","currentSideAxis","acc","size","apply","isYAxis","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hide","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","arrowDimensions","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","shouldAddOffset","centerOffset","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","computePosition","Map","mergedOptions","platformWithCache","config","middleware","validMiddleware","Boolean","statefulPlacement","resetCount","i","nextX","nextY","computePosition$1","isComponentPublicInstance","$el","toValue","source","unref","getDPR","devicePixelRatio","roundByDPR","dpr","Q","t","n","Symbol","r","ol","Error","toString","isArray","join","ll","zt","originalEvent","l","CustomEvent","bubbles","cancelable","detail","once","dispatchEvent","mt","ur","Ne","o","Je","WorkerGlobalScope","globalThis","Qr","Object","prototype","ei","call","Va","No","ti","navigator","userAgent","maxTouchPoints","xl","Dt","sl","s","oi","eventFilter","te","Promise","resolve","thisArg","args","then","catch","_l","zo","pause","resume","isActive","u","I","Ka","ni","stop","si","vt","Vn","Be","Ut","je","c","p","f","flatMap","g","immediate","flush","jn","a2","eventName","dedupe","key","di","repeat","ae","clone","deep","defaultValue","shouldEmit","emit","$emit","bind","proxy","m","S","h","JSON","parse","stringify","pi","Zr","D","E","P","le","B","Ua","type","_e","children","gn","getPrototypeOf","iterator","toStringTag","Pn","assign","yi","Ga","gi","wi","il","run","Yr","values","scrollBody","style","paddingRight","marginRight","pointerEvents","removeProperty","_a","innerWidth","margin","setProperty","touches","preventDefault","ha","random","Ci","delete","Re","emits","console","warn","__name","cr","dl","Bt","keys","props","default","pr","vnode","xe","T","nextElementSibling","exposed","defineProperty","enumerable","configurable","forwardRef","currentRef","currentElement","Il","Set","on","add","off","trigger","all","ia","currentTarget","clientX","clientY","abs","xi","Si","Ei","slice","pop","$i","Di","ye","contains","Pi","hasAttribute","isPointerInTransit","onPointerExit","Vt","WeakMap","Pa","Da","Cn","Tl","Ti","error","Ii","has","getAttribute","setAttribute","clear","removeAttribute","Ri","Bi","querySelectorAll","Ai","me","useId","Al","dispatch","Xn","w","inheritAttrs","setup","attrs","slots","findIndex","fr","ref","k","class","Fn","startsWith","O","asChild","as","String","pt","$a","animationName","Pe","present","required","forceMount","expose","ne","isPresent","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","Ie","Fi","parent","firstElementChild","tt","Wi","ji","defineComponent","open","defaultOpen","modal","openModal","onOpenChange","onOpenToggle","contentId","titleId","descriptionId","triggerElement","contentElement","C","$slots","Ui","se","_","onClick","ht","to","disabled","ja","Wt","pe","hv","K","j","Vl","closest","dataset","dismissableLayer","querySelector","indexOf","We","Ma","layersRoot","layersWithOutsidePointerEventsDisabled","branches","yt","disableOutsidePointerEvents","pointerType","onPointerDownCapture","Fl","defaultPrevented","onFocusCapture","onBlurCapture","Ll","Oe","onPointerdownCapture","wn","_n","Ho","Jn","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","tagName","hidden","FILTER_SKIP","tabIndex","FILTER_ACCEPT","nextNode","Wo","Zi","upTo","visibility","parentElement","dt","select","focus","activeElement","preventScroll","HTMLInputElement","Ji","Qi","qr","jo","splice","Ya","loop","trapped","unshift","remove","eu","paused","altKey","ctrlKey","metaKey","reverse","Xi","shiftKey","relatedTarget","MutationObserver","childList","subtree","Oa","tu","ref_key","tabindex","onKeydown","Qn","zl","trapFocus","onMountAutoFocus","onUnmountAutoFocus","Y","id","role","$attrs","onDismiss","onEscapeKeyDown","onFocusOutside","onInteractOutside","onPointerDownOutside","pu","ya","onCloseAutoFocus","button","fu","vu","mu","hu","Kl","yu","gu","Ul","Uu","It","anchor","onAnchorChange","Tt","Gu","qu","arrowWidth","arrowHeight","Bn","_b","Yu","Xu","Pt","mergeDefaults","sideOffset","align","alignOffset","avoidCollisions","collisionBoundary","collisionPadding","arrowPadding","sticky","hideWhenDetached","updatePositionStrategy","prioritizePosition","borderBoxSize","inlineSize","blockSize","box","Rl","Mn","Ur","Er","Fo","Pr","Dr","$r","A","L","U","H","J","N","F","arrow$1","Ir","floatingStyles","isPositioned","whileElementsMountedOption","whileElementsMounted","openOption","computed","_toValue","middlewareOption","placementOption","_toValue2","strategyOption","_toValue3","transformOption","_toValue4","referenceElement","floatingElement","shallowRef","initialStyles","xVal","yVal","whileElementsMountedCleanup","watch","getCurrentScope","onScopeDispose","shallowReadonly","xr","Sr","R","zIndex","M","V","placedSide","onArrowChange","arrowX","arrowY","shouldHideArrow","ce","minWidth","transformOrigin","animation","wo","Qd","gh","openDelay","closeDelay","onOpen","onClose","hasSelectionRef","isPointerDownOnContentRef","isPointerInTransitRef","Tn","bh","onPointerenter","onPointerleave","onFocus","onBlur","Ch","tc","ltr","li","getSelection","userSelect","webkitUserSelect","ec","ie","WebkitUserSelect","onPointerdown","wh","matchMedia","uf","CLASS_PART_SEPARATOR","createClassGroupUtils","classMap","theme","prefix","nextPart","validators","prefixedClassGroupEntries","classGroupEntries","classGroupId","classGroup","classDefinition","fromEntries","getPrefixedClassGroupEntries","classGroups","processClassesRecursively","createClassMap","conflictingClassGroups","conflictingClassGroupModifiers","getClassGroupId","className","classParts","getGroupRecursive","arbitraryPropertyRegex","arbitraryPropertyClassName","exec","property","substring","getGroupIdForArbitraryProperty","getConflictingClassGroupIds","hasPostfixModifier","conflicts","classPartObject","currentClassPart","nextClassPartObject","classGroupFromNextClassPart","classRest","find","validator","isThemeGetter","getPart","path","currentClassPartObject","pathPart","createLruCache","maxCacheSize","cacheSize","previousCache","IMPORTANT_MODIFIER","createParseClassName","separator","experimentalParseClassName","isSeparatorSingleCharacter","firstSeparatorCharacter","separatorLength","parseClassName","modifiers","postfixModifierPosition","bracketDepth","modifierStart","currentCharacter","baseClassNameWithImportantModifier","hasImportantModifier","baseClassName","maybePostfixModifierPosition","SPLIT_CLASSES_REGEX","twJoin","argument","resolvedValue","string","arguments","mix","createTailwindMerge","createConfigFirst","createConfigRest","configUtils","cacheGet","cacheSet","functionToCall","classList","previousConfig","createConfigCurrent","createConfigUtils","tailwindMerge","classGroupsInConflict","trim","originalClassName","isTailwindClass","variantModifier","sortedModifiers","unsortedModifiers","modifier","sortModifiers","modifierId","parsed","classId","group","mergeClassList","fromTheme","themeGetter","arbitraryValueRegex","fractionRegex","stringLengths","tshirtUnitRegex","lengthUnitRegex","colorFunctionRegex","shadowRegex","imageRegex","isLength","isNumber","isArbitraryLength","getIsArbitraryValue","isLengthOnly","isNaN","isArbitraryNumber","isInteger","isPercent","endsWith","isArbitraryValue","isTshirtSize","sizeLabels","isArbitrarySize","isNever","isArbitraryPosition","imageLabels","isArbitraryImage","isImage","isArbitraryShadow","isShadow","isAny","label","testValue","getDefaultConfig","colors","spacing","blur","brightness","borderColor","borderRadius","borderSpacing","borderWidth","contrast","grayscale","hueRotate","invert","gap","gradientColorStops","gradientColorStopPositions","inset","opacity","saturate","sepia","skew","space","translate","getSpacingWithAutoAndArbitrary","getSpacingWithArbitrary","getLengthWithEmptyAndArbitrary","getNumberWithAutoAndArbitrary","getZeroAndEmpty","getNumber","getNumberAndArbitrary","aspect","container","columns","float","isolation","object","overscroll","z","basis","flex","grow","shrink","order","col","span","row","justify","content","items","self","px","py","ps","pb","pl","mx","my","ms","mr","mb","ml","screen","text","font","tracking","leading","placeholder","decoration","indent","whitespace","break","hyphens","bg","via","rounded","border","divide","outline","ring","shadow","table","caption","transition","duration","ease","delay","animate","rotate","origin","accent","appearance","cursor","caret","resize","snap","touch","fill","stroke","sr","twMerge","cn","inputs","clsx"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}